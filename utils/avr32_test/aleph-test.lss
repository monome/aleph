
aleph-test.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00008b80  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ac00  8000ac00  0000b000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001b60  8000ae00  8000ae00  0000b200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000524  00000008  8000c960  0000d008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  0000052c  8000ce84  0000d52c  2**0
                  ALLOC
  8 .bss          00002d60  00000530  00000530  00000000  2**2
                  ALLOC
  9 .heap         0000bd70  00003290  00003290  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000d52c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001450  00000000  00000000  0000d55c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002f23  00000000  00000000  0000e9ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ecad  00000000  00000000  000118cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006ae2  00000000  00000000  0004057c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00020ae0  00000000  00000000  0004705e  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000389c  00000000  00000000  00067b40  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00009d84  00000000  00000000  0006b3dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000b075  00000000  00000000  00075160  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 026e32aa  00000000  00000000  000801d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .flash_nvram  00010048  80040000  8000ce84  0000d800  2**2
                  ALLOC
 22 .debug_ranges 00002930  00000000  00000000  0276347f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe ff 00 04 	ld.w	pc,pc[4]
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	a0 6c       	st.h	r0[0xc],r12

Disassembly of section .text:

80002008 <smc_get_cs_size>:

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
}

unsigned char smc_get_cs_size(unsigned char cs)
{
80002008:	e0 68 05 30 	mov	r8,1328
  return smc_tab_cs_size[cs];
}
8000200c:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
80002010:	5e fc       	retal	r12
80002012:	d7 03       	nop

80002014 <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
80002014:	eb cd 40 c0 	pushm	r6-r7,lr
  // Enable SM mode for CS1 if necessary.
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
80002018:	fe 68 10 00 	mov	r8,-126976
8000201c:	f0 f9 01 24 	ld.w	r9,r8[292]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002026:	30 09       	mov	r9,0
#if UC3C
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80002028:	f0 f8 01 24 	ld.w	r8,r8[292]
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
8000202c:	fe 68 1c 00 	mov	r8,-123904
80002030:	91 49       	st.w	r8[0x10],r9
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002032:	ee 79 42 3f 	mov	r9,999999
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002036:	e0 6e 4d d3 	mov	lr,19923
8000203a:	ea 1e 10 62 	orh	lr,0x1062
static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
8000203e:	f8 09 00 0b 	add	r11,r12,r9
80002042:	e0 69 de 83 	mov	r9,56963
80002046:	ea 19 43 1b 	orh	r9,0x431b
8000204a:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000204e:	b3 8b       	lsr	r11,0x12
#else
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] &= ~(1 << AVR32_EBI_SDRAM_CS);
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
#endif
  // Setup SMC for NCS1
  SMC_CS_SETUP(1)
80002050:	f6 07 10 52 	mul	r7,r11,82
80002054:	ee c7 fc 19 	sub	r7,r7,-999
80002058:	ee 0e 06 46 	mulu.d	r6,r7,lr
8000205c:	0e 99       	mov	r9,r7
8000205e:	e0 67 00 a4 	mov	r7,164
80002062:	a7 89       	lsr	r9,0x6
80002064:	f6 07 02 47 	mul	r7,r11,r7
80002068:	f2 0a 15 10 	lsl	r10,r9,0x10
8000206c:	ee c7 fc 19 	sub	r7,r7,-999
80002070:	f5 e9 10 8c 	or	r12,r10,r9<<0x8
80002074:	ee 0e 06 46 	mulu.d	r6,r7,lr
80002078:	12 4c       	or	r12,r9
8000207a:	0e 9b       	mov	r11,r7
8000207c:	f9 e9 11 8c 	or	r12,r12,r9<<0x18
80002080:	a7 8b       	lsr	r11,0x6
80002082:	91 5c       	st.w	r8[0x14],r12
80002084:	12 3b       	cp.w	r11,r9
80002086:	f6 09 17 20 	movhs	r9,r11
8000208a:	12 4a       	or	r10,r9
8000208c:	e0 69 10 03 	mov	r9,4099
80002090:	91 6a       	st.w	r8[0x18],r10
80002092:	91 79       	st.w	r8[0x1c],r9
80002094:	31 49       	mov	r9,20
80002096:	e0 68 05 30 	mov	r8,1328
8000209a:	32 9b       	mov	r11,41
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
8000209c:	b0 99       	st.b	r8[0x1],r9
8000209e:	48 3c       	lddpc	r12,800020a8 <smc_init+0x94>
800020a0:	e0 a0 02 04 	rcall	800024a8 <gpio_enable_module>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
800020a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800020a8:	80 00       	ld.sh	r0,r0[0x0]
800020aa:	ae 00       	st.h	r7[0x0],r0

800020ac <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020ac:	fe 68 14 00 	mov	r8,-125952
800020b0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020b2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020b6:	91 09       	st.w	r8[0x0],r9
}
800020b8:	5e fc       	retal	r12

800020ba <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
800020ba:	e0 68 8a 3f 	mov	r8,35391
800020be:	ea 18 01 f7 	orh	r8,0x1f7
800020c2:	10 3c       	cp.w	r12,r8
800020c4:	e0 8b 00 0a 	brhi	800020d8 <flashc_set_bus_freq+0x1e>
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020c8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020cc:	30 0a       	mov	r10,0
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020ce:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020d0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020d4:	91 09       	st.w	r8[0x0],r9
800020d6:	5e fc       	retal	r12
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020d8:	fe 68 14 00 	mov	r8,-125952
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020dc:	30 1a       	mov	r10,1
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020de:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020e0:	f3 da d0 c1 	bfins	r9,r10,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020e4:	91 09       	st.w	r8[0x0],r9
800020e6:	5e fc       	retal	r12

800020e8 <flashc_default_wait_until_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
800020e8:	fe 6a 14 00 	mov	r10,-125952
}


void flashc_default_wait_until_ready(void)
{
	while (!flashc_is_ready());
800020ec:	30 09       	mov	r9,0
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
800020ee:	74 28       	ld.w	r8,r10[0x8]
}


void flashc_default_wait_until_ready(void)
{
	while (!flashc_is_ready());
800020f0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800020f4:	f2 08 18 00 	cp.b	r8,r9
800020f8:	cf b0       	breq	800020ee <flashc_default_wait_until_ready+0x6>
}
800020fa:	5e fc       	retal	r12

800020fc <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
800020fc:	eb cd 40 e0 	pushm	r5-r7,lr
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002100:	30 86       	mov	r6,8
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80002102:	18 97       	mov	r7,r12
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002104:	6c 08       	ld.w	r8,r6[0x0]
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80002106:	16 95       	mov	r5,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002108:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000210a:	fe 68 14 00 	mov	r8,-125952
8000210e:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80002110:	f1 d7 d0 06 	bfins	r8,r7,0x0,0x6
	if (page_number >= 0) {
80002114:	58 05       	cp.w	r5,0
80002116:	c0 35       	brlt	8000211c <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
80002118:	f1 d5 d1 10 	bfins	r8,r5,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
8000211c:	3a 5a       	mov	r10,-91
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
8000211e:	fe 69 14 00 	mov	r9,-125952
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
	u_avr32_flashc_fcmd.FCMD.cmd = command;
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80002122:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
80002126:	e0 6a 05 38 	mov	r10,1336
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
8000212a:	93 18       	st.w	r9[0x4],r8
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8000212c:	72 29       	ld.w	r9,r9[0x8]
8000212e:	e2 19 00 0c 	andl	r9,0xc,COH
80002132:	6c 08       	ld.w	r8,r6[0x0]
	flashc_wait_until_ready();
80002134:	95 09       	st.w	r10[0x0],r9
}
80002136:	5d 18       	icall	r8
80002138:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000213c <flashc_clear_page_buffer>:
8000213c:	d4 01       	pushm	lr
8000213e:	3f fb       	mov	r11,-1
80002140:	30 3c       	mov	r12,3
80002142:	cd df       	rcall	800020fc <flashc_issue_command>
//! @{


void flashc_clear_page_buffer(void)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80002144:	d8 02       	popm	pc
}
80002146:	d7 03       	nop

80002148 <flashc_quick_page_read>:
80002148:	d4 01       	pushm	lr
8000214a:	18 9b       	mov	r11,r12
}


bool flashc_quick_page_read(int page_number)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
8000214c:	30 cc       	mov	r12,12
8000214e:	cd 7f       	rcall	800020fc <flashc_issue_command>
80002150:	fe 68 14 00 	mov	r8,-125952
}


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80002154:	70 2c       	ld.w	r12,r8[0x8]
80002156:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1

bool flashc_quick_page_read(int page_number)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
	return flashc_is_page_erased();
}
8000215a:	d8 02       	popm	pc

8000215c <flashc_erase_page>:
8000215c:	eb cd 40 c0 	pushm	r6-r7,lr
80002160:	16 97       	mov	r7,r11
80002162:	18 9b       	mov	r11,r12

bool flashc_erase_page(int page_number, bool check)
{
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80002164:	30 2c       	mov	r12,2
80002166:	cc bf       	rcall	800020fc <flashc_issue_command>
80002168:	58 07       	cp.w	r7,0
	if (check) {
8000216a:	c0 31       	brne	80002170 <flashc_erase_page+0x14>
8000216c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002170:	e0 67 05 38 	mov	r7,1336
		unsigned int error_status = flashc_error_status;
		page_erased = flashc_quick_page_read(-1);
80002174:	3f fc       	mov	r12,-1
{
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
	if (check) {
		unsigned int error_status = flashc_error_status;
80002176:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
80002178:	ce 8f       	rcall	80002148 <flashc_quick_page_read>
8000217a:	6e 08       	ld.w	r8,r7[0x0]
		flashc_error_status |= error_status;
8000217c:	f1 e6 10 06 	or	r6,r8,r6
80002180:	8f 06       	st.w	r7[0x0],r6
80002182:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	}
	return page_erased;
}
80002186:	d7 03       	nop

80002188 <flashc_write_page>:
80002188:	d4 01       	pushm	lr
8000218a:	18 9b       	mov	r11,r12
8000218c:	30 1c       	mov	r12,1
8000218e:	cb 7f       	rcall	800020fc <flashc_issue_command>
80002190:	d8 02       	popm	pc
80002192:	d7 03       	nop

80002194 <flashc_quick_user_page_read>:


void flashc_write_page(int page_number)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
}
80002194:	d4 01       	pushm	lr
80002196:	30 fc       	mov	r12,15


bool flashc_quick_user_page_read(void)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80002198:	3f fb       	mov	r11,-1
8000219a:	cb 1f       	rcall	800020fc <flashc_issue_command>
8000219c:	fe 68 14 00 	mov	r8,-125952
}


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
800021a0:	70 2c       	ld.w	r12,r8[0x8]
800021a2:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1

bool flashc_quick_user_page_read(void)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
	return flashc_is_page_erased();
}
800021a6:	d8 02       	popm	pc

800021a8 <flashc_erase_user_page>:
800021a8:	eb cd 40 80 	pushm	r7,lr
800021ac:	3f fb       	mov	r11,-1
800021ae:	18 97       	mov	r7,r12


bool flashc_erase_user_page(bool check)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
800021b0:	30 ec       	mov	r12,14
800021b2:	ca 5f       	rcall	800020fc <flashc_issue_command>
800021b4:	58 07       	cp.w	r7,0
	return (check) ? flashc_quick_user_page_read() : true;
800021b6:	c0 31       	brne	800021bc <flashc_erase_user_page+0x14>
800021b8:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
800021bc:	ce cf       	rcall	80002194 <flashc_quick_user_page_read>
800021be:	e3 cd 80 80 	ldm	sp++,r7,pc
}
800021c2:	d7 03       	nop

800021c4 <flashc_write_user_page>:
800021c4:	d4 01       	pushm	lr
800021c6:	3f fb       	mov	r11,-1
800021c8:	30 dc       	mov	r12,13
800021ca:	c9 9f       	rcall	800020fc <flashc_issue_command>
800021cc:	d8 02       	popm	pc
800021ce:	d7 03       	nop

800021d0 <flashc_memset64>:


void flashc_write_user_page(void)
{
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
}
800021d0:	d4 31       	pushm	r0-r7,lr
800021d2:	21 3d       	sub	sp,76
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800021d4:	50 28       	stdsp	sp[0x8],r8
800021d6:	12 93       	mov	r3,r9
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800021d8:	30 08       	mov	r8,0
800021da:	30 09       	mov	r9,0
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800021dc:	50 5c       	stdsp	sp[0x14],r12
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
800021de:	fa e9 00 3c 	st.d	sp[60],r8
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
800021e2:	16 97       	mov	r7,r11
800021e4:	14 96       	mov	r6,r10
		256,
		384,
		512,
		768,
		1024,
	};
800021e6:	fe fb 02 52 	ld.w	r11,pc[594]
800021ea:	31 0a       	mov	r10,16
800021ec:	fa cc ff dc 	sub	r12,sp,-36
800021f0:	e0 a0 42 ca 	rcall	8000a784 <memcpy>
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800021f4:	fa c9 ff b4 	sub	r9,sp,-76
		384,
		512,
		768,
		1024,
	};
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
800021f8:	fe 68 14 00 	mov	r8,-125952
800021fc:	70 28       	ld.w	r8,r8[0x8]
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
800021fe:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
80002202:	f2 08 00 18 	add	r8,r9,r8<<0x1
	dest.u8ptr = dst;
80002206:	40 5a       	lddsp	r10,sp[0x14]
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
80002208:	f1 19 ff d8 	ld.uh	r9,r8[-40]
	dest.u8ptr = dst;
8000220c:	51 2a       	stdsp	sp[0x48],r10
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000220e:	ab 69       	lsl	r9,0xa
80002210:	fc 18 80 00 	movh	r8,0x8000
80002214:	f2 08 00 08 	add	r8,r9,r8
80002218:	50 68       	stdsp	sp[0x18],r8
	dest.u8ptr = dst;
8000221a:	14 91       	mov	r1,r10
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000221c:	58 06       	cp.w	r6,0
8000221e:	5c 27       	cpc	r7
80002220:	c1 80       	breq	80002250 <flashc_memset64+0x80>
80002222:	14 98       	mov	r8,r10
80002224:	2f 98       	sub	r8,-7
80002226:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
8000222a:	fa c9 ff b4 	sub	r9,sp,-76
8000222e:	10 09       	add	r9,r8
80002230:	f3 66 ff f0 	st.b	r9[-16],r6
		src >>= 8;
80002234:	0e 9a       	mov	r10,r7
80002236:	0c 99       	mov	r9,r6

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80002238:	20 18       	sub	r8,1
		source.u8[i] = src;
		src >>= 8;
8000223a:	a9 89       	lsr	r9,0x8
8000223c:	a9 8a       	lsr	r10,0x8
8000223e:	f3 e7 11 89 	or	r9,r9,r7<<0x18

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
80002242:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
		source.u8[i] = src;
		src >>= 8;
80002246:	14 97       	mov	r7,r10
80002248:	12 96       	mov	r6,r9
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000224a:	58 06       	cp.w	r6,0
8000224c:	5c 27       	cpc	r7
8000224e:	ce e1       	brne	8000222a <flashc_memset64+0x5a>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80002250:	40 59       	lddsp	r9,sp[0x14]

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80002252:	e0 68 ff ff 	mov	r8,65535
80002256:	ea 18 7f ff 	orh	r8,0x7fff
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
8000225a:	f2 03 00 03 	add	r3,r9,r3

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
8000225e:	10 39       	cp.w	r9,r8
80002260:	e0 8b 00 db 	brhi	80002416 <flashc_memset64+0x246>
		dest.u8ptr = AVR32_FLASH;
80002264:	fc 11 80 00 	movh	r1,0x8000
80002268:	51 21       	stdsp	sp[0x48],r1
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
8000226a:	e0 6a 02 00 	mov	r10,512
8000226e:	ea 1a 80 80 	orh	r10,0x8080
80002272:	14 33       	cp.w	r3,r10
80002274:	e0 88 00 c2 	brls	800023f8 <flashc_memset64+0x228>
80002278:	50 1a       	stdsp	sp[0x4],r10
8000227a:	14 98       	mov	r8,r10
8000227c:	14 93       	mov	r3,r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000227e:	f3 d8 c0 03 	bfextu	r9,r8,0x0,0x3
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80002282:	e0 18 fe 00 	andl	r8,0xfe00
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80002286:	50 49       	stdsp	sp[0x10],r9
80002288:	fa c2 ff cc 	sub	r2,sp,-52
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000228c:	e6 09 01 09 	sub	r9,r3,r9
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80002290:	50 38       	stdsp	sp[0xc],r8
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80002292:	2f 89       	sub	r9,-8
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80002294:	40 48       	lddsp	r8,sp[0x10]
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
80002296:	fa ca ff c4 	sub	r10,sp,-60
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000229a:	e4 08 00 08 	add	r8,r2,r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000229e:	50 89       	stdsp	sp[0x20],r9
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
800022a0:	50 78       	stdsp	sp[0x1c],r8
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
800022a2:	50 0a       	stdsp	sp[0x0],r10
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800022a4:	fa e6 00 3c 	ld.d	r6,sp[60]
800022a8:	30 05       	mov	r5,0
800022aa:	e0 64 05 38 	mov	r4,1336
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800022ae:	02 33       	cp.w	r3,r1
800022b0:	e0 88 00 8c 	brls	800023c8 <flashc_memset64+0x1f8>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800022b4:	c4 4f       	rcall	8000213c <flashc_clear_page_buffer>
		error_status |= flashc_error_status;
800022b6:	68 08       	ld.w	r8,r4[0x0]
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
800022b8:	fa e7 00 34 	st.d	sp[52],r6

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
800022bc:	10 45       	or	r5,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800022be:	02 9a       	mov	r10,r1
800022c0:	40 19       	lddsp	r9,sp[0x4]
800022c2:	e0 1a fe 00 	andl	r10,0xfe00

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800022c6:	f1 d1 c0 09 	bfextu	r8,r1,0x0,0x9
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800022ca:	f4 cc fe 00 	sub	r12,r10,-512
800022ce:	f2 0c 0d 4c 	min	r12,r9,r12

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
800022d2:	58 08       	cp.w	r8,0
800022d4:	c7 e0       	breq	800023d0 <flashc_memset64+0x200>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800022d6:	51 1a       	stdsp	sp[0x44],r10
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800022d8:	02 99       	mov	r9,r1
800022da:	e0 19 ff f8 	andl	r9,0xfff8
800022de:	12 9b       	mov	r11,r9
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800022e0:	12 3a       	cp.w	r10,r9
800022e2:	c1 52       	brcc	8000230c <flashc_memset64+0x13c>
800022e4:	14 98       	mov	r8,r10
800022e6:	12 9e       	mov	lr,r9
800022e8:	14 90       	mov	r0,r10
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
800022ea:	f0 ea 00 00 	ld.d	r10,r8[0]
800022ee:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800022f0:	10 39       	cp.w	r9,r8
800022f2:	fe 9b ff fc 	brhi	800022ea <flashc_memset64+0x11a>
800022f6:	e0 08 11 ff 	rsub	r8,r0,-1
800022fa:	1c 9b       	mov	r11,lr
800022fc:	12 08       	add	r8,r9
800022fe:	00 9a       	mov	r10,r0
80002300:	e0 18 ff f8 	andl	r8,0xfff8
80002304:	2f 88       	sub	r8,-8
80002306:	e0 08 00 08 	add	r8,r0,r8
8000230a:	51 18       	stdsp	sp[0x44],r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
8000230c:	e3 d1 c0 03 	bfextu	r1,r1,0x0,0x3
80002310:	c6 00       	breq	800023d0 <flashc_memset64+0x200>
80002312:	41 10       	lddsp	r0,sp[0x44]
80002314:	30 08       	mov	r8,0
80002316:	e0 08 00 0e 	add	lr,r0,r8
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
8000231a:	1d 8e       	ld.ub	lr,lr[0x0]
8000231c:	e4 08 0b 0e 	st.b	r2[r8],lr
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
80002320:	2f f8       	sub	r8,-1
80002322:	02 38       	cp.w	r8,r1
80002324:	cf 91       	brne	80002316 <flashc_memset64+0x146>
80002326:	e0 08 00 08 	add	r8,r0,r8
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
8000232a:	51 29       	stdsp	sp[0x48],r9
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000232c:	51 18       	stdsp	sp[0x44],r8

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
8000232e:	40 18       	lddsp	r8,sp[0x4]
80002330:	10 39       	cp.w	r9,r8
80002332:	c0 82       	brcc	80002342 <flashc_memset64+0x172>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
80002334:	12 9b       	mov	r11,r9
80002336:	fa e8 00 34 	ld.d	r8,sp[52]
8000233a:	b7 28       	st.d	r11++,r8
					flash_dword.u64 = source.u64;
8000233c:	fa e7 00 34 	st.d	sp[52],r6
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
80002340:	51 2b       	stdsp	sp[0x48],r11
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80002342:	16 1c       	sub	r12,r11
80002344:	a3 5c       	asr	r12,0x3
80002346:	c0 90       	breq	80002358 <flashc_memset64+0x188>
80002348:	16 99       	mov	r9,r11
8000234a:	18 98       	mov	r8,r12
			*dest.u64ptr++ = source.u64;
8000234c:	b3 26       	st.d	r9++,r6
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
8000234e:	20 18       	sub	r8,1
80002350:	cf e1       	brne	8000234c <flashc_memset64+0x17c>
80002352:	f6 0c 00 3b 	add	r11,r11,r12<<0x3
80002356:	51 2b       	stdsp	sp[0x48],r11
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80002358:	40 39       	lddsp	r9,sp[0xc]
8000235a:	12 3a       	cp.w	r10,r9
8000235c:	c1 e3       	brcs	80002398 <flashc_memset64+0x1c8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
8000235e:	51 13       	stdsp	sp[0x44],r3

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80002360:	40 48       	lddsp	r8,sp[0x10]
80002362:	58 08       	cp.w	r8,0
80002364:	c0 f0       	breq	80002382 <flashc_memset64+0x1b2>
80002366:	06 99       	mov	r9,r3
80002368:	40 78       	lddsp	r8,sp[0x1c]
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
8000236a:	13 3a       	ld.ub	r10,r9++
8000236c:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000236e:	40 0a       	lddsp	r10,sp[0x0]
80002370:	14 38       	cp.w	r8,r10
80002372:	cf c1       	brne	8000236a <flashc_memset64+0x19a>
80002374:	40 89       	lddsp	r9,sp[0x20]
80002376:	51 19       	stdsp	sp[0x44],r9
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80002378:	41 28       	lddsp	r8,sp[0x48]
8000237a:	fa ea 00 34 	ld.d	r10,sp[52]
8000237e:	b1 2a       	st.d	r8++,r10
80002380:	51 28       	stdsp	sp[0x48],r8
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80002382:	41 18       	lddsp	r8,sp[0x44]
80002384:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002388:	c0 80       	breq	80002398 <flashc_memset64+0x1c8>
					*tmp.u64ptr = *tmp.u64ptr;
8000238a:	f0 ea 00 00 	ld.d	r10,r8[0]
8000238e:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80002390:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002394:	cf b1       	brne	8000238a <flashc_memset64+0x1ba>
80002396:	51 18       	stdsp	sp[0x44],r8
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
80002398:	41 21       	lddsp	r1,sp[0x48]
8000239a:	fc 18 80 80 	movh	r8,0x8080
8000239e:	10 31       	cp.w	r1,r8
800023a0:	e0 8b 00 1a 	brhi	800023d4 <flashc_memset64+0x204>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
800023a4:	40 2a       	lddsp	r10,sp[0x8]
800023a6:	58 0a       	cp.w	r10,0
800023a8:	c1 d1       	brne	800023e2 <flashc_memset64+0x212>
				flashc_erase_page(-1, false);
				error_status |= flashc_error_status;
			}
			flashc_write_page(-1);
800023aa:	3f fc       	mov	r12,-1
800023ac:	ce ee       	rcall	80002188 <flashc_write_page>
800023ae:	68 08       	ld.w	r8,r4[0x0]
			error_status |= flashc_error_status;
800023b0:	40 69       	lddsp	r9,sp[0x18]

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
800023b2:	10 45       	or	r5,r8
			if (erase) {
				flashc_erase_page(-1, false);
				error_status |= flashc_error_status;
			}
			flashc_write_page(-1);
			error_status |= flashc_error_status;
800023b4:	02 39       	cp.w	r9,r1

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
800023b6:	e0 8b 00 05 	brhi	800023c0 <flashc_memset64+0x1f0>
800023ba:	fc 18 80 80 	movh	r8,0x8080
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800023be:	51 28       	stdsp	sp[0x48],r8
800023c0:	41 21       	lddsp	r1,sp[0x48]
			if (erase) {
				flashc_erase_user_page(false);
				error_status |= flashc_error_status;
			}
			flashc_write_user_page();
			error_status |= flashc_error_status;
800023c2:	02 33       	cp.w	r3,r1
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800023c4:	fe 9b ff 78 	brhi	800022b4 <flashc_memset64+0xe4>
800023c8:	89 05       	st.w	r4[0x0],r5
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
800023ca:	40 5c       	lddsp	r12,sp[0x14]

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
800023cc:	2e dd       	sub	sp,-76
800023ce:	d8 32       	popm	r0-r7,pc
800023d0:	41 2b       	lddsp	r11,sp[0x48]
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
800023d2:	cb 8b       	rjmp	80002342 <flashc_memset64+0x172>
800023d4:	40 28       	lddsp	r8,sp[0x8]
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
800023d6:	58 08       	cp.w	r8,0
800023d8:	c0 b1       	brne	800023ee <flashc_memset64+0x21e>
800023da:	cf 5e       	rcall	800021c4 <flashc_write_user_page>
				flashc_erase_user_page(false);
				error_status |= flashc_error_status;
			}
			flashc_write_user_page();
800023dc:	68 08       	ld.w	r8,r4[0x0]
800023de:	10 45       	or	r5,r8
			error_status |= flashc_error_status;
800023e0:	cf 0b       	rjmp	800023c0 <flashc_memset64+0x1f0>
800023e2:	30 0b       	mov	r11,0
800023e4:	3f fc       	mov	r12,-1

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
				flashc_erase_page(-1, false);
800023e6:	cb be       	rcall	8000215c <flashc_erase_page>
800023e8:	68 08       	ld.w	r8,r4[0x0]
800023ea:	10 45       	or	r5,r8
800023ec:	cd fb       	rjmp	800023aa <flashc_memset64+0x1da>
				error_status |= flashc_error_status;
800023ee:	30 0c       	mov	r12,0
800023f0:	cd ce       	rcall	800021a8 <flashc_erase_user_page>
800023f2:	68 08       	ld.w	r8,r4[0x0]
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
				flashc_erase_user_page(false);
800023f4:	10 45       	or	r5,r8
800023f6:	cf 2b       	rjmp	800023da <flashc_memset64+0x20a>
800023f8:	fc 19 80 80 	movh	r9,0x8080
				error_status |= flashc_error_status;
800023fc:	12 33       	cp.w	r3,r9
800023fe:	e0 8b 00 06 	brhi	8000240a <flashc_memset64+0x23a>
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80002402:	40 69       	lddsp	r9,sp[0x18]
80002404:	12 33       	cp.w	r3,r9
80002406:	f2 03 17 b0 	movhi	r3,r9
8000240a:	06 9a       	mov	r10,r3
8000240c:	06 98       	mov	r8,r3
8000240e:	e0 1a ff f8 	andl	r10,0xfff8
80002412:	50 1a       	stdsp	sp[0x4],r10
80002414:	c3 5b       	rjmp	8000227e <flashc_memset64+0xae>
80002416:	40 6a       	lddsp	r10,sp[0x18]
80002418:	40 59       	lddsp	r9,sp[0x14]
8000241a:	12 3a       	cp.w	r10,r9
8000241c:	fe 9b ff 27 	brhi	8000226a <flashc_memset64+0x9a>
	dest_end.u8ptr = dest.u8ptr + nbytes;

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
		dest.u8ptr = AVR32_FLASH;
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80002420:	e0 68 ff ff 	mov	r8,65535
80002424:	ea 18 80 7f 	orh	r8,0x807f
80002428:	10 39       	cp.w	r9,r8
8000242a:	fe 9b ff 20 	brhi	8000226a <flashc_memset64+0x9a>
8000242e:	fc 11 80 80 	movh	r1,0x8080
80002432:	51 21       	stdsp	sp[0x48],r1
80002434:	c1 bb       	rjmp	8000226a <flashc_memset64+0x9a>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80002436:	d7 03       	nop
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	af 48       	asr	r8,0xe

8000243c <flashc_memset32>:
8000243c:	eb cd 40 c0 	pushm	r6-r7,lr
80002440:	30 0e       	mov	lr,0
80002442:	16 96       	mov	r6,r11
80002444:	1c 97       	mov	r7,lr
80002446:	12 98       	mov	r8,r9
80002448:	0c 9b       	mov	r11,r6
8000244a:	14 99       	mov	r9,r10
8000244c:	0e 4b       	or	r11,r7
8000244e:	0e 9a       	mov	r10,r7
80002450:	0c 4a       	or	r10,r6
80002452:	cb fe       	rcall	800021d0 <flashc_memset64>
80002454:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80002458 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002458:	f8 08 16 05 	lsr	r8,r12,0x5
8000245c:	a9 68       	lsl	r8,0x8
8000245e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80002462:	58 1b       	cp.w	r11,1
80002464:	c1 50       	breq	8000248e <gpio_enable_module_pin+0x36>
80002466:	c0 82       	brcc	80002476 <gpio_enable_module_pin+0x1e>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002468:	30 1b       	mov	r11,1
8000246a:	f6 0c 09 4c 	lsl	r12,r11,r12
8000246e:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002470:	91 ac       	st.w	r8[0x28],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002472:	91 2c       	st.w	r8[0x8],r12
80002474:	5e fd       	retal	0
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the correct function. */
	switch (function) {
80002476:	58 2b       	cp.w	r11,2
80002478:	c1 10       	breq	8000249a <gpio_enable_module_pin+0x42>
8000247a:	58 3b       	cp.w	r11,3
8000247c:	c0 20       	breq	80002480 <gpio_enable_module_pin+0x28>
8000247e:	5e ff       	retal	1
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002480:	30 1b       	mov	r11,1
80002482:	f6 0c 09 4c 	lsl	r12,r11,r12
80002486:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002488:	91 9c       	st.w	r8[0x24],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000248a:	91 2c       	st.w	r8[0x8],r12
8000248c:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000248e:	f6 0c 09 4c 	lsl	r12,r11,r12
80002492:	91 5c       	st.w	r8[0x14],r12
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002494:	91 ac       	st.w	r8[0x28],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002496:	91 2c       	st.w	r8[0x8],r12
80002498:	5e fd       	retal	0
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000249a:	30 1b       	mov	r11,1
8000249c:	f6 0c 09 4c 	lsl	r12,r11,r12
800024a0:	91 6c       	st.w	r8[0x18],r12
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800024a2:	91 9c       	st.w	r8[0x24],r12
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800024a4:	91 2c       	st.w	r8[0x8],r12
800024a6:	5e fd       	retal	0

800024a8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800024a8:	d4 21       	pushm	r4-r7,lr
800024aa:	18 97       	mov	r7,r12
800024ac:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800024ae:	58 0b       	cp.w	r11,0
800024b0:	c0 e0       	breq	800024cc <gpio_enable_module+0x24>
800024b2:	30 06       	mov	r6,0
800024b4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800024b6:	6e 1b       	ld.w	r11,r7[0x4]
800024b8:	6e 0c       	ld.w	r12,r7[0x0]
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800024ba:	2f f6       	sub	r6,-1
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
800024bc:	2f 87       	sub	r7,-8
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800024be:	cc df       	rcall	80002458 <gpio_enable_module_pin>
800024c0:	18 45       	or	r5,r12
800024c2:	0c 34       	cp.w	r4,r6
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800024c4:	fe 9b ff f9 	brhi	800024b6 <gpio_enable_module+0xe>
800024c8:	0a 9c       	mov	r12,r5
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800024ca:	d8 22       	popm	r4-r7,pc
800024cc:	16 95       	mov	r5,r11
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800024ce:	cf db       	rjmp	800024c8 <gpio_enable_module+0x20>

800024d0 <gpio_enable_pin_pull_up>:
800024d0:	30 18       	mov	r8,1
800024d2:	f0 0c 09 48 	lsl	r8,r8,r12
800024d6:	a5 9c       	lsr	r12,0x5
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_pull_up(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800024d8:	a9 6c       	lsl	r12,0x8
800024da:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->puers = 1 << (pin & 0x1F);
800024de:	f9 48 00 74 	st.w	r12[116],r8
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	gpio_port->pderc = 1 << (pin & 0x1F);
#endif
}
800024e2:	5e fc       	retal	r12

800024e4 <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800024e4:	f8 08 16 05 	lsr	r8,r12,0x5
800024e8:	a9 68       	lsl	r8,0x8
800024ea:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800024ee:	71 88       	ld.w	r8,r8[0x60]
800024f0:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800024f4:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800024f8:	5e fc       	retal	r12

800024fa <gpio_set_gpio_pin>:
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800024fa:	30 18       	mov	r8,1
800024fc:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002500:	a5 9c       	lsr	r12,0x5
80002502:	a9 6c       	lsl	r12,0x8
80002504:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002508:	f9 48 00 54 	st.w	r12[84],r8
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000250c:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002510:	99 18       	st.w	r12[0x4],r8
}
80002512:	5e fc       	retal	r12

80002514 <gpio_clr_gpio_pin>:
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80002514:	30 18       	mov	r8,1
80002516:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000251a:	a5 9c       	lsr	r12,0x5
8000251c:	a9 6c       	lsl	r12,0x8
8000251e:	e0 2c f0 00 	sub	r12,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80002522:	f9 48 00 58 	st.w	r12[88],r8
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80002526:	f9 48 00 44 	st.w	r12[68],r8
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000252a:	99 18       	st.w	r12[0x4],r8
}
8000252c:	5e fc       	retal	r12

8000252e <gpio_enable_pin_glitch_filter>:
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
	
	gpio_port->gfers = 1 << (pin & 0x1F);
8000252e:	30 18       	mov	r8,1
80002530:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002534:	a5 9c       	lsr	r12,0x5
80002536:	a9 6c       	lsl	r12,0x8
80002538:	e0 2c f0 00 	sub	r12,61440
	
	gpio_port->gfers = 1 << (pin & 0x1F);
8000253c:	f9 48 00 c4 	st.w	r12[196],r8
}
80002540:	5e fc       	retal	r12

80002542 <gpio_enable_pin_interrupt>:
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80002542:	30 1a       	mov	r10,1
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002544:	f8 08 16 05 	lsr	r8,r12,0x5

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80002548:	f4 0c 09 49 	lsl	r9,r10,r12
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000254c:	a9 68       	lsl	r8,0x8
8000254e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80002552:	f1 49 00 c4 	st.w	r8[196],r9
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
80002556:	14 3b       	cp.w	r11,r10
80002558:	c0 c0       	breq	80002570 <gpio_enable_pin_interrupt+0x2e>
8000255a:	c0 82       	brcc	8000256a <gpio_enable_pin_interrupt+0x28>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
8000255c:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80002560:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80002564:	f1 49 00 94 	st.w	r8[148],r9
80002568:	5e fd       	retal	0
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8000256a:	58 2b       	cp.w	r11,2
8000256c:	c0 90       	breq	8000257e <gpio_enable_pin_interrupt+0x3c>
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1s = 1 << (pin & 0x1F);
8000256e:	5e fa       	retal	r10
		gpio_port->imr0c = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
80002570:	f1 49 00 a4 	st.w	r8[164],r9
		gpio_port->imr1c = 1 << (pin & 0x1F);
80002574:	f1 49 00 b8 	st.w	r8[184],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80002578:	f1 49 00 94 	st.w	r8[148],r9
8000257c:	5e fd       	retal	0
		gpio_port->imr0s = 1 << (pin & 0x1F);
		gpio_port->imr1c = 1 << (pin & 0x1F);
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
8000257e:	f1 49 00 a8 	st.w	r8[168],r9
		gpio_port->imr1s = 1 << (pin & 0x1F);
80002582:	f1 49 00 b4 	st.w	r8[180],r9
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
80002586:	f1 49 00 94 	st.w	r8[148],r9
8000258a:	5e fd       	retal	0

8000258c <gpio_get_pin_interrupt_flag>:
 *
 * \return The pin interrupt flag.
 */
bool gpio_get_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000258c:	f8 08 16 05 	lsr	r8,r12,0x5
80002590:	a9 68       	lsl	r8,0x8
80002592:	e0 28 f0 00 	sub	r8,61440
	
	return (gpio_port->ifr >> (pin & 0x1F)) & 1;
80002596:	f0 f8 00 d0 	ld.w	r8,r8[208]
8000259a:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
8000259e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800025a2:	5e fc       	retal	r12

800025a4 <gpio_clear_pin_interrupt_flag>:
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800025a4:	30 18       	mov	r8,1
800025a6:	f0 0c 09 48 	lsl	r8,r8,r12
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800025aa:	a5 9c       	lsr	r12,0x5
800025ac:	a9 6c       	lsl	r12,0x8
800025ae:	e0 2c f0 00 	sub	r12,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800025b2:	f9 48 00 d8 	st.w	r12[216],r8
#endif
}
800025b6:	5e fc       	retal	r12

800025b8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800025b8:	c0 08       	rjmp	800025b8 <_unhandled_interrupt>
800025ba:	d7 03       	nop

800025bc <INTC_register_interrupt>:

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800025bc:	f3 db c0 05 	bfextu	r9,r11,0x0,0x5
800025c0:	49 b8       	lddpc	r8,8000262c <INTC_register_interrupt+0x70>
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800025c2:	a5 9b       	lsr	r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800025c4:	f0 0b 00 38 	add	r8,r8,r11<<0x3
800025c8:	70 18       	ld.w	r8,r8[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800025ca:	f0 09 09 2c 	st.w	r8[r9<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800025ce:	58 0a       	cp.w	r10,0
800025d0:	c1 00       	breq	800025f0 <INTC_register_interrupt+0x34>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	} else if (int_level == AVR32_INTC_INT1) {
800025d2:	58 1a       	cp.w	r10,1
800025d4:	c1 70       	breq	80002602 <INTC_register_interrupt+0x46>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
	} else if (int_level == AVR32_INTC_INT2) {
800025d6:	58 2a       	cp.w	r10,2
800025d8:	c1 f0       	breq	80002616 <INTC_register_interrupt+0x5a>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800025da:	49 69       	lddpc	r9,80002630 <INTC_register_interrupt+0x74>
800025dc:	49 68       	lddpc	r8,80002634 <INTC_register_interrupt+0x78>
800025de:	f2 08 01 08 	sub	r8,r9,r8
800025e2:	fe 79 08 00 	mov	r9,-63488
800025e6:	ea 18 c0 00 	orh	r8,0xc000
800025ea:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
800025ee:	5e fc       	retal	r12
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800025f0:	fe 78 08 00 	mov	r8,-63488
800025f4:	49 09       	lddpc	r9,80002634 <INTC_register_interrupt+0x78>
800025f6:	49 1a       	lddpc	r10,80002638 <INTC_register_interrupt+0x7c>
800025f8:	f4 09 01 09 	sub	r9,r10,r9
800025fc:	f0 0b 09 29 	st.w	r8[r11<<0x2],r9
80002600:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002602:	48 f9       	lddpc	r9,8000263c <INTC_register_interrupt+0x80>
80002604:	48 c8       	lddpc	r8,80002634 <INTC_register_interrupt+0x78>
80002606:	f2 08 01 08 	sub	r8,r9,r8
8000260a:	fe 79 08 00 	mov	r9,-63488
8000260e:	bf a8       	sbr	r8,0x1e
80002610:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
80002614:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002616:	48 b9       	lddpc	r9,80002640 <INTC_register_interrupt+0x84>
80002618:	48 78       	lddpc	r8,80002634 <INTC_register_interrupt+0x78>
8000261a:	f2 08 01 08 	sub	r8,r9,r8
8000261e:	fe 79 08 00 	mov	r9,-63488
80002622:	bf b8       	sbr	r8,0x1f
80002624:	f2 0b 09 28 	st.w	r9[r11<<0x2],r8
80002628:	5e fc       	retal	r12
8000262a:	d7 03       	nop
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	af 58       	asr	r8,0xf
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	ad 2e       	st.d	r6++,lr
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	ac 00       	st.h	r6[0x0],r0
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	ad 04       	ld.d	r4,r6
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	ad 12       	ld.d	r2,--r6
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	ad 20       	st.d	r6++,r0

80002644 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002644:	eb cd 40 e0 	pushm	r5-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002648:	48 f8       	lddpc	r8,80002684 <INTC_init_interrupts+0x40>
8000264a:	e3 b8 00 01 	mtsr	0x4,r8
8000264e:	48 f5       	lddpc	r5,80002688 <INTC_init_interrupts+0x44>
80002650:	48 f7       	lddpc	r7,8000268c <INTC_init_interrupts+0x48>
80002652:	10 15       	sub	r5,r8
80002654:	30 0e       	mov	lr,0
80002656:	fe cc 00 9e 	sub	r12,pc,158

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000265a:	fe 76 08 00 	mov	r6,-63488

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000265e:	6e 0a       	ld.w	r10,r7[0x0]
80002660:	58 0a       	cp.w	r10,0
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002662:	c0 90       	breq	80002674 <INTC_init_interrupts+0x30>
80002664:	30 08       	mov	r8,0
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002666:	6e 1b       	ld.w	r11,r7[0x4]
80002668:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000266c:	2f f8       	sub	r8,-1
8000266e:	10 3a       	cp.w	r10,r8
80002670:	fe 9b ff fc 	brhi	80002668 <INTC_init_interrupts+0x24>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002674:	ec 0e 09 25 	st.w	r6[lr<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002678:	2f 87       	sub	r7,-8
8000267a:	2f fe       	sub	lr,-1
8000267c:	59 4e       	cp.w	lr,20
8000267e:	cf 01       	brne	8000265e <INTC_init_interrupts+0x1a>
80002680:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	ac 00       	st.h	r6[0x0],r0
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	ad 04       	ld.d	r4,r6
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	af 58       	asr	r8,0xf

80002690 <_get_interrupt_handler>:
80002690:	e0 68 00 83 	mov	r8,131
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002694:	f0 0c 01 0c 	sub	r12,r8,r12
80002698:	fe 78 08 00 	mov	r8,-63488
8000269c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800026a0:	f2 ca ff c0 	sub	r10,r9,-64
800026a4:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800026a8:	58 0c       	cp.w	r12,0
800026aa:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
800026ac:	48 68       	lddpc	r8,800026c4 <_get_interrupt_handler+0x34>
800026ae:	f8 0c 12 00 	clz	r12,r12
800026b2:	f0 09 00 39 	add	r9,r8,r9<<0x3
800026b6:	f8 0c 11 1f 	rsub	r12,r12,31
800026ba:	72 18       	ld.w	r8,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800026bc:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800026c0:	5e fc       	retal	r12
800026c2:	d7 03       	nop
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	af 58       	asr	r8,0xf

800026c8 <pdca_get_handler>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800026c8:	30 e8       	mov	r8,14
800026ca:	f0 0c 18 00 	cp.b	r12,r8
800026ce:	e0 8b 00 06 	brhi	800026da <pdca_get_handler+0x12>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800026d2:	a7 6c       	lsl	r12,0x6
800026d4:	e0 3c 00 00 	sub	r12,65536
	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
	}

	return pdca_channel;
}
800026d8:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800026da:	5e fe       	retal	-1

800026dc <pdca_disable>:
800026dc:	30 e8       	mov	r8,14
800026de:	f0 0c 18 00 	cp.b	r12,r8
800026e2:	e0 8b 00 08 	brhi	800026f2 <pdca_disable+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800026e6:	a7 6c       	lsl	r12,0x6
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
800026e8:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800026ea:	e0 3c 00 00 	sub	r12,65536
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
800026ee:	99 58       	st.w	r12[0x14],r8
}
800026f0:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800026f2:	3f fc       	mov	r12,-1
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
800026f4:	30 28       	mov	r8,2
800026f6:	99 58       	st.w	r12[0x14],r8
}
800026f8:	5e fc       	retal	r12

800026fa <pdca_enable_interrupt_transfer_complete>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800026fa:	30 e8       	mov	r8,14
800026fc:	f0 0c 18 00 	cp.b	r12,r8
80002700:	e0 8b 00 08 	brhi	80002710 <pdca_enable_interrupt_transfer_complete+0x16>

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002704:	a7 6c       	lsl	r12,0x6
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80002706:	30 28       	mov	r8,2

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002708:	e0 3c 00 00 	sub	r12,65536
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
8000270c:	99 88       	st.w	r12[0x20],r8
}
8000270e:	5e fc       	retal	r12
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002710:	3f fc       	mov	r12,-1
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
80002712:	30 28       	mov	r8,2
80002714:	99 88       	st.w	r12[0x20],r8
}
80002716:	5e fc       	retal	r12

80002718 <pdca_disable_interrupt_reload_counter_zero>:
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002718:	30 e8       	mov	r8,14
8000271a:	f0 0c 18 00 	cp.b	r12,r8
8000271e:	e0 88 00 0e 	brls	8000273a <pdca_disable_interrupt_reload_counter_zero+0x22>
80002722:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002724:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002728:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
8000272a:	30 19       	mov	r9,1
8000272c:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
8000272e:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80002730:	ed b8 00 10 	bld	r8,0x10
80002734:	c0 20       	breq	80002738 <pdca_disable_interrupt_reload_counter_zero+0x20>
      cpu_irq_enable();
80002736:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80002738:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
8000273a:	a7 6c       	lsl	r12,0x6
8000273c:	e0 3c 00 00 	sub	r12,65536
80002740:	cf 2b       	rjmp	80002724 <pdca_disable_interrupt_reload_counter_zero+0xc>

80002742 <pdca_disable_interrupt_transfer_complete>:

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80002742:	30 e8       	mov	r8,14
80002744:	f0 0c 18 00 	cp.b	r12,r8
80002748:	e0 88 00 0e 	brls	80002764 <pdca_disable_interrupt_transfer_complete+0x22>
8000274c:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000274e:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002752:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
80002754:	30 29       	mov	r9,2
80002756:	99 99       	st.w	r12[0x24],r9
	pdca_channel->isr;
80002758:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000275a:	ed b8 00 10 	bld	r8,0x10
8000275e:	c0 20       	breq	80002762 <pdca_disable_interrupt_transfer_complete+0x20>
      cpu_irq_enable();
80002760:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80002762:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002764:	a7 6c       	lsl	r12,0x6
80002766:	e0 3c 00 00 	sub	r12,65536
8000276a:	cf 2b       	rjmp	8000274e <pdca_disable_interrupt_transfer_complete+0xc>

8000276c <pdca_load_channel>:

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
8000276c:	30 e8       	mov	r8,14
8000276e:	f0 0c 18 00 	cp.b	r12,r8
80002772:	e0 88 00 11 	brls	80002794 <pdca_load_channel+0x28>
80002776:	3f fc       	mov	r12,-1

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002778:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000277c:	d3 03       	ssrf	0x10
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)addr;
8000277e:	99 0b       	st.w	r12[0x0],r11
	pdca_channel->tcr = size;
80002780:	99 2a       	st.w	r12[0x8],r10
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80002782:	e0 69 01 00 	mov	r9,256
80002786:	99 59       	st.w	r12[0x14],r9
	pdca_channel->isr;
80002788:	78 b9       	ld.w	r9,r12[0x2c]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000278a:	ed b8 00 10 	bld	r8,0x10
8000278e:	c0 20       	breq	80002792 <pdca_load_channel+0x26>
      cpu_irq_enable();
80002790:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80002792:	5e fc       	retal	r12

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80002794:	a7 6c       	lsl	r12,0x6
80002796:	e0 3c 00 00 	sub	r12,65536
8000279a:	ce fb       	rjmp	80002778 <pdca_load_channel+0xc>

8000279c <pdca_init_channel>:
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
8000279c:	eb cd 40 e0 	pushm	r5-r7,lr
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800027a0:	30 e8       	mov	r8,14
	return pdca_channel;
}

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
800027a2:	18 97       	mov	r7,r12
800027a4:	16 95       	mov	r5,r11
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
800027a6:	f0 0c 18 00 	cp.b	r12,r8
800027aa:	e0 88 00 20 	brls	800027ea <pdca_init_channel+0x4e>
800027ae:	3f f6       	mov	r6,-1
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
			pdca_ch_number);

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
800027b0:	0e 9c       	mov	r12,r7
800027b2:	cc 8f       	rcall	80002742 <pdca_disable_interrupt_transfer_complete>
800027b4:	0e 9c       	mov	r12,r7
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
800027b6:	cb 1f       	rcall	80002718 <pdca_disable_interrupt_reload_counter_zero>
800027b8:	e1 b8 00 00 	mfsr	r8,0x0

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027bc:	d3 03       	ssrf	0x10
800027be:	6a 09       	ld.w	r9,r5[0x0]
	cpu_irq_disable();
800027c0:	8d 09       	st.w	r6[0x0],r9
	
	irqflags_t flags = cpu_irq_save();

	pdca_channel->mar = (uint32_t)opt->addr;
800027c2:	6a 19       	ld.w	r9,r5[0x4]
800027c4:	8d 29       	st.w	r6[0x8],r9
	pdca_channel->tcr = opt->size;
800027c6:	6a 49       	ld.w	r9,r5[0x10]
800027c8:	8d 19       	st.w	r6[0x4],r9
	pdca_channel->psr = opt->pid;
800027ca:	6a 29       	ld.w	r9,r5[0x8]
800027cc:	8d 39       	st.w	r6[0xc],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
800027ce:	6a 39       	ld.w	r9,r5[0xc]
800027d0:	8d 49       	st.w	r6[0x10],r9
	pdca_channel->tcrr = opt->r_size;
800027d2:	6a 59       	ld.w	r9,r5[0x14]
800027d4:	8d 69       	st.w	r6[0x18],r9
	pdca_channel->mr =
800027d6:	e0 69 01 00 	mov	r9,256
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
800027da:	8d 59       	st.w	r6[0x14],r9
800027dc:	6c b9       	ld.w	r9,r6[0x2c]
800027de:	ed b8 00 10 	bld	r8,0x10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800027e2:	c0 20       	breq	800027e6 <pdca_init_channel+0x4a>
800027e4:	d5 03       	csrf	0x10
800027e6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
	pdca_channel->isr;
	
	cpu_irq_restore(flags);

	return PDCA_SUCCESS;
}
800027ea:	f8 06 15 06 	lsl	r6,r12,0x6

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
800027ee:	e0 36 00 00 	sub	r6,65536
800027f2:	cd fb       	rjmp	800027b0 <pdca_init_channel+0x14>

800027f4 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
800027f4:	f8 c8 00 01 	sub	r8,r12,1
800027f8:	f0 0b 00 0b 	add	r11,r8,r11
800027fc:	f6 0c 0d 0a 	divu	r10,r11,r12
80002800:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002802:	f4 c8 00 01 	sub	r8,r10,1
80002806:	e0 48 00 fe 	cp.w	r8,254
8000280a:	e0 8b 00 04 	brhi	80002812 <getBaudDiv+0x1e>
		return -1;
	}

	return baudDiv;
8000280e:	5c 8c       	casts.h	r12
}
80002810:	5e fc       	retal	r12

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);

	if (baudDiv <= 0 || baudDiv > 255) {
80002812:	5e fe       	retal	-1

80002814 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80002814:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80002816:	30 18       	mov	r8,1
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80002818:	18 99       	mov	r9,r12
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000281a:	f7 3a 00 0d 	ld.ub	r10,r11[13]
8000281e:	f0 0a 18 00 	cp.b	r10,r8
80002822:	e0 88 00 04 	brls	8000282a <spi_initMaster+0x16>
80002826:	30 2c       	mov	r12,2
80002828:	d8 02       	popm	pc

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
	u_avr32_spi_mr.MR.llb = 0;
8000282a:	30 0a       	mov	r10,0
	if (options->modfdis > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000282c:	e0 68 00 80 	mov	r8,128
80002830:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
80002832:	30 1e       	mov	lr,1

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80002834:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002836:	f7 3b 00 0d 	ld.ub	r11,r11[13]
	u_avr32_spi_mr.MR.llb = 0;
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
	spi->mr = u_avr32_spi_mr.mr;
8000283a:	14 9c       	mov	r12,r10
	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
	u_avr32_spi_mr.MR.mstr = 1;
8000283c:	f1 de d0 01 	bfins	r8,lr,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80002840:	f1 db d0 81 	bfins	r8,r11,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80002844:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80002848:	30 fa       	mov	r10,15
8000284a:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
8000284e:	93 18       	st.w	r9[0x4],r8

	return SPI_OK;
}
80002850:	d8 02       	popm	pc

80002852 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80002852:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002854:	30 18       	mov	r8,1
80002856:	f0 0b 18 00 	cp.b	r11,r8
8000285a:	5f be       	srhi	lr
8000285c:	f0 0a 18 00 	cp.b	r10,r8
80002860:	5f b8       	srhi	r8
80002862:	1c 48       	or	r8,lr
80002864:	c0 a1       	brne	80002878 <spi_selectionMode+0x26>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80002866:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80002868:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
8000286c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80002870:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80002874:	99 18       	st.w	r12[0x4],r8
80002876:	d8 0a       	popm	pc,r12=0
		uint8_t pcs_decode,
		uint8_t delay)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80002878:	30 2c       	mov	r12,2
8000287a:	d8 02       	popm	pc

8000287c <spi_selectChip>:
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
8000287c:	78 19       	ld.w	r9,r12[0x4]

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000287e:	18 98       	mov	r8,r12
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002880:	ea 19 00 0f 	orh	r9,0xf
80002884:	99 19       	st.w	r12[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002886:	78 1c       	ld.w	r12,r12[0x4]
80002888:	e2 1c 00 04 	andl	r12,0x4,COH
8000288c:	c0 80       	breq	8000289c <spi_selectChip+0x20>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
8000288e:	30 e9       	mov	r9,14
80002890:	f2 0b 18 00 	cp.b	r11,r9
80002894:	e0 88 00 12 	brls	800028b8 <spi_selectChip+0x3c>
	} else {
		if (chip > 3) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80002898:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
8000289a:	5e fc       	retal	r12
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
8000289c:	30 39       	mov	r9,3
8000289e:	f2 0b 18 00 	cp.b	r11,r9
800028a2:	fe 9b ff fb 	brhi	80002898 <spi_selectChip+0x1c>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800028a6:	70 19       	ld.w	r9,r8[0x4]
800028a8:	2f 0b       	sub	r11,-16
800028aa:	30 1a       	mov	r10,1
800028ac:	f4 0b 09 4b 	lsl	r11,r10,r11
800028b0:	5c db       	com	r11
800028b2:	12 6b       	and	r11,r9
800028b4:	91 1b       	st.w	r8[0x4],r11
800028b6:	5e fc       	retal	r12
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800028b8:	70 19       	ld.w	r9,r8[0x4]
800028ba:	b1 6b       	lsl	r11,0x10
800028bc:	30 0c       	mov	r12,0
800028be:	ea 1b ff f0 	orh	r11,0xfff0
800028c2:	e8 1b ff ff 	orl	r11,0xffff
800028c6:	12 6b       	and	r11,r9
800028c8:	91 1b       	st.w	r8[0x4],r11
800028ca:	5e fc       	retal	r12

800028cc <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800028cc:	e0 69 3a 98 	mov	r9,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800028d0:	c0 48       	rjmp	800028d8 <spi_unselectChip+0xc>
		if (!timeout--) {
800028d2:	58 09       	cp.w	r9,0
800028d4:	c0 e0       	breq	800028f0 <spi_unselectChip+0x24>
800028d6:	20 19       	sub	r9,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800028d8:	78 48       	ld.w	r8,r12[0x10]
800028da:	ed b8 00 09 	bld	r8,0x9
800028de:	cf a1       	brne	800028d2 <spi_unselectChip+0x6>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
800028e0:	78 18       	ld.w	r8,r12[0x4]
800028e2:	ea 18 00 0f 	orh	r8,0xf
800028e6:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800028e8:	fc 18 01 00 	movh	r8,0x100
800028ec:	99 08       	st.w	r12[0x0],r8
800028ee:	5e fd       	retal	0
spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800028f0:	5e ff       	retal	1
800028f2:	d7 03       	nop

800028f4 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800028f4:	eb cd 40 fe 	pushm	r1-r7,lr
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800028f8:	30 34       	mov	r4,3
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
800028fa:	16 97       	mov	r7,r11
800028fc:	18 96       	mov	r6,r12
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
800028fe:	f7 35 00 0c 	ld.ub	r5,r11[12]
80002902:	e8 05 18 00 	cp.b	r5,r4
80002906:	e0 8b 00 09 	brhi	80002918 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
8000290a:	f7 32 00 0b 	ld.ub	r2,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000290e:	30 13       	mov	r3,1
80002910:	e6 02 18 00 	cp.b	r2,r3
80002914:	e0 88 00 05 	brls	8000291e <spi_setupChipReg+0x2a>
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
		break;
80002918:	30 2c       	mov	r12,2
		}
	}
#endif

	return SPI_OK;
}
8000291a:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
8000291e:	f7 31 00 08 	ld.ub	r1,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80002922:	30 78       	mov	r8,7
80002924:	f0 01 18 00 	cp.b	r1,r8
80002928:	fe 98 ff f8 	brls	80002918 <spi_setupChipReg+0x24>
8000292c:	31 08       	mov	r8,16
8000292e:	f0 01 18 00 	cp.b	r1,r8
80002932:	fe 9b ff f3 	brhi	80002918 <spi_setupChipReg+0x24>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80002936:	14 9b       	mov	r11,r10
80002938:	6e 1c       	ld.w	r12,r7[0x4]
8000293a:	c5 df       	rcall	800027f4 <getBaudDiv>
8000293c:	ce e5       	brlt	80002918 <spi_setupChipReg+0x24>

	if (baudDiv < 0) {
8000293e:	0a 9a       	mov	r10,r5
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002940:	ec 1a 00 01 	eorl	r10,0x1
80002944:	30 08       	mov	r8,0
	if (baudDiv < 0) {
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80002946:	a1 95       	lsr	r5,0x1
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80002948:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
8000294c:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80002950:	ef 3a 00 09 	ld.ub	r10,r7[9]
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002954:	20 81       	sub	r1,8
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002956:	f1 d2 d0 61 	bfins	r8,r2,0x3,0x1

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000295a:	0f 89       	ld.ub	r9,r7[0x0]
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
8000295c:	f1 d1 d0 84 	bfins	r8,r1,0x4,0x4
	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80002960:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80002964:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80002968:	ef 3a 00 0a 	ld.ub	r10,r7[10]
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000296c:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
80002970:	e6 09 18 00 	cp.b	r9,r3

	switch (options->reg) {
80002974:	c0 f0       	breq	80002992 <spi_setupChipReg+0x9e>
80002976:	c0 b3       	brcs	8000298c <spi_setupChipReg+0x98>
80002978:	30 2a       	mov	r10,2
8000297a:	f4 09 18 00 	cp.b	r9,r10
8000297e:	c0 d0       	breq	80002998 <spi_setupChipReg+0xa4>
80002980:	e8 09 18 00 	cp.b	r9,r4
80002984:	cc a1       	brne	80002918 <spi_setupChipReg+0x24>
80002986:	8d f8       	st.w	r6[0x3c],r8
	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
		break;

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80002988:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000298c:	8d c8       	st.w	r6[0x30],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;

	switch (options->reg) {
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
8000298e:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80002992:	8d d8       	st.w	r6[0x34],r8
		break;

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80002994:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
80002998:	8d e8       	st.w	r6[0x38],r8
		break;

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
8000299a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000299e:	d7 03       	nop

800029a0 <spi_enable>:
800029a0:	30 18       	mov	r8,1
800029a2:	99 08       	st.w	r12[0x0],r8
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
}
800029a4:	5e fc       	retal	r12

800029a6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800029a6:	e0 69 3a 98 	mov	r9,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800029aa:	c0 48       	rjmp	800029b2 <spi_write+0xc>
		if (!timeout--) {
800029ac:	58 09       	cp.w	r9,0
800029ae:	c0 90       	breq	800029c0 <spi_write+0x1a>
800029b0:	20 19       	sub	r9,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800029b2:	78 48       	ld.w	r8,r12[0x10]
800029b4:	ed b8 00 01 	bld	r8,0x1
800029b8:	cf a1       	brne	800029ac <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800029ba:	5c 7b       	castu.h	r11
800029bc:	99 3b       	st.w	r12[0xc],r11
800029be:	5e fd       	retal	0
spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
		if (!timeout--) {
800029c0:	5e ff       	retal	1

800029c2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800029c2:	e0 69 3a 98 	mov	r9,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800029c6:	c0 48       	rjmp	800029ce <spi_read+0xc>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800029c8:	58 09       	cp.w	r9,0
800029ca:	c0 c0       	breq	800029e2 <spi_read+0x20>
800029cc:	20 19       	sub	r9,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800029ce:	78 48       	ld.w	r8,r12[0x10]
800029d0:	e2 18 02 01 	andl	r8,0x201,COH
800029d4:	e0 48 02 01 	cp.w	r8,513
800029d8:	cf 81       	brne	800029c8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800029da:	78 28       	ld.w	r8,r12[0x8]
800029dc:	30 0c       	mov	r12,0
800029de:	b6 08       	st.h	r11[0x0],r8

	return SPI_OK;
}
800029e0:	5e fc       	retal	r12
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800029e2:	5e ff       	retal	1

800029e4 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
800029e4:	d4 01       	pushm	lr
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
800029e6:	76 09       	ld.w	r9,r11[0x0]
800029e8:	58 29       	cp.w	r9,2
800029ea:	e0 8b 00 4b 	brhi	80002a80 <tc_init_waveform+0x9c>
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
800029ee:	76 18       	ld.w	r8,r11[0x4]
800029f0:	10 9e       	mov	lr,r8
800029f2:	e6 1e c0 00 	andh	lr,0xc000,COH
800029f6:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800029fa:	af ba       	sbr	r10,0xf
800029fc:	1c 4a       	or	r10,lr
800029fe:	10 9e       	mov	lr,r8
80002a00:	e6 1e 30 00 	andh	lr,0x3000,COH
80002a04:	1c 4a       	or	r10,lr
80002a06:	10 9e       	mov	lr,r8
80002a08:	e6 1e 0c 00 	andh	lr,0xc00,COH
80002a0c:	1c 4a       	or	r10,lr
80002a0e:	10 9e       	mov	lr,r8
80002a10:	e6 1e 03 00 	andh	lr,0x300,COH
80002a14:	1c 4a       	or	r10,lr
80002a16:	10 9e       	mov	lr,r8
80002a18:	e6 1e 00 c0 	andh	lr,0xc0,COH
80002a1c:	1c 4a       	or	r10,lr
80002a1e:	10 9e       	mov	lr,r8
80002a20:	e6 1e 00 30 	andh	lr,0x30,COH
80002a24:	1c 4a       	or	r10,lr
80002a26:	10 9e       	mov	lr,r8
80002a28:	e6 1e 00 0c 	andh	lr,0xc,COH
80002a2c:	1c 4a       	or	r10,lr
80002a2e:	10 9e       	mov	lr,r8
80002a30:	e6 1e 00 03 	andh	lr,0x3,COH
80002a34:	1c 4a       	or	r10,lr
80002a36:	10 9e       	mov	lr,r8
80002a38:	e2 1e 60 00 	andl	lr,0x6000,COH
80002a3c:	1c 4a       	or	r10,lr
80002a3e:	10 9e       	mov	lr,r8
80002a40:	e2 1e 10 00 	andl	lr,0x1000,COH
80002a44:	1c 4a       	or	r10,lr
80002a46:	10 9e       	mov	lr,r8
80002a48:	e2 1e 0c 00 	andl	lr,0xc00,COH
80002a4c:	1c 4a       	or	r10,lr
80002a4e:	10 9e       	mov	lr,r8
80002a50:	e2 1e 03 00 	andl	lr,0x300,COH
80002a54:	1c 4a       	or	r10,lr
80002a56:	10 9e       	mov	lr,r8
80002a58:	e2 1e 00 80 	andl	lr,0x80,COH
80002a5c:	10 9b       	mov	r11,r8
80002a5e:	1c 4a       	or	r10,lr
80002a60:	e2 1b 00 08 	andl	r11,0x8,COH
80002a64:	10 9e       	mov	lr,r8
80002a66:	a5 69       	lsl	r9,0x4
80002a68:	e2 1e 00 40 	andl	lr,0x40,COH
80002a6c:	2f f9       	sub	r9,-1
80002a6e:	1c 4a       	or	r10,lr
80002a70:	e2 18 00 30 	andl	r8,0x30,COH
80002a74:	f5 e8 10 08 	or	r8,r10,r8
80002a78:	16 48       	or	r8,r11
80002a7a:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80002a7e:	d8 0a       	popm	pc,r12=0


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80002a80:	dc 0a       	popm	pc,r12=-1

80002a82 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002a82:	58 2b       	cp.w	r11,2
80002a84:	e0 8b 00 07 	brhi	80002a92 <tc_start+0x10>
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80002a88:	a7 6b       	lsl	r11,0x6
80002a8a:	16 0c       	add	r12,r11
80002a8c:	30 58       	mov	r8,5
80002a8e:	99 08       	st.w	r12[0x0],r8
80002a90:	5e fd       	retal	0


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002a92:	5e fe       	retal	-1

80002a94 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002a94:	58 2b       	cp.w	r11,2
80002a96:	e0 8b 00 07 	brhi	80002aa4 <tc_read_sr+0x10>
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80002a9a:	a7 6b       	lsl	r11,0x6
80002a9c:	2e 0b       	sub	r11,-32
80002a9e:	16 0c       	add	r12,r11
80002aa0:	78 0c       	ld.w	r12,r12[0x0]
}
80002aa2:	5e fc       	retal	r12


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002aa4:	5e fe       	retal	-1

80002aa6 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002aa6:	58 2b       	cp.w	r11,2
80002aa8:	e0 8b 00 1a 	brhi	80002adc <tc_write_rc+0x36>
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80002aac:	f6 08 15 04 	lsl	r8,r11,0x4
80002ab0:	2f f8       	sub	r8,-1
80002ab2:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80002ab6:	ed b8 00 0f 	bld	r8,0xf
80002aba:	c0 e1       	brne	80002ad6 <tc_write_rc+0x30>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80002abc:	a7 6b       	lsl	r11,0x6
80002abe:	f8 0b 00 0b 	add	r11,r12,r11
80002ac2:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80002ac6:	2e 4b       	sub	r11,-28
80002ac8:	76 08       	ld.w	r8,r11[0x0]
80002aca:	e0 18 00 00 	andl	r8,0x0
80002ace:	f9 e8 10 08 	or	r8,r12,r8
80002ad2:	97 08       	st.w	r11[0x0],r8

  return value;
}
80002ad4:	5e fc       	retal	r12
80002ad6:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
80002ada:	5e fc       	retal	r12


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002adc:	5e fe       	retal	-1

80002ade <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80002ade:	eb cd 40 80 	pushm	r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002ae2:	e1 be 00 00 	mfsr	lr,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002ae6:	58 2b       	cp.w	r11,2
80002ae8:	e0 8b 00 5f 	brhi	80002ba6 <tc_configure_interrupts+0xc8>
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80002aec:	74 08       	ld.w	r8,r10[0x0]
80002aee:	10 99       	mov	r9,r8
80002af0:	e2 19 00 02 	andl	r9,0x2,COH
80002af4:	e2 18 00 fd 	andl	r8,0xfd,COH
80002af8:	12 48       	or	r8,r9
80002afa:	f6 09 15 06 	lsl	r9,r11,0x6
80002afe:	f8 09 00 07 	add	r7,r12,r9
80002b02:	2d c7       	sub	r7,-36
80002b04:	8f 08       	st.w	r7[0x0],r8
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80002b06:	ee 1e 00 01 	eorh	lr,0x1
80002b0a:	fd de c2 01 	bfextu	lr,lr,0x10,0x1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002b0e:	c4 e1       	brne	80002baa <tc_configure_interrupts+0xcc>
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002b10:	a7 6b       	lsl	r11,0x6
80002b12:	2e 0b       	sub	r11,-32
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b14:	74 08       	ld.w	r8,r10[0x0]
80002b16:	f8 09 00 0a 	add	r10,r12,r9
80002b1a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002b1e:	16 0c       	add	r12,r11
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b20:	e0 6b 00 80 	mov	r11,128
80002b24:	58 07       	cp.w	r7,0
80002b26:	f9 bb 01 00 	movne	r11,0
80002b2a:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80002b2e:	ec 19 00 01 	eorl	r9,0x1
80002b32:	f7 e9 10 09 	or	r9,r11,r9
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80002b36:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80002b3a:	f9 bb 00 40 	moveq	r11,64
80002b3e:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b42:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80002b44:	f7 d8 c0 a1 	bfextu	r11,r8,0x5,0x1
80002b48:	f9 bb 00 20 	moveq	r11,32
80002b4c:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b50:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80002b52:	f7 d8 c0 81 	bfextu	r11,r8,0x4,0x1
80002b56:	f9 bb 00 10 	moveq	r11,16
80002b5a:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b5e:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80002b60:	f7 d8 c0 61 	bfextu	r11,r8,0x3,0x1
80002b64:	f9 bb 00 08 	moveq	r11,8
80002b68:	f9 bb 01 00 	movne	r11,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b6c:	16 49       	or	r9,r11
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002b6e:	f7 d8 c0 41 	bfextu	r11,r8,0x2,0x1
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002b72:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80002b76:	58 0b       	cp.w	r11,0
80002b78:	f9 bb 00 04 	moveq	r11,4
80002b7c:	f9 bb 01 00 	movne	r11,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80002b80:	58 08       	cp.w	r8,0
80002b82:	f9 b8 00 02 	moveq	r8,2
80002b86:	f9 b8 01 00 	movne	r8,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002b8a:	16 49       	or	r9,r11
80002b8c:	f3 e8 10 08 	or	r8,r9,r8
80002b90:	2d 8a       	sub	r10,-40
80002b92:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002b94:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002b96:	58 0e       	cp.w	lr,0
80002b98:	c0 41       	brne	80002ba0 <tc_configure_interrupts+0xc2>
80002b9a:	1c 9c       	mov	r12,lr
80002b9c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ba0:	d5 03       	csrf	0x10
80002ba2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
  bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002ba6:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002baa:	d3 03       	ssrf	0x10
80002bac:	cb 2b       	rjmp	80002b10 <tc_configure_interrupts+0x32>

80002bae <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002bae:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002bb0:	f6 08 15 04 	lsl	r8,r11,0x4
80002bb4:	14 38       	cp.w	r8,r10
80002bb6:	e0 8b 00 26 	brhi	80002c02 <usart_set_async_baudrate+0x54>
80002bba:	31 0e       	mov	lr,16
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002bbc:	f0 09 16 01 	lsr	r9,r8,0x1
80002bc0:	f2 0a 00 39 	add	r9,r9,r10<<0x3
80002bc4:	f2 08 0d 08 	divu	r8,r9,r8
80002bc8:	10 99       	mov	r9,r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002bca:	a3 98       	lsr	r8,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002bcc:	f0 cb 00 01 	sub	r11,r8,1
80002bd0:	e0 4b ff fe 	cp.w	r11,65534
80002bd4:	e0 8b 00 1b 	brhi	80002c0a <usart_set_async_baudrate+0x5c>
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002bd8:	78 1a       	ld.w	r10,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002bda:	e8 6b 00 00 	mov	r11,524288
80002bde:	e4 1a ff f7 	andh	r10,0xfff7
80002be2:	e0 1a fe cf 	andl	r10,0xfecf
80002be6:	59 0e       	cp.w	lr,16
80002be8:	f6 0e 17 10 	movne	lr,r11
80002bec:	f9 be 00 00 	moveq	lr,0
80002bf0:	fd ea 10 0a 	or	r10,lr,r10
80002bf4:	99 1a       	st.w	r12[0x4],r10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002bf6:	f3 d9 c0 03 	bfextu	r9,r9,0x0,0x3
80002bfa:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002bfe:	99 88       	st.w	r12[0x20],r8
80002c00:	d8 0a       	popm	pc,r12=0
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002c02:	f6 08 15 03 	lsl	r8,r11,0x3
80002c06:	30 8e       	mov	lr,8
80002c08:	cd ab       	rjmp	80002bbc <usart_set_async_baudrate+0xe>
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002c0a:	da 0a       	popm	pc,r12=1

80002c0c <usart_write_line>:
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002c0c:	17 8a       	ld.ub	r10,r11[0x0]
80002c0e:	58 0a       	cp.w	r10,0
80002c10:	5e 0c       	reteq	r12
80002c12:	e0 69 27 0f 	mov	r9,9999
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002c16:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80002c18:	ed b8 00 01 	bld	r8,0x1
80002c1c:	c0 91       	brne	80002c2e <usart_write_line+0x22>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002c1e:	f1 da c0 09 	bfextu	r8,r10,0x0,0x9
80002c22:	99 78       	st.w	r12[0x1c],r8


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
    usart_putchar(usart, *string++);
80002c24:	2f fb       	sub	r11,-1
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80002c26:	17 8a       	ld.ub	r10,r11[0x0]
80002c28:	58 0a       	cp.w	r10,0
80002c2a:	cf 41       	brne	80002c12 <usart_write_line+0x6>
80002c2c:	5e fc       	retal	r12
{
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80002c2e:	58 09       	cp.w	r9,0
80002c30:	cf a0       	breq	80002c24 <usart_write_line+0x18>
80002c32:	20 19       	sub	r9,1
80002c34:	cf 1b       	rjmp	80002c16 <usart_write_line+0xa>

80002c36 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002c36:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002c3a:	ed b8 00 10 	bld	r8,0x10
80002c3e:	c0 c1       	brne	80002c56 <usart_reset+0x20>
  usart->idr = 0xFFFFFFFF;
80002c40:	3f f8       	mov	r8,-1
80002c42:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002c44:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002c46:	30 08       	mov	r8,0
80002c48:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002c4a:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002c4c:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002c4e:	ea 68 61 0c 	mov	r8,680204
80002c52:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002c54:	5e fc       	retal	r12
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002c56:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002c58:	3f f8       	mov	r8,-1
80002c5a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002c5c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002c5e:	d5 03       	csrf	0x10
80002c60:	cf 3b       	rjmp	80002c46 <usart_reset+0x10>
80002c62:	d7 03       	nop

80002c64 <usart_init_rs232>:
              AVR32_USART_CR_RTSDIS_MASK;
}


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002c64:	d4 21       	pushm	r4-r7,lr
80002c66:	16 97       	mov	r7,r11
80002c68:	14 94       	mov	r4,r10
80002c6a:	18 96       	mov	r6,r12
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002c6c:	ce 5f       	rcall	80002c36 <usart_reset>
80002c6e:	58 07       	cp.w	r7,0

  // Check input values.
  if (!opt || // Null pointer.
80002c70:	c2 00       	breq	80002cb0 <usart_init_rs232+0x4c>
80002c72:	0f c8       	ld.ub	r8,r7[0x4]
      opt->charlength < 5 || opt->charlength > 9 ||
80002c74:	30 49       	mov	r9,4
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002c76:	f2 08 18 00 	cp.b	r8,r9
80002c7a:	e0 88 00 1b 	brls	80002cb0 <usart_init_rs232+0x4c>
80002c7e:	30 95       	mov	r5,9
80002c80:	ea 08 18 00 	cp.b	r8,r5
80002c84:	e0 8b 00 16 	brhi	80002cb0 <usart_init_rs232+0x4c>
80002c88:	0f d9       	ld.ub	r9,r7[0x5]
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002c8a:	30 78       	mov	r8,7
80002c8c:	f0 09 18 00 	cp.b	r9,r8
80002c90:	e0 8b 00 10 	brhi	80002cb0 <usart_init_rs232+0x4c>
80002c94:	8e 39       	ld.sh	r9,r7[0x6]
      opt->stopbits > 2 + 255 ||
80002c96:	e0 68 01 01 	mov	r8,257
80002c9a:	f0 09 19 00 	cp.h	r9,r8
80002c9e:	e0 8b 00 09 	brhi	80002cb0 <usart_init_rs232+0x4c>
80002ca2:	ef 39 00 08 	ld.ub	r9,r7[8]
      opt->channelmode > 3 ||
80002ca6:	30 38       	mov	r8,3
80002ca8:	f0 09 18 00 	cp.b	r9,r8
80002cac:	e0 88 00 03 	brls	80002cb2 <usart_init_rs232+0x4e>
80002cb0:	da 2a       	popm	r4-r7,pc,r12=1
  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002cb2:	08 9a       	mov	r10,r4
  if (!opt || // Null pointer.
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002cb4:	6e 0b       	ld.w	r11,r7[0x0]
80002cb6:	0c 9c       	mov	r12,r6
80002cb8:	c7 bf       	rcall	80002bae <usart_set_async_baudrate>
80002cba:	58 1c       	cp.w	r12,1
80002cbc:	cf a0       	breq	80002cb0 <usart_init_rs232+0x4c>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002cbe:	0f c8       	ld.ub	r8,r7[0x4]
80002cc0:	ea 08 18 00 	cp.b	r8,r5
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002cc4:	c2 90       	breq	80002d16 <usart_init_rs232+0xb2>
80002cc6:	6c 19       	ld.w	r9,r6[0x4]
80002cc8:	20 58       	sub	r8,5
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002cca:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002cce:	8d 18       	st.w	r6[0x4],r8
80002cd0:	6c 19       	ld.w	r9,r6[0x4]
80002cd2:	ef 3a 00 08 	ld.ub	r10,r7[8]
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002cd6:	0f d8       	ld.ub	r8,r7[0x5]
80002cd8:	a9 78       	lsl	r8,0x9
80002cda:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80002cde:	12 48       	or	r8,r9
80002ce0:	8d 18       	st.w	r6[0x4],r8
80002ce2:	30 29       	mov	r9,2
80002ce4:	8e 38       	ld.sh	r8,r7[0x6]
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002ce6:	f2 08 19 00 	cp.h	r8,r9
80002cea:	e0 88 00 10 	brls	80002d0a <usart_init_rs232+0xa6>
80002cee:	6c 18       	ld.w	r8,r6[0x4]
80002cf0:	ad b8       	sbr	r8,0xd
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002cf2:	8d 18       	st.w	r6[0x4],r8
80002cf4:	8e b8       	ld.uh	r8,r7[0x6]
80002cf6:	20 28       	sub	r8,2
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002cf8:	8d a8       	st.w	r6[0x28],r8
80002cfa:	6c 18       	ld.w	r8,r6[0x4]
80002cfc:	e0 18 ff f0 	andl	r8,0xfff0
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002d00:	8d 18       	st.w	r6[0x4],r8
80002d02:	30 0c       	mov	r12,0
80002d04:	35 08       	mov	r8,80
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002d06:	8d 08       	st.w	r6[0x0],r8
80002d08:	d8 22       	popm	r4-r7,pc
80002d0a:	6c 19       	ld.w	r9,r6[0x4]
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002d0c:	5c 78       	castu.h	r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002d0e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80002d12:	8d 18       	st.w	r6[0x4],r8
80002d14:	cf 3b       	rjmp	80002cfa <usart_init_rs232+0x96>
80002d16:	6c 18       	ld.w	r8,r6[0x4]
80002d18:	b1 b8       	sbr	r8,0x11
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002d1a:	8d 18       	st.w	r6[0x4],r8
80002d1c:	cd ab       	rjmp	80002cd0 <usart_init_rs232+0x6c>
80002d1e:	d7 03       	nop

80002d20 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80002d20:	d4 01       	pushm	lr
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80002d22:	c7 5f       	rcall	80002c0c <usart_write_line>
80002d24:	d8 02       	popm	pc
}
80002d26:	d7 03       	nop

80002d28 <print_hex>:
80002d28:	d4 01       	pushm	lr
80002d2a:	20 3d       	sub	sp,12
{
  char tmp[9];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
80002d2c:	30 08       	mov	r8,0
  // Transmit the resulting string with the given USART.
  print(usart, tmp);
}


void print_hex(volatile avr32_usart_t *usart, unsigned long n)
80002d2e:	fa ce 00 01 	sub	lr,sp,1
{
  char tmp[9];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
80002d32:	fb 68 00 08 	st.b	sp[8],r8
80002d36:	48 9a       	lddpc	r10,80002d58 <print_hex+0x30>
80002d38:	fa c8 ff f9 	sub	r8,sp,-7
  for (i = 7; i >= 0; i--)
  {
    tmp[i] = HEX_DIGITS[n & 0xF];
80002d3c:	f3 db c0 04 	bfextu	r9,r11,0x0,0x4
80002d40:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002d44:	b0 89       	st.b	r8[0x0],r9
    n >>= 4;
80002d46:	a5 8b       	lsr	r11,0x4
80002d48:	20 18       	sub	r8,1
  char tmp[9];
  int i;

  // Convert the given number to an ASCII hexadecimal representation.
  tmp[8] = '\0';
  for (i = 7; i >= 0; i--)
80002d4a:	1c 38       	cp.w	r8,lr
80002d4c:	cf 81       	brne	80002d3c <print_hex+0x14>
    tmp[i] = HEX_DIGITS[n & 0xF];
    n >>= 4;
  }

  // Transmit the resulting string with the given USART.
  print(usart, tmp);
80002d4e:	1a 9b       	mov	r11,sp
80002d50:	ce 8f       	rcall	80002d20 <print>
80002d52:	2f dd       	sub	sp,-12
}
80002d54:	d8 02       	popm	pc
80002d56:	d7 03       	nop
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	af f8       	*unknown*

80002d5c <print_dbg_hex>:
80002d5c:	d4 01       	pushm	lr
80002d5e:	18 9b       	mov	r11,r12


void print_dbg_hex(unsigned long n)
{
  // Redirection to the debug USART.
  print_hex(DBG_USART, n);
80002d60:	fe 7c 14 00 	mov	r12,-60416
80002d64:	ce 2f       	rcall	80002d28 <print_hex>
80002d66:	d8 02       	popm	pc

80002d68 <print_ulong>:
}
80002d68:	eb cd 40 e0 	pushm	r5-r7,lr
80002d6c:	20 3d       	sub	sp,12
80002d6e:	30 08       	mov	r8,0
{
  char tmp[11];
  int i = sizeof(tmp) - 1;

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
80002d70:	30 a9       	mov	r9,10
80002d72:	fb 68 00 0a 	st.b	sp[10],r8
80002d76:	1a 9e       	mov	lr,sp
  do
  {
    tmp[--i] = '0' + n % 10;
80002d78:	e0 65 cc cd 	mov	r5,52429
80002d7c:	ea 15 cc cc 	orh	r5,0xcccc
80002d80:	f6 05 06 46 	mulu.d	r6,r11,r5
80002d84:	20 19       	sub	r9,1
80002d86:	0e 98       	mov	r8,r7
80002d88:	a3 98       	lsr	r8,0x3
80002d8a:	f0 08 00 2a 	add	r10,r8,r8<<0x2
80002d8e:	f6 0a 01 1b 	sub	r11,r11,r10<<0x1
80002d92:	2d 0b       	sub	r11,-48
80002d94:	fc 09 0b 0b 	st.b	lr[r9],r11
    n /= 10;
80002d98:	10 9b       	mov	r11,r8
  } while (n);
80002d9a:	58 08       	cp.w	r8,0
80002d9c:	cf 21       	brne	80002d80 <print_ulong+0x18>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
80002d9e:	fc 09 00 0b 	add	r11,lr,r9
80002da2:	cb ff       	rcall	80002d20 <print>
80002da4:	2f dd       	sub	sp,-12
}
80002da6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002daa:	d7 03       	nop

80002dac <print_dbg_ulong>:
80002dac:	d4 01       	pushm	lr
80002dae:	18 9b       	mov	r11,r12


void print_dbg_ulong(unsigned long n)
{
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
80002db0:	fe 7c 14 00 	mov	r12,-60416
80002db4:	cd af       	rcall	80002d68 <print_ulong>
80002db6:	d8 02       	popm	pc

80002db8 <print_dbg>:
}
80002db8:	d4 01       	pushm	lr
80002dba:	18 9b       	mov	r11,r12
80002dbc:	fe 7c 14 00 	mov	r12,-60416


void print_dbg(const char *str)
{
  // Redirection to the debug USART.
  print(DBG_USART, str);
80002dc0:	cb 0f       	rcall	80002d20 <print>
80002dc2:	d8 02       	popm	pc

80002dc4 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
80002dc4:	eb cd 40 c0 	pushm	r6-r7,lr
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
80002dc8:	e0 69 2c 4e 	mov	r9,11342
80002dcc:	e0 68 2c 50 	mov	r8,11344
80002dd0:	13 8b       	ld.ub	r11,r9[0x0]
80002dd2:	11 dc       	ld.ub	r12,r8[0x5]
80002dd4:	30 39       	mov	r9,3
80002dd6:	f2 0b 18 00 	cp.b	r11,r9
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002dda:	c4 60       	breq	80002e66 <sd_mmc_spi_get_capacity+0xa2>
80002ddc:	11 fe       	ld.ub	lr,r8[0x7]
80002dde:	f1 37 00 08 	ld.ub	r7,r8[8]
80002de2:	a7 87       	lsr	r7,0x6
80002de4:	ee 0e 00 27 	add	r7,r7,lr<<0x2
80002de8:	11 ee       	ld.ub	lr,r8[0x6]
80002dea:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
    capacity = (uint64_t)c_size << 19;
    capacity_mult = (c_size >> 13) & 0x01FF;
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
80002dee:	ab 6e       	lsl	lr,0xa
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
80002df0:	f1 39 00 0a 	ld.ub	r9,r8[10]
80002df4:	1c 07       	add	r7,lr
80002df6:	f2 06 16 07 	lsr	r6,r9,0x7
80002dfa:	2f f7       	sub	r7,-1
80002dfc:	f1 3e 00 09 	ld.ub	lr,r8[9]
80002e00:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80002e04:	ec 0e 00 1e 	add	lr,r6,lr<<0x1
80002e08:	2f ee       	sub	lr,-2
80002e0a:	ee 0e 09 4e 	lsl	lr,r7,lr
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
80002e0e:	20 1e       	sub	lr,1
80002e10:	e0 6a 2c 48 	mov	r10,11336
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
80002e14:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
80002e18:	95 0e       	st.w	r10[0x0],lr
80002e1a:	74 0e       	ld.w	lr,r10[0x0]
80002e1c:	2f fe       	sub	lr,-1
80002e1e:	fc 0c 09 4e 	lsl	lr,lr,r12
80002e22:	1c 96       	mov	r6,lr
80002e24:	30 0e       	mov	lr,0
80002e26:	1c 97       	mov	r7,lr
    capacity_mult = 0;
80002e28:	e0 6e 2c 3c 	mov	lr,11324
80002e2c:	fc e7 00 00 	st.d	lr[0],r6
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002e30:	e0 67 2c 44 	mov	r7,11332
80002e34:	30 0e       	mov	lr,0
80002e36:	ae 0e       	st.h	r7[0x0],lr
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002e38:	30 97       	mov	r7,9
80002e3a:	ee 0c 18 00 	cp.b	r12,r7
80002e3e:	e0 88 00 07 	brls	80002e4c <sd_mmc_spi_get_capacity+0x88>
    }
  }
  if (card_type == MMC_CARD)
80002e42:	74 0e       	ld.w	lr,r10[0x0]
80002e44:	20 9c       	sub	r12,9
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
80002e46:	fc 0c 09 4c 	lsl	r12,lr,r12
80002e4a:	95 0c       	st.w	r10[0x0],r12
80002e4c:	58 0b       	cp.w	r11,0
80002e4e:	c3 51       	brne	80002eb8 <sd_mmc_spi_get_capacity+0xf4>
80002e50:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80002e54:	f1 38 00 0b 	ld.ub	r8,r8[11]
80002e58:	f3 d9 c0 45 	bfextu	r9,r9,0x2,0x5
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
  if (card_type == SD_CARD_2_SDHC) {
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002e5c:	a5 98       	lsr	r8,0x5
80002e5e:	f1 ea 10 38 	or	r8,r8,r10<<0x3
80002e62:	2f f8       	sub	r8,-1
80002e64:	c3 28       	rjmp	80002ec8 <sd_mmc_spi_get_capacity+0x104>
80002e66:	f1 3e 00 08 	ld.ub	lr,r8[8]
80002e6a:	f1 39 00 09 	ld.ub	r9,r8[9]
80002e6e:	f3 ee 10 89 	or	r9,r9,lr<<0x8
    ++c_size;
80002e72:	11 fe       	ld.ub	lr,r8[0x7]
    capacity = (uint64_t)c_size << 19;
80002e74:	fd de c0 06 	bfextu	lr,lr,0x0,0x6
80002e78:	f3 ee 11 0e 	or	lr,r9,lr<<0x10
80002e7c:	2f fe       	sub	lr,-1
80002e7e:	fc 09 16 0d 	lsr	r9,lr,0xd
80002e82:	fc 0a 15 13 	lsl	r10,lr,0x13
    capacity_mult = (c_size >> 13) & 0x01FF;
80002e86:	e0 6c 2c 3c 	mov	r12,11324
80002e8a:	12 9b       	mov	r11,r9
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002e8c:	f8 eb 00 00 	st.d	r12[0],r10
80002e90:	f5 d9 c0 09 	bfextu	r10,r9,0x0,0x9
80002e94:	e0 69 2c 44 	mov	r9,11332
80002e98:	b2 0a       	st.h	r9[0x0],r10
80002e9a:	f8 ea 00 00 	ld.d	r10,r12[0]
80002e9e:	92 0c       	ld.sh	r12,r9[0x0]
80002ea0:	f4 09 16 09 	lsr	r9,r10,0x9
80002ea4:	b7 7c       	lsl	r12,0x17
80002ea6:	f3 eb 11 79 	or	r9,r9,r11<<0x17
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002eaa:	20 19       	sub	r9,1
80002eac:	18 09       	add	r9,r12
80002eae:	e0 6a 2c 48 	mov	r10,11336
80002eb2:	95 09       	st.w	r10[0x0],r9
80002eb4:	f1 39 00 0a 	ld.ub	r9,r8[10]
    erase_grp_mult = 0;
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
80002eb8:	f1 38 00 0b 	ld.ub	r8,r8[11]
80002ebc:	a7 98       	lsr	r8,0x7
80002ebe:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
}
80002ec2:	f0 09 00 19 	add	r9,r8,r9<<0x1
80002ec6:	30 18       	mov	r8,1
80002ec8:	2f f9       	sub	r9,-1
80002eca:	b1 39       	mul	r9,r8
80002ecc:	e0 68 2c 46 	mov	r8,11334
80002ed0:	b0 09       	st.h	r8[0x0],r9
80002ed2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ed6:	d7 03       	nop

80002ed8 <sd_mmc_spi_write_close>:
80002ed8:	5e fc       	retal	r12
80002eda:	d7 03       	nop

80002edc <sd_mmc_spi_read_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA read transfer
//! page programming.
//!
void sd_mmc_spi_read_close_PDCA (void)
{
80002edc:	d4 01       	pushm	lr

  // load 16-bit CRC (ignored)
  spi_write(SD_MMC_SPI,0xFF);
80002ede:	e0 6b 00 ff 	mov	r11,255
80002ee2:	fe 7c 28 00 	mov	r12,-55296
80002ee6:	fe b0 fd 60 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80002eea:	e0 6b 00 ff 	mov	r11,255
80002eee:	fe 7c 28 00 	mov	r12,-55296
80002ef2:	fe b0 fd 5a 	rcall	800029a6 <spi_write>

  // continue delivering some clock cycles
  spi_write(SD_MMC_SPI,0xFF);
80002ef6:	e0 6b 00 ff 	mov	r11,255
80002efa:	fe 7c 28 00 	mov	r12,-55296
80002efe:	fe b0 fd 54 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80002f02:	e0 6b 00 ff 	mov	r11,255
80002f06:	fe 7c 28 00 	mov	r12,-55296
80002f0a:	fe b0 fd 4e 	rcall	800029a6 <spi_write>

  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002f0e:	30 2b       	mov	r11,2
80002f10:	fe 7c 28 00 	mov	r12,-55296
80002f14:	fe b0 fc dc 	rcall	800028cc <spi_unselectChip>

}
80002f18:	d8 02       	popm	pc
80002f1a:	d7 03       	nop

80002f1c <sd_mmc_spi_send_and_read>:
80002f1c:	d4 01       	pushm	lr
80002f1e:	20 1d       	sub	sp,4
80002f20:	18 9b       	mov	r11,r12
80002f22:	fe 7c 28 00 	mov	r12,-55296
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
80002f26:	fe b0 fd 40 	rcall	800029a6 <spi_write>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002f2a:	fa cb ff fe 	sub	r11,sp,-2
80002f2e:	fe 7c 28 00 	mov	r12,-55296
80002f32:	fe b0 fd 48 	rcall	800029c2 <spi_read>
80002f36:	58 1c       	cp.w	r12,1
80002f38:	c0 40       	breq	80002f40 <sd_mmc_spi_send_and_read+0x24>
     return 0xFF;
   return data_read;
80002f3a:	1b bc       	ld.ub	r12,sp[0x3]
}
80002f3c:	2f fd       	sub	sp,-4
80002f3e:	d8 02       	popm	pc
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
80002f40:	e0 6c 00 ff 	mov	r12,255
     return 0xFF;
   return data_read;
}
80002f44:	2f fd       	sub	sp,-4
80002f46:	d8 02       	popm	pc

80002f48 <sd_mmc_spi_wait_not_busy>:
80002f48:	eb cd 40 e0 	pushm	r5-r7,lr
80002f4c:	30 2b       	mov	r11,2
80002f4e:	fe 7c 28 00 	mov	r12,-55296
bool sd_mmc_spi_wait_not_busy(void)
{
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f52:	e0 65 2c 60 	mov	r5,11360
80002f56:	fe b0 fc 93 	rcall	8000287c <spi_selectChip>
80002f5a:	3f f6       	mov	r6,-1
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002f5c:	30 07       	mov	r7,0
  {
    retry++;
80002f5e:	c0 58       	rjmp	80002f68 <sd_mmc_spi_wait_not_busy+0x20>
    if (retry == 200000)
80002f60:	2f f7       	sub	r7,-1
80002f62:	e2 57 0d 40 	cp.w	r7,200000
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002f66:	c0 f0       	breq	80002f84 <sd_mmc_spi_wait_not_busy+0x3c>
80002f68:	e0 6c 00 ff 	mov	r12,255
80002f6c:	cd 8f       	rcall	80002f1c <sd_mmc_spi_send_and_read>
80002f6e:	aa 8c       	st.b	r5[0x0],r12
80002f70:	ec 0c 18 00 	cp.b	r12,r6
80002f74:	cf 61       	brne	80002f60 <sd_mmc_spi_wait_not_busy+0x18>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f76:	30 2b       	mov	r11,2
80002f78:	fe 7c 28 00 	mov	r12,-55296
80002f7c:	fe b0 fc a8 	rcall	800028cc <spi_unselectChip>
80002f80:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
  {
    retry++;
    if (retry == 200000)
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002f84:	30 2b       	mov	r11,2
80002f86:	fe 7c 28 00 	mov	r12,-55296
80002f8a:	fe b0 fc a1 	rcall	800028cc <spi_unselectChip>
80002f8e:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80002f92:	d7 03       	nop

80002f94 <sd_mmc_spi_write_open>:
80002f94:	d4 01       	pushm	lr
80002f96:	e0 68 06 28 	mov	r8,1576
80002f9a:	a9 7c       	lsl	r12,0x9
80002f9c:	91 0c       	st.w	r8[0x0],r12
80002f9e:	cd 5f       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
80002fa0:	d8 02       	popm	pc
80002fa2:	d7 03       	nop

80002fa4 <sd_mmc_spi_command>:
  // Set the global memory ptr at a Byte address.
  gl_ptr_mem = pos << 9; // gl_ptr_mem = pos * 512

  // wait for MMC not busy
  return sd_mmc_spi_wait_not_busy();
}
80002fa4:	d4 21       	pushm	r4-r7,lr
80002fa6:	16 97       	mov	r7,r11
80002fa8:	18 96       	mov	r6,r12
80002faa:	e0 6b 00 ff 	mov	r11,255
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
80002fae:	fe 7c 28 00 	mov	r12,-55296
80002fb2:	fe b0 fc fa 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
80002fb6:	fe 7c 28 00 	mov	r12,-55296
80002fba:	0c 9b       	mov	r11,r6
80002fbc:	a7 ab       	sbr	r11,0x6
80002fbe:	5c 5b       	castu.b	r11
80002fc0:	fe b0 fc f3 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
80002fc4:	ee 0b 16 18 	lsr	r11,r7,0x18
80002fc8:	fe 7c 28 00 	mov	r12,-55296
80002fcc:	fe b0 fc ed 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI, arg>>16);
80002fd0:	ee 0b 16 10 	lsr	r11,r7,0x10
80002fd4:	fe 7c 28 00 	mov	r12,-55296
80002fd8:	fe b0 fc e7 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI, arg>>8 );
80002fdc:	f7 d7 c1 10 	bfextu	r11,r7,0x8,0x10
80002fe0:	fe 7c 28 00 	mov	r12,-55296
80002fe4:	fe b0 fc e1 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI, arg    );
80002fe8:	0e 9b       	mov	r11,r7
80002fea:	fe 7c 28 00 	mov	r12,-55296
80002fee:	5c 7b       	castu.h	r11
80002ff0:	fe b0 fc db 	rcall	800029a6 <spi_write>
  switch(command)
80002ff4:	30 08       	mov	r8,0
80002ff6:	f0 06 18 00 	cp.b	r6,r8
80002ffa:	c1 f0       	breq	80003038 <sd_mmc_spi_command+0x94>
80002ffc:	30 88       	mov	r8,8
80002ffe:	f0 06 18 00 	cp.b	r6,r8
80003002:	c2 20       	breq	80003046 <sd_mmc_spi_command+0xa2>
         break;
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
         break;
      default:
         spi_write(SD_MMC_SPI, 0xff);
80003004:	e0 6b 00 ff 	mov	r11,255
80003008:	fe 7c 28 00 	mov	r12,-55296
8000300c:	fe b0 fc cd 	rcall	800029a6 <spi_write>

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
80003010:	3f f8       	mov	r8,-1
80003012:	e0 66 2c 60 	mov	r6,11360
80003016:	10 95       	mov	r5,r8
80003018:	ac 88       	st.b	r6[0x0],r8
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
    retry++;
    if(retry > 10) break;
8000301a:	30 07       	mov	r7,0
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000301c:	30 b4       	mov	r4,11
8000301e:	e0 6c 00 ff 	mov	r12,255
80003022:	c7 df       	rcall	80002f1c <sd_mmc_spi_send_and_read>
80003024:	ac 8c       	st.b	r6[0x0],r12
80003026:	ea 0c 18 00 	cp.b	r12,r5
8000302a:	c0 61       	brne	80003036 <sd_mmc_spi_command+0x92>
  {
    retry++;
8000302c:	2f f7       	sub	r7,-1
8000302e:	5c 57       	castu.b	r7
    if(retry > 10) break;
80003030:	e8 07 18 00 	cp.b	r7,r4
80003034:	cf 51       	brne	8000301e <sd_mmc_spi_command+0x7a>
  }
  return r1;
}
80003036:	d8 22       	popm	r4-r7,pc
  spi_write(SD_MMC_SPI, arg>>8 );
  spi_write(SD_MMC_SPI, arg    );
  switch(command)
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80003038:	e0 6b 00 95 	mov	r11,149
8000303c:	fe 7c 28 00 	mov	r12,-55296
80003040:	fe b0 fc b3 	rcall	800029a6 <spi_write>
         break;
80003044:	ce 6b       	rjmp	80003010 <sd_mmc_spi_command+0x6c>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80003046:	e0 6b 00 87 	mov	r11,135
8000304a:	fe 7c 28 00 	mov	r12,-55296
8000304e:	fe b0 fc ac 	rcall	800029a6 <spi_write>
         break;
80003052:	cd fb       	rjmp	80003010 <sd_mmc_spi_command+0x6c>

80003054 <sd_mmc_spi_send_command>:
80003054:	eb cd 40 c0 	pushm	r6-r7,lr
80003058:	18 97       	mov	r7,r12
8000305a:	16 96       	mov	r6,r11
8000305c:	fe 7c 28 00 	mov	r12,-55296
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003060:	30 2b       	mov	r11,2
80003062:	fe b0 fc 0d 	rcall	8000287c <spi_selectChip>
  r1 = sd_mmc_spi_command(command, arg);
80003066:	0c 9b       	mov	r11,r6
80003068:	0e 9c       	mov	r12,r7
8000306a:	c9 df       	rcall	80002fa4 <sd_mmc_spi_command>
8000306c:	30 2b       	mov	r11,2
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000306e:	e0 67 2c 60 	mov	r7,11360
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(command, arg);
80003072:	ae 8c       	st.b	r7[0x0],r12
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003074:	fe 7c 28 00 	mov	r12,-55296
80003078:	fe b0 fc 2a 	rcall	800028cc <spi_unselectChip>
  return r1;
}
8000307c:	0f 8c       	ld.ub	r12,r7[0x0]
8000307e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003082:	d7 03       	nop

80003084 <sd_mmc_spi_check_presence>:
80003084:	d4 21       	pushm	r4-r7,lr
80003086:	e0 67 06 40 	mov	r7,1600
8000308a:	30 06       	mov	r6,0
8000308c:	0f 88       	ld.ub	r8,r7[0x0]
8000308e:	ec 08 18 00 	cp.b	r8,r6
80003092:	c1 91       	brne	800030c4 <sd_mmc_spi_check_presence+0x40>
bool sd_mmc_spi_check_presence(void)
{
  uint16_t retry;

  retry = 0;
  if (sd_mmc_spi_init_done == false)
80003094:	30 07       	mov	r7,0
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80003096:	e0 65 2c 60 	mov	r5,11360
8000309a:	30 16       	mov	r6,1
8000309c:	30 b4       	mov	r4,11
8000309e:	30 0b       	mov	r11,0
800030a0:	16 9c       	mov	r12,r11
800030a2:	cd 9f       	rcall	80003054 <sd_mmc_spi_send_command>
800030a4:	aa 8c       	st.b	r5[0x0],r12
800030a6:	ec 0c 18 00 	cp.b	r12,r6
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800030aa:	c1 50       	breq	800030d4 <sd_mmc_spi_check_presence+0x50>
800030ac:	e0 6b 00 ff 	mov	r11,255
800030b0:	fe 7c 28 00 	mov	r12,-55296
800030b4:	fe b0 fc 79 	rcall	800029a6 <spi_write>
      retry++;
800030b8:	2f f7       	sub	r7,-1
      if (retry > 10)
800030ba:	5c 87       	casts.h	r7
800030bc:	e8 07 19 00 	cp.h	r7,r4
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
800030c0:	ce f1       	brne	8000309e <sd_mmc_spi_check_presence+0x1a>
    return true;
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
800030c2:	d8 2a       	popm	r4-r7,pc,r12=0
800030c4:	30 0b       	mov	r11,0
800030c6:	33 bc       	mov	r12,59
800030c8:	cc 6f       	rcall	80003054 <sd_mmc_spi_send_command>
800030ca:	e0 68 2c 60 	mov	r8,11360
800030ce:	b0 8c       	st.b	r8[0x0],r12
800030d0:	58 0c       	cp.w	r12,0
      return true;
    sd_mmc_spi_init_done = false;
    return false;
800030d2:	c0 21       	brne	800030d6 <sd_mmc_spi_check_presence+0x52>
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
      return true;
    sd_mmc_spi_init_done = false;
800030d4:	da 2a       	popm	r4-r7,pc,r12=1
800030d6:	ae 86       	st.b	r7[0x0],r6
800030d8:	d8 2a       	popm	r4-r7,pc,r12=0
800030da:	d7 03       	nop

800030dc <sd_mmc_spi_write_sector_from_ram>:
800030dc:	d4 21       	pushm	r4-r7,lr
800030de:	18 97       	mov	r7,r12
800030e0:	c3 4f       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
800030e2:	c0 21       	brne	800030e6 <sd_mmc_spi_write_sector_from_ram+0xa>
800030e4:	d8 2a       	popm	r4-r7,pc,r12=0
800030e6:	30 2b       	mov	r11,2

  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800030e8:	fe 7c 28 00 	mov	r12,-55296
800030ec:	fe b0 fb c8 	rcall	8000287c <spi_selectChip>
800030f0:	e0 68 2c 4e 	mov	r8,11342

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
800030f4:	11 89       	ld.ub	r9,r8[0x0]
800030f6:	30 38       	mov	r8,3
800030f8:	f0 09 18 00 	cp.b	r9,r8
800030fc:	c6 60       	breq	800031c8 <sd_mmc_spi_write_sector_from_ram+0xec>
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
800030fe:	e0 64 06 28 	mov	r4,1576
80003102:	31 8c       	mov	r12,24
80003104:	68 0b       	ld.w	r11,r4[0x0]
80003106:	e0 65 2c 60 	mov	r5,11360
8000310a:	c4 df       	rcall	80002fa4 <sd_mmc_spi_command>
  }

  // check for valid response
  if(r1 != 0x00)
8000310c:	aa 8c       	st.b	r5[0x0],r12
8000310e:	58 0c       	cp.w	r12,0
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
    return false;
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80003110:	c3 61       	brne	8000317c <sd_mmc_spi_write_sector_from_ram+0xa0>
80003112:	e0 6b 00 ff 	mov	r11,255
80003116:	fe 7c 28 00 	mov	r12,-55296
8000311a:	fe b0 fc 46 	rcall	800029a6 <spi_write>

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
8000311e:	e0 6b 00 fe 	mov	r11,254
80003122:	fe 7c 28 00 	mov	r12,-55296
//!
//! @return bit
//!   The write succeeded   -> true
//!   The write failed      -> false
//!
bool sd_mmc_spi_write_sector_from_ram(const void *ram)
80003126:	ee c6 fe 00 	sub	r6,r7,-512
  }
  // send dummy
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
8000312a:	fe b0 fc 3e 	rcall	800029a6 <spi_write>
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
  {
    spi_write(SD_MMC_SPI,*_ram++);
8000312e:	0f 3b       	ld.ub	r11,r7++
80003130:	fe 7c 28 00 	mov	r12,-55296
80003134:	fe b0 fc 39 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction

  // send data start token
  spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
  // write data
  for(i=0;i<MMC_SECTOR_SIZE;i++)
80003138:	0c 37       	cp.w	r7,r6
  {
    spi_write(SD_MMC_SPI,*_ram++);
  }

  spi_write(SD_MMC_SPI,0xFF);    // send CRC (field required but value ignored)
8000313a:	cf a1       	brne	8000312e <sd_mmc_spi_write_sector_from_ram+0x52>
8000313c:	e0 6b 00 ff 	mov	r11,255
80003140:	fe 7c 28 00 	mov	r12,-55296
80003144:	fe b0 fc 31 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80003148:	e0 6b 00 ff 	mov	r11,255
8000314c:	fe 7c 28 00 	mov	r12,-55296
80003150:	fe b0 fc 2b 	rcall	800029a6 <spi_write>

  // read data response token
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003154:	e0 6c 00 ff 	mov	r12,255
80003158:	ce 2e       	rcall	80002f1c <sd_mmc_spi_send_and_read>
8000315a:	aa 8c       	st.b	r5[0x0],r12
  if( (r1&MMC_DR_MASK) != MMC_DR_ACCEPT)
8000315c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003160:	58 5c       	cp.w	r12,5
80003162:	c1 30       	breq	80003188 <sd_mmc_spi_write_sector_from_ram+0xac>
  {
    spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80003164:	e0 6b 00 ff 	mov	r11,255
80003168:	fe 7c 28 00 	mov	r12,-55296
8000316c:	fe b0 fc 1d 	rcall	800029a6 <spi_write>
    spi_write(SD_MMC_SPI,0xFF);
80003170:	e0 6b 00 ff 	mov	r11,255
80003174:	fe 7c 28 00 	mov	r12,-55296
80003178:	fe b0 fc 17 	rcall	800029a6 <spi_write>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
8000317c:	30 2b       	mov	r11,2
8000317e:	fe 7c 28 00 	mov	r12,-55296
80003182:	fe b0 fb a5 	rcall	800028cc <spi_unselectChip>
80003186:	d8 2a       	popm	r4-r7,pc,r12=0
    return false;         // return ERROR byte
  }

  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80003188:	e0 6b 00 ff 	mov	r11,255
8000318c:	fe 7c 28 00 	mov	r12,-55296
80003190:	fe b0 fc 0b 	rcall	800029a6 <spi_write>
  spi_write(SD_MMC_SPI,0xFF);
80003194:	e0 6b 00 ff 	mov	r11,255
80003198:	fe 7c 28 00 	mov	r12,-55296
8000319c:	fe b0 fc 05 	rcall	800029a6 <spi_write>

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800031a0:	30 2b       	mov	r11,2
800031a2:	fe 7c 28 00 	mov	r12,-55296
800031a6:	fe b0 fb 93 	rcall	800028cc <spi_unselectChip>
  gl_ptr_mem += 512;        // Update the memory pointer.
800031aa:	68 08       	ld.w	r8,r4[0x0]
800031ac:	30 07       	mov	r7,0
800031ae:	f0 c8 fe 00 	sub	r8,r8,-512
  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
  {
    i++;
    if (i == 10)
800031b2:	30 a6       	mov	r6,10
  spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
  spi_write(SD_MMC_SPI,0xFF);

  // release chip select
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.
800031b4:	89 08       	st.w	r4[0x0],r8

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800031b6:	c0 68       	rjmp	800031c2 <sd_mmc_spi_write_sector_from_ram+0xe6>
  {
    i++;
800031b8:	2f f7       	sub	r7,-1
800031ba:	5c 87       	casts.h	r7
    if (i == 10)
800031bc:	ec 07 19 00 	cp.h	r7,r6
800031c0:	c9 20       	breq	800030e4 <sd_mmc_spi_write_sector_from_ram+0x8>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
  gl_ptr_mem += 512;        // Update the memory pointer.

  // wait card not busy after last programming operation
  i=0;
  while (false == sd_mmc_spi_wait_not_busy())
800031c2:	cc 3e       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
800031c4:	cf a0       	breq	800031b8 <sd_mmc_spi_write_sector_from_ram+0xdc>
800031c6:	da 2a       	popm	r4-r7,pc,r12=1
800031c8:	e0 64 06 28 	mov	r4,1576

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem>>9);
800031cc:	31 8c       	mov	r12,24
800031ce:	68 0b       	ld.w	r11,r4[0x0]
800031d0:	e0 65 2c 60 	mov	r5,11360
800031d4:	a9 9b       	lsr	r11,0x9
800031d6:	ce 7e       	rcall	80002fa4 <sd_mmc_spi_command>
800031d8:	aa 8c       	st.b	r5[0x0],r12
800031da:	c9 ab       	rjmp	8000310e <sd_mmc_spi_write_sector_from_ram+0x32>

800031dc <sd_mmc_spi_read_open_PDCA>:
800031dc:	eb cd 40 e0 	pushm	r5-r7,lr
800031e0:	a9 7c       	lsl	r12,0x9
800031e2:	e0 66 06 28 	mov	r6,1576
800031e6:	8d 0c       	st.w	r6[0x0],r12
800031e8:	cb 0e       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
800031ea:	c0 31       	brne	800031f0 <sd_mmc_spi_read_open_PDCA+0x14>
800031ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800031f0:	30 2b       	mov	r11,2
800031f2:	fe 7c 28 00 	mov	r12,-55296
800031f6:	fe b0 fb 43 	rcall	8000287c <spi_selectChip>
800031fa:	e0 68 2c 4e 	mov	r8,11342
800031fe:	11 89       	ld.ub	r9,r8[0x0]


  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
80003200:	30 38       	mov	r8,3
80003202:	f0 09 18 00 	cp.b	r9,r8
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
  } else {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem);
80003206:	c2 a0       	breq	8000325a <sd_mmc_spi_read_open_PDCA+0x7e>
80003208:	6c 0b       	ld.w	r11,r6[0x0]
8000320a:	31 1c       	mov	r12,17
8000320c:	e0 66 2c 60 	mov	r6,11360
80003210:	cc ae       	rcall	80002fa4 <sd_mmc_spi_command>
  }

  // check for valid response
  if (r1 != 0x00)
80003212:	ac 8c       	st.b	r6[0x0],r12
80003214:	58 0c       	cp.w	r12,0
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
       return false;
80003216:	c2 a1       	brne	8000326a <sd_mmc_spi_read_open_PDCA+0x8e>
80003218:	e0 67 75 30 	mov	r7,30000
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000321c:	3f f5       	mov	r5,-1
  {
     read_time_out--;
8000321e:	c0 48       	rjmp	80003226 <sd_mmc_spi_read_open_PDCA+0x4a>
80003220:	20 17       	sub	r7,1
     if (read_time_out == 0)   // TIME-OUT
80003222:	5c 87       	casts.h	r7
    return false;
  }

  // wait for token (may be a datablock start token OR a data error token !)
  read_time_out = 30000;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80003224:	c2 a0       	breq	80003278 <sd_mmc_spi_read_open_PDCA+0x9c>
80003226:	e0 6c 00 ff 	mov	r12,255
8000322a:	c7 9e       	rcall	80002f1c <sd_mmc_spi_send_and_read>
8000322c:	ac 8c       	st.b	r6[0x0],r12
8000322e:	ea 0c 18 00 	cp.b	r12,r5
80003232:	cf 70       	breq	80003220 <sd_mmc_spi_read_open_PDCA+0x44>
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80003234:	3f e8       	mov	r8,-2
80003236:	f0 0c 18 00 	cp.b	r12,r8
8000323a:	c0 e0       	breq	80003256 <sd_mmc_spi_read_open_PDCA+0x7a>
  {
    spi_write(SD_MMC_SPI,0xFF);
8000323c:	e0 6b 00 ff 	mov	r11,255
80003240:	fe 7c 28 00 	mov	r12,-55296
80003244:	fe b0 fb b1 	rcall	800029a6 <spi_write>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003248:	30 2b       	mov	r11,2
8000324a:	fe 7c 28 00 	mov	r12,-55296
8000324e:	fe b0 fb 3f 	rcall	800028cc <spi_unselectChip>
80003252:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
       return false;
     }
  }

  // check token
  if (r1 != MMC_STARTBLOCK_READ)
80003256:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI

  // issue command
  if(card_type == SD_CARD_2_SDHC) {
    r1 = sd_mmc_spi_command(MMC_READ_SINGLE_BLOCK, gl_ptr_mem>>9);
8000325a:	6c 0b       	ld.w	r11,r6[0x0]
8000325c:	31 1c       	mov	r12,17
8000325e:	a9 9b       	lsr	r11,0x9
80003260:	e0 66 2c 60 	mov	r6,11360
80003264:	ca 0e       	rcall	80002fa4 <sd_mmc_spi_command>
80003266:	ac 8c       	st.b	r6[0x0],r12
80003268:	cd 6b       	rjmp	80003214 <sd_mmc_spi_read_open_PDCA+0x38>
  }

  // check for valid response
  if (r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000326a:	30 2b       	mov	r11,2
8000326c:	fe 7c 28 00 	mov	r12,-55296
80003270:	fe b0 fb 2e 	rcall	800028cc <spi_unselectChip>
80003274:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
  {
     read_time_out--;
     if (read_time_out == 0)   // TIME-OUT
     {
       spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS); // unselect SD_MMC_SPI
80003278:	30 2b       	mov	r11,2
8000327a:	fe 7c 28 00 	mov	r12,-55296
8000327e:	fe b0 fb 27 	rcall	800028cc <spi_unselectChip>
80003282:	0e 9c       	mov	r12,r7
       return false;
80003284:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80003288 <sd_mmc_spi_check_hc>:
80003288:	eb cd 40 c0 	pushm	r6-r7,lr
8000328c:	c5 ee       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
8000328e:	c0 31       	brne	80003294 <sd_mmc_spi_check_hc+0xc>
80003290:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
80003294:	30 2b       	mov	r11,2
80003296:	fe 7c 28 00 	mov	r12,-55296
8000329a:	fe b0 fa f1 	rcall	8000287c <spi_selectChip>
8000329e:	30 0b       	mov	r11,0
800032a0:	e0 67 2c 60 	mov	r7,11360
800032a4:	33 ac       	mov	r12,58
800032a6:	c7 fe       	rcall	80002fa4 <sd_mmc_spi_command>
800032a8:	ae 8c       	st.b	r7[0x0],r12
800032aa:	c1 a1       	brne	800032de <sd_mmc_spi_check_hc+0x56>
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
  // check for valid response
  if(r1 != 0) {
800032ac:	e0 6c 00 ff 	mov	r12,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
800032b0:	c3 6e       	rcall	80002f1c <sd_mmc_spi_send_and_read>
800032b2:	18 96       	mov	r6,r12
800032b4:	e0 6c 00 ff 	mov	r12,255
  r1 = sd_mmc_spi_send_and_read(0xFF);
800032b8:	c3 2e       	rcall	80002f1c <sd_mmc_spi_send_and_read>
800032ba:	ae 8c       	st.b	r7[0x0],r12
800032bc:	e0 6c 00 ff 	mov	r12,255
800032c0:	c2 ee       	rcall	80002f1c <sd_mmc_spi_send_and_read>
  r1 = sd_mmc_spi_send_and_read(0xFF);
800032c2:	ae 8c       	st.b	r7[0x0],r12
800032c4:	e0 6c 00 ff 	mov	r12,255
800032c8:	c2 ae       	rcall	80002f1c <sd_mmc_spi_send_and_read>
800032ca:	30 2b       	mov	r11,2
  r1 = sd_mmc_spi_send_and_read(0xFF);
800032cc:	ae 8c       	st.b	r7[0x0],r12
800032ce:	fe 7c 28 00 	mov	r12,-55296
800032d2:	fe b0 fa fd 	rcall	800028cc <spi_unselectChip>
800032d6:	f9 d6 c0 c1 	bfextu	r12,r6,0x6,0x1
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032de:	30 2b       	mov	r11,2
800032e0:	fe 7c 28 00 	mov	r12,-55296
  if(hc_bit & 0x40) {
      return SDHC_CARD;
  }
  return 0;
}
800032e4:	fe b0 fa f4 	rcall	800028cc <spi_unselectChip>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
  // check for valid response
  if(r1 != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800032e8:	cd 4b       	rjmp	80003290 <sd_mmc_spi_check_hc+0x8>
800032ea:	d7 03       	nop

800032ec <sd_mmc_spi_get_if>:
800032ec:	eb cd 40 80 	pushm	r7,lr
800032f0:	c2 ce       	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
800032f2:	c0 31       	brne	800032f8 <sd_mmc_spi_get_if+0xc>
800032f4:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1
800032f8:	30 2b       	mov	r11,2
800032fa:	fe 7c 28 00 	mov	r12,-55296
800032fe:	fe b0 fa bf 	rcall	8000287c <spi_selectChip>
80003302:	e0 6b 01 aa 	mov	r11,426
80003306:	e0 67 2c 60 	mov	r7,11360
8000330a:	30 8c       	mov	r12,8
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
    return SD_FAILURE;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
8000330c:	c4 ce       	rcall	80002fa4 <sd_mmc_spi_command>
8000330e:	ae 8c       	st.b	r7[0x0],r12
80003310:	ed bc 00 02 	bld	r12,0x2
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
80003314:	c2 20       	breq	80003358 <sd_mmc_spi_get_if+0x6c>
80003316:	e0 6c 00 ff 	mov	r12,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_MMC;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000331a:	c0 1e       	rcall	80002f1c <sd_mmc_spi_send_and_read>
8000331c:	ae 8c       	st.b	r7[0x0],r12
8000331e:	e0 6c 00 ff 	mov	r12,255
  r1 = sd_mmc_spi_send_and_read(0xFF);
80003322:	fe b0 fd fd 	rcall	80002f1c <sd_mmc_spi_send_and_read>
80003326:	ae 8c       	st.b	r7[0x0],r12
80003328:	e0 6c 00 ff 	mov	r12,255
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000332c:	fe b0 fd f8 	rcall	80002f1c <sd_mmc_spi_send_and_read>
80003330:	ae 8c       	st.b	r7[0x0],r12
80003332:	ed bc 00 00 	bld	r12,0x0
  if((r1 & 0x01) == 0) {
80003336:	c1 e1       	brne	80003372 <sd_mmc_spi_get_if+0x86>
80003338:	e0 6c 00 ff 	mov	r12,255
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000333c:	fe b0 fd f0 	rcall	80002f1c <sd_mmc_spi_send_and_read>
80003340:	ae 8c       	st.b	r7[0x0],r12
80003342:	3a a8       	mov	r8,-86
80003344:	f0 0c 18 00 	cp.b	r12,r8
  if(r1 != 0xaa) {
80003348:	c0 f1       	brne	80003366 <sd_mmc_spi_get_if+0x7a>
8000334a:	30 2b       	mov	r11,2
8000334c:	fe 7c 28 00 	mov	r12,-55296
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE; /* wrong test pattern */
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003350:	fe b0 fa be 	rcall	800028cc <spi_unselectChip>
80003354:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80003358:	30 2b       	mov	r11,2
8000335a:	fe 7c 28 00 	mov	r12,-55296

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000335e:	fe b0 fa b7 	rcall	800028cc <spi_unselectChip>
80003362:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80003366:	30 2b       	mov	r11,2
80003368:	fe 7c 28 00 	mov	r12,-55296
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
    return SD_FAILURE;
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if(r1 != 0xaa) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000336c:	fe b0 fa b0 	rcall	800028cc <spi_unselectChip>
80003370:	cc 2b       	rjmp	800032f4 <sd_mmc_spi_get_if+0x8>
80003372:	30 2b       	mov	r11,2
80003374:	fe 7c 28 00 	mov	r12,-55296
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  r1 = sd_mmc_spi_send_and_read(0xFF);
  if((r1 & 0x01) == 0) {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003378:	fe b0 fa aa 	rcall	800028cc <spi_unselectChip>
8000337c:	e3 cf c0 80 	ldm	sp++,r7,pc,r12=-1

80003380 <sd_mmc_spi_get_csd>:
80003380:	eb cd 40 f8 	pushm	r3-r7,lr
80003384:	20 1d       	sub	sp,4
80003386:	18 96       	mov	r6,r12
80003388:	fe b0 fd e0 	rcall	80002f48 <sd_mmc_spi_wait_not_busy>
8000338c:	c0 41       	brne	80003394 <sd_mmc_spi_get_csd+0x14>
8000338e:	2f fd       	sub	sp,-4
80003390:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003394:	30 2b       	mov	r11,2
80003396:	fe 7c 28 00 	mov	r12,-55296
8000339a:	fe b0 fa 71 	rcall	8000287c <spi_selectChip>
  if (false == sd_mmc_spi_wait_not_busy())
    return false;

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
8000339e:	30 0b       	mov	r11,0
800033a0:	e0 67 2c 60 	mov	r7,11360
800033a4:	30 9c       	mov	r12,9
800033a6:	fe b0 fd ff 	rcall	80002fa4 <sd_mmc_spi_command>
  // check for valid response
  if(r1 != 0x00)
800033aa:	ae 8c       	st.b	r7[0x0],r12
800033ac:	c4 71       	brne	8000343a <sd_mmc_spi_get_csd+0xba>
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800033ae:	18 95       	mov	r5,r12
  {
    if (retry > 8)
800033b0:	3f e4       	mov	r4,-2
800033b2:	30 93       	mov	r3,9
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
      return false;
    }
    retry++;
800033b4:	c0 38       	rjmp	800033ba <sd_mmc_spi_get_csd+0x3a>
800033b6:	2f f5       	sub	r5,-1
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800033b8:	5c 55       	castu.b	r5
800033ba:	e0 6c 00 ff 	mov	r12,255
800033be:	fe b0 fd af 	rcall	80002f1c <sd_mmc_spi_send_and_read>
800033c2:	ae 8c       	st.b	r7[0x0],r12
800033c4:	e8 0c 18 00 	cp.b	r12,r4
  {
    if (retry > 8)
800033c8:	c0 c0       	breq	800033e0 <sd_mmc_spi_get_csd+0x60>
800033ca:	e6 05 18 00 	cp.b	r5,r3
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800033ce:	cf 41       	brne	800033b6 <sd_mmc_spi_get_csd+0x36>
800033d0:	30 2b       	mov	r11,2
800033d2:	fe 7c 28 00 	mov	r12,-55296
800033d6:	fe b0 fa 7b 	rcall	800028cc <spi_unselectChip>
800033da:	2f fd       	sub	sp,-4
800033dc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800033e0:	30 07       	mov	r7,0
800033e2:	fa c5 ff fe 	sub	r5,sp,-2
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
  {
   spi_write(SD_MMC_SPI,0xFF);
800033e6:	e0 6b 00 ff 	mov	r11,255
800033ea:	fe 7c 28 00 	mov	r12,-55296
800033ee:	fe b0 fa dc 	rcall	800029a6 <spi_write>
   spi_read(SD_MMC_SPI,&data_read);
800033f2:	0a 9b       	mov	r11,r5
800033f4:	fe 7c 28 00 	mov	r12,-55296
800033f8:	fe b0 fa e5 	rcall	800029c2 <spi_read>
    buffer[retry] = data_read;
800033fc:	9a 18       	ld.sh	r8,sp[0x2]
800033fe:	ec 07 0b 08 	st.b	r6[r7],r8
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
80003402:	2f f7       	sub	r7,-1
80003404:	59 07       	cp.w	r7,16
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
80003406:	cf 01       	brne	800033e6 <sd_mmc_spi_get_csd+0x66>
80003408:	e0 6b 00 ff 	mov	r11,255
8000340c:	fe 7c 28 00 	mov	r12,-55296
80003410:	fe b0 fa cb 	rcall	800029a6 <spi_write>
   spi_write(SD_MMC_SPI,0xFF);
80003414:	e0 6b 00 ff 	mov	r11,255
80003418:	fe 7c 28 00 	mov	r12,-55296
8000341c:	fe b0 fa c5 	rcall	800029a6 <spi_write>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80003420:	e0 6b 00 ff 	mov	r11,255
80003424:	fe 7c 28 00 	mov	r12,-55296
80003428:	fe b0 fa bf 	rcall	800029a6 <spi_write>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000342c:	30 2b       	mov	r11,2
8000342e:	fe 7c 28 00 	mov	r12,-55296
80003432:	fe b0 fa 4d 	rcall	800028cc <spi_unselectChip>
  return true;
80003436:	30 1c       	mov	r12,1
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
  // check for valid response
  if(r1 != 0x00)
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80003438:	ca bb       	rjmp	8000338e <sd_mmc_spi_get_csd+0xe>
8000343a:	30 2b       	mov	r11,2
8000343c:	fe 7c 28 00 	mov	r12,-55296
80003440:	fe b0 fa 46 	rcall	800028cc <spi_unselectChip>
    sd_mmc_spi_init_done = false;
80003444:	30 09       	mov	r9,0
80003446:	e0 68 06 40 	mov	r8,1600
    return false;
8000344a:	30 0c       	mov	r12,0
8000344c:	b0 89       	st.b	r8[0x0],r9
8000344e:	ca 0b       	rjmp	8000338e <sd_mmc_spi_get_csd+0xe>

80003450 <sd_mmc_spi_internal_init>:
80003450:	d4 31       	pushm	r0-r7,lr
80003452:	e6 68 1a 80 	mov	r8,400000
80003456:	e0 69 06 2c 	mov	r9,1580
8000345a:	93 18       	st.w	r9[0x4],r8
8000345c:	e0 68 06 3c 	mov	r8,1596
80003460:	12 9b       	mov	r11,r9
80003462:	70 0a       	ld.w	r10,r8[0x0]
80003464:	fe 7c 28 00 	mov	r12,-55296
80003468:	fe b0 fa 46 	rcall	800028f4 <spi_setupChipReg>
8000346c:	30 2b       	mov	r11,2
8000346e:	fe 7c 28 00 	mov	r12,-55296
  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80003472:	fe b0 fa 05 	rcall	8000287c <spi_selectChip>
80003476:	30 07       	mov	r7,0
  for(i = 0; i < 10; ++i) {
80003478:	2f f7       	sub	r7,-1
    spi_write(SD_MMC_SPI,0xFF);
8000347a:	e0 6b 00 ff 	mov	r11,255
8000347e:	fe 7c 28 00 	mov	r12,-55296
80003482:	fe b0 fa 92 	rcall	800029a6 <spi_write>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
80003486:	58 a7       	cp.w	r7,10
80003488:	cf 81       	brne	80003478 <sd_mmc_spi_internal_init+0x28>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000348a:	30 2b       	mov	r11,2
8000348c:	fe 7c 28 00 	mov	r12,-55296
80003490:	fe b0 fa 1e 	rcall	800028cc <spi_unselectChip>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
80003494:	30 08       	mov	r8,0
80003496:	e0 69 06 40 	mov	r9,1600
8000349a:	30 0b       	mov	r11,0
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000349c:	b2 88       	st.b	r9[0x0],r8
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
  card_type = MMC_CARD;
8000349e:	16 9c       	mov	r12,r11
800034a0:	e0 62 2c 4e 	mov	r2,11342
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800034a4:	a4 88       	st.b	r2[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034a6:	fe b0 fd d7 	rcall	80003054 <sd_mmc_spi_send_command>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800034aa:	e0 6b 00 ff 	mov	r11,255
800034ae:	e0 67 2c 60 	mov	r7,11360
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034b2:	30 16       	mov	r6,1
800034b4:	ae 8c       	st.b	r7[0x0],r12
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800034b6:	0e 90       	mov	r0,r7
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034b8:	fe 7c 28 00 	mov	r12,-55296
    // do retry counter
    retry++;
    if(retry > 100)
800034bc:	0c 93       	mov	r3,r6
800034be:	fe b0 fa 74 	rcall	800029a6 <spi_write>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800034c2:	36 51       	mov	r1,101
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034c4:	c0 f8       	rjmp	800034e2 <sd_mmc_spi_internal_init+0x92>
800034c6:	fe b0 fd c7 	rcall	80003054 <sd_mmc_spi_send_command>
    // do retry counter
    retry++;
800034ca:	e0 6b 00 ff 	mov	r11,255
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034ce:	a0 8c       	st.b	r0[0x0],r12
    // do retry counter
    retry++;
800034d0:	2f f6       	sub	r6,-1
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800034d2:	fe 7c 28 00 	mov	r12,-55296
    // do retry counter
    retry++;
    if(retry > 100)
800034d6:	5c 86       	casts.h	r6
800034d8:	fe b0 fa 67 	rcall	800029a6 <spi_write>
  card_type = MMC_CARD;
  retry = 0;
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
800034dc:	e2 06 19 00 	cp.h	r6,r1
800034e0:	c7 50       	breq	800035ca <sd_mmc_spi_internal_init+0x17a>
    // do retry counter
    retry++;
    if(retry > 100)
      return false;
  }
  while(r1 != 0x01);   // check memory enters idle_state
800034e2:	30 0b       	mov	r11,0
800034e4:	0f 85       	ld.ub	r5,r7[0x0]
800034e6:	16 9c       	mov	r12,r11
800034e8:	e0 64 2c 60 	mov	r4,11360

  if_cond = sd_mmc_spi_get_if();
800034ec:	e6 05 18 00 	cp.b	r5,r3
  if(if_cond == -1) {
800034f0:	ce b1       	brne	800034c6 <sd_mmc_spi_internal_init+0x76>
      return false; // card is bad
  } else if (if_cond == 1) {
800034f2:	cf de       	rcall	800032ec <sd_mmc_spi_get_if>
800034f4:	5b fc       	cp.w	r12,-1
      card_type = SD_CARD_2;
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
800034f6:	c6 a0       	breq	800035ca <sd_mmc_spi_internal_init+0x17a>
800034f8:	58 1c       	cp.w	r12,1
800034fa:	c6 90       	breq	800035cc <sd_mmc_spi_internal_init+0x17c>
800034fc:	30 0b       	mov	r11,0
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800034fe:	33 7c       	mov	r12,55
80003500:	fe b0 fd aa 	rcall	80003054 <sd_mmc_spi_send_command>
80003504:	e0 6b 00 ff 	mov	r11,255
80003508:	a8 8c       	st.b	r4[0x0],r12
8000350a:	fe 7c 28 00 	mov	r12,-55296

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000350e:	fe b0 fa 4c 	rcall	800029a6 <spi_write>
80003512:	30 0b       	mov	r11,0
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80003514:	32 9c       	mov	r12,41
80003516:	fe b0 fd 9f 	rcall	80003054 <sd_mmc_spi_send_command>
8000351a:	e0 6b 00 ff 	mov	r11,255
8000351e:	a8 8c       	st.b	r4[0x0],r12
80003520:	fe 7c 28 00 	mov	r12,-55296

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80003524:	fe b0 fa 41 	rcall	800029a6 <spi_write>
80003528:	09 88       	ld.ub	r8,r4[0x0]
8000352a:	e2 18 00 fe 	andl	r8,0xfe,COH
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000352e:	e0 80 00 85 	breq	80003638 <sd_mmc_spi_internal_init+0x1e8>
80003532:	30 08       	mov	r8,0
80003534:	30 0b       	mov	r11,0
80003536:	a4 88       	st.b	r2[0x0],r8
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003538:	16 9c       	mov	r12,r11
8000353a:	fe b0 fd 8d 	rcall	80003054 <sd_mmc_spi_send_command>
8000353e:	e0 6b 00 ff 	mov	r11,255
80003542:	a8 8c       	st.b	r4[0x0],r12
        // do retry counter
        retry++;
        if(retry > 100)
80003544:	30 16       	mov	r6,1
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003546:	fe 7c 28 00 	mov	r12,-55296
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
8000354a:	36 53       	mov	r3,101
8000354c:	fe b0 fa 2d 	rcall	800029a6 <spi_write>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80003550:	0c 95       	mov	r5,r6
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003552:	c0 f8       	rjmp	80003570 <sd_mmc_spi_internal_init+0x120>
80003554:	fe b0 fd 80 	rcall	80003054 <sd_mmc_spi_send_command>
        // do retry counter
        retry++;
80003558:	e0 6b 00 ff 	mov	r11,255
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000355c:	a8 8c       	st.b	r4[0x0],r12
        // do retry counter
        retry++;
8000355e:	2f f6       	sub	r6,-1
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003560:	fe 7c 28 00 	mov	r12,-55296
        // do retry counter
        retry++;
        if(retry > 100)
80003564:	5c 86       	casts.h	r6
80003566:	fe b0 fa 20 	rcall	800029a6 <spi_write>
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
      // reset card again
      retry = 0;
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
8000356a:	e6 06 19 00 	cp.h	r6,r3
8000356e:	c2 e0       	breq	800035ca <sd_mmc_spi_internal_init+0x17a>
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
80003570:	30 0b       	mov	r11,0
80003572:	0f 88       	ld.ub	r8,r7[0x0]
80003574:	16 9c       	mov	r12,r11
80003576:	ea 08 18 00 	cp.b	r8,r5
     if(retry == 50000)    // measured approx. 500 on several cards
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
8000357a:	ce d1       	brne	80003554 <sd_mmc_spi_internal_init+0x104>
8000357c:	05 88       	ld.ub	r8,r2[0x0]
8000357e:	c2 a8       	rjmp	800035d2 <sd_mmc_spi_internal_init+0x182>
80003580:	05 89       	ld.ub	r9,r2[0x0]
80003582:	30 28       	mov	r8,2
          card_type = SD_CARD_2_SDHC;
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80003584:	f0 09 18 00 	cp.b	r9,r8
80003588:	c7 10       	breq	8000366a <sd_mmc_spi_internal_init+0x21a>
8000358a:	30 0b       	mov	r11,0
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000358c:	33 bc       	mov	r12,59
8000358e:	fe b0 fd 63 	rcall	80003054 <sd_mmc_spi_send_command>
80003592:	e0 6b 00 ff 	mov	r11,255
80003596:	ae 8c       	st.b	r7[0x0],r12
80003598:	fe 7c 28 00 	mov	r12,-55296

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
8000359c:	fe b0 fa 05 	rcall	800029a6 <spi_write>
800035a0:	e0 6b 02 00 	mov	r11,512
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800035a4:	31 0c       	mov	r12,16
800035a6:	fe b0 fd 57 	rcall	80003054 <sd_mmc_spi_send_command>
800035aa:	e0 6b 00 ff 	mov	r11,255
800035ae:	ae 8c       	st.b	r7[0x0],r12
800035b0:	fe 7c 28 00 	mov	r12,-55296
  if (r1 != 0x00)
800035b4:	fe b0 f9 f9 	rcall	800029a6 <spi_write>
800035b8:	0f 89       	ld.ub	r9,r7[0x0]
800035ba:	30 08       	mov	r8,0
    return false;    // card unsupported if block length of 512b is not accepted

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
800035bc:	f0 09 18 00 	cp.b	r9,r8
800035c0:	c0 51       	brne	800035ca <sd_mmc_spi_internal_init+0x17a>
800035c2:	e0 6c 2c 50 	mov	r12,11344

  if_cond = sd_mmc_spi_get_if();
  if(if_cond == -1) {
      return false; // card is bad
  } else if (if_cond == 1) {
      card_type = SD_CARD_2;
800035c6:	cd de       	rcall	80003380 <sd_mmc_spi_get_csd>
800035c8:	c3 b1       	brne	8000363e <sd_mmc_spi_internal_init+0x1ee>
800035ca:	d8 3a       	popm	r0-r7,pc,r12=0
        // do retry counter
        retry++;
        if(retry > 100)
          return false;
      }
      while(r1 != 0x01);   // check memory enters idle_state
800035cc:	30 28       	mov	r8,2

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800035ce:	a4 88       	st.b	r2[0x0],r8
800035d0:	30 28       	mov	r8,2
800035d2:	30 06       	mov	r6,0
800035d4:	30 15       	mov	r5,1
800035d6:	30 24       	mov	r4,2
800035d8:	c1 18       	rjmp	800035fa <sd_mmc_spi_internal_init+0x1aa>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    }
     // do retry counter
     retry++;
800035da:	e8 08 18 00 	cp.b	r8,r4
     if(retry == 50000)    // measured approx. 500 on several cards
800035de:	c2 50       	breq	80003628 <sd_mmc_spi_internal_init+0x1d8>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    }
     // do retry counter
     retry++;
800035e0:	2f f6       	sub	r6,-1
     if(retry == 50000)    // measured approx. 500 on several cards
800035e2:	fe 78 c3 50 	mov	r8,-15536
800035e6:	5c 86       	casts.h	r6
        return false;
  } while (r1);
800035e8:	f0 06 19 00 	cp.h	r6,r8
800035ec:	ce f0       	breq	800035ca <sd_mmc_spi_internal_init+0x17a>
800035ee:	0f 89       	ld.ub	r9,r7[0x0]
800035f0:	30 08       	mov	r8,0
800035f2:	f0 09 18 00 	cp.b	r9,r8

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800035f6:	cc 50       	breq	80003580 <sd_mmc_spi_internal_init+0x130>
800035f8:	05 88       	ld.ub	r8,r2[0x0]
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
800035fa:	ea 08 18 00 	cp.b	r8,r5

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
  do {
    switch(card_type) {
800035fe:	c0 e0       	breq	8000361a <sd_mmc_spi_internal_init+0x1ca>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
80003600:	30 0b       	mov	r11,0
80003602:	30 1c       	mov	r12,1
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80003604:	ce b2       	brcc	800035da <sd_mmc_spi_internal_init+0x18a>
80003606:	fe b0 fd 27 	rcall	80003054 <sd_mmc_spi_send_command>
8000360a:	e0 6b 00 ff 	mov	r11,255
8000360e:	ae 8c       	st.b	r7[0x0],r12
80003610:	fe 7c 28 00 	mov	r12,-55296
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003614:	fe b0 f9 c9 	rcall	800029a6 <spi_write>
80003618:	ce 4b       	rjmp	800035e0 <sd_mmc_spi_internal_init+0x190>
8000361a:	30 0b       	mov	r11,0
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000361c:	33 7c       	mov	r12,55
8000361e:	fe b0 fd 1b 	rcall	80003054 <sd_mmc_spi_send_command>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      break;
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
80003622:	30 0b       	mov	r11,0
80003624:	32 9c       	mov	r12,41
80003626:	cf 0b       	rjmp	80003606 <sd_mmc_spi_internal_init+0x1b6>
80003628:	30 0b       	mov	r11,0
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
8000362a:	33 7c       	mov	r12,55
8000362c:	fe b0 fd 14 	rcall	80003054 <sd_mmc_spi_send_command>
80003630:	fc 1b 40 00 	movh	r11,0x4000

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
80003634:	32 9c       	mov	r12,41
80003636:	ce 8b       	rjmp	80003606 <sd_mmc_spi_internal_init+0x1b6>
  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
    return false;

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
80003638:	a4 85       	st.b	r2[0x0],r5
8000363a:	30 18       	mov	r8,1

  sd_mmc_spi_init_done = true;

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000363c:	cc bb       	rjmp	800035d2 <sd_mmc_spi_internal_init+0x182>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
8000363e:	fe b0 fb c3 	rcall	80002dc4 <sd_mmc_spi_get_capacity>
80003642:	e0 68 06 3c 	mov	r8,1596

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
80003646:	e0 69 06 40 	mov	r9,1600
8000364a:	70 0a       	ld.w	r10,r8[0x0]
8000364c:	30 18       	mov	r8,1
8000364e:	b2 88       	st.b	r9[0x0],r8
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
80003650:	e0 69 06 2c 	mov	r9,1580
80003654:	e0 68 1b 00 	mov	r8,6912
80003658:	ea 18 00 b7 	orh	r8,0xb7
8000365c:	12 9b       	mov	r11,r9
        return false;
  } while (r1);

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
    if_cond = sd_mmc_spi_check_hc();
8000365e:	93 18       	st.w	r9[0x4],r8
80003660:	fe 7c 28 00 	mov	r12,-55296
    if (if_cond == -1) {
80003664:	fe b0 f9 48 	rcall	800028f4 <spi_setupChipReg>
      return false;
    } else if (if_cond == 1){
80003668:	da 3a       	popm	r0-r7,pc,r12=1
          card_type = SD_CARD_2_SDHC;
8000366a:	c0 fe       	rcall	80003288 <sd_mmc_spi_check_hc>
8000366c:	5b fc       	cp.w	r12,-1
8000366e:	ca e0       	breq	800035ca <sd_mmc_spi_internal_init+0x17a>
80003670:	58 1c       	cp.w	r12,1
80003672:	c8 c1       	brne	8000358a <sd_mmc_spi_internal_init+0x13a>
80003674:	30 39       	mov	r9,3
80003676:	e0 68 2c 4e 	mov	r8,11342
8000367a:	b0 89       	st.b	r8[0x0],r9
8000367c:	c8 7b       	rjmp	8000358a <sd_mmc_spi_internal_init+0x13a>
8000367e:	d7 03       	nop

80003680 <sd_mmc_spi_mem_check>:
80003680:	d4 01       	pushm	lr
80003682:	fe b0 fd 01 	rcall	80003084 <sd_mmc_spi_check_presence>
80003686:	c0 a0       	breq	8000369a <sd_mmc_spi_mem_check+0x1a>
80003688:	e0 68 06 40 	mov	r8,1600
8000368c:	11 89       	ld.ub	r9,r8[0x0]
8000368e:	30 08       	mov	r8,0
80003690:	f0 09 18 00 	cp.b	r9,r8
80003694:	c0 20       	breq	80003698 <sd_mmc_spi_mem_check+0x18>
80003696:	da 0a       	popm	pc,r12=1
80003698:	cd ce       	rcall	80003450 <sd_mmc_spi_internal_init>
8000369a:	d8 02       	popm	pc

8000369c <sd_mmc_spi_init>:
8000369c:	eb cd 40 10 	pushm	r4,lr
800036a0:	e0 68 06 2c 	mov	r8,1580
800036a4:	fa c4 ff f8 	sub	r4,sp,-8
800036a8:	e8 ea 00 08 	ld.d	r10,r4[8]
800036ac:	f0 eb 00 08 	st.d	r8[8],r10
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
800036b0:	e0 69 06 3c 	mov	r9,1596
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
800036b4:	93 0c       	st.w	r9[0x0],r12
800036b6:	e8 ea 00 00 	ld.d	r10,r4[0]

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
800036ba:	f0 eb 00 00 	st.d	r8[0],r10
}
800036be:	cc 9e       	rcall	80003450 <sd_mmc_spi_internal_init>
800036c0:	e3 cd 80 10 	ldm	sp++,r4,pc

800036c4 <uhd_get_speed>:
	cpu_irq_restore(flags);
}

uhd_speed_t uhd_get_speed(void)
{
	switch (uhd_get_speed_mode()) {
800036c4:	fe 68 08 04 	mov	r8,-129020
800036c8:	70 08       	ld.w	r8,r8[0x0]
800036ca:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
800036ce:	58 38       	cp.w	r8,3
800036d0:	c0 60       	breq	800036dc <uhd_get_speed+0x18>
800036d2:	fe c9 86 ca 	sub	r9,pc,-31030
800036d6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
800036da:	5e fc       	retal	r12
800036dc:	5e fd       	retal	0
800036de:	d7 03       	nop

800036e0 <uhd_send_reset>:
	return uhd_get_microsof_number();
}

void uhd_send_reset(uhd_callback_reset_t callback)
{
	uhd_reset_callback = callback;
800036e0:	e0 69 06 44 	mov	r9,1604
	uhd_start_reset();
800036e4:	93 0c       	st.w	r9[0x0],r12
800036e6:	fe 68 04 00 	mov	r8,-130048
800036ea:	70 09       	ld.w	r9,r8[0x0]
800036ec:	a9 b9       	sbr	r9,0x9
}
800036ee:	91 09       	st.w	r8[0x0],r9
800036f0:	5e fc       	retal	r12
800036f2:	d7 03       	nop

800036f4 <uhd_suspend>:

void uhd_suspend(void)
{
800036f4:	d4 01       	pushm	lr
	if (uhd_ctrl_request_timeout) {
800036f6:	e0 68 2c 74 	mov	r8,11380
800036fa:	90 08       	ld.sh	r8,r8[0x0]
800036fc:	58 08       	cp.w	r8,0
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
		return;
800036fe:	c1 d1       	brne	80003738 <uhd_suspend+0x44>
80003700:	fe 69 05 c4 	mov	r9,-129596
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
		uhd_freeze_pipe(pipe);
80003704:	10 9b       	mov	r11,r8
80003706:	e2 6e 00 00 	mov	lr,131072
8000370a:	72 0a       	ld.w	r10,r9[0x0]
{
	uhd_reset_callback = callback;
	uhd_start_reset();
}

void uhd_suspend(void)
8000370c:	93 ce       	st.w	r9[0x30],lr
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
8000370e:	2f f8       	sub	r8,-1
80003710:	ee 1a 00 02 	eorh	r10,0x2
80003714:	2f c9       	sub	r9,-4
80003716:	f5 da c2 21 	bfextu	r10,r10,0x11,0x1
8000371a:	f4 08 09 4a 	lsl	r10,r10,r8
8000371e:	f5 eb 10 0b 	or	r11,r10,r11
		uhd_b_suspend_requested = true;
		return;
	}
	// Save pipe freeze states and freeze pipes
	uhd_pipes_unfreeze = 0;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80003722:	5c 5b       	castu.b	r11
80003724:	58 68       	cp.w	r8,6
80003726:	cf 21       	brne	8000370a <uhd_suspend+0x16>
80003728:	e0 68 06 c1 	mov	r8,1729
		uhd_pipes_unfreeze |= (!Is_uhd_pipe_frozen(pipe)) << pipe;
		uhd_freeze_pipe(pipe);
	}
	// Wait three SOFs before entering in suspend state
	uhd_suspend_start = 3;
8000372c:	b0 8b       	st.b	r8[0x0],r11
8000372e:	30 39       	mov	r9,3
80003730:	e0 68 06 c0 	mov	r8,1728

void uhd_suspend(void)
{
	if (uhd_ctrl_request_timeout) {
		// Delay suspend after setup requests
		uhd_b_suspend_requested = true;
80003734:	b0 89       	st.b	r8[0x0],r9
80003736:	d8 02       	popm	pc
		return;
80003738:	30 19       	mov	r9,1
8000373a:	e0 68 06 c3 	mov	r8,1731
8000373e:	b0 89       	st.b	r8[0x0],r9
80003740:	d8 02       	popm	pc
80003742:	d7 03       	nop

80003744 <uhd_ctrl_phase_data_out>:
80003744:	eb cd 40 f8 	pushm	r3-r7,lr
80003748:	e0 65 2c 64 	mov	r5,11364
static void uhd_ctrl_phase_data_out(void)
{
	uint8_t *ptr_ep_data;
	uint8_t ep_ctrl_size;

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
8000374c:	30 18       	mov	r8,1

	if (uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength) {
8000374e:	8b 08       	st.w	r5[0x0],r8
80003750:	e0 66 2c 68 	mov	r6,11368
80003754:	e0 67 2c 6c 	mov	r7,11372
80003758:	6c 0a       	ld.w	r10,r6[0x0]
8000375a:	8e 09       	ld.sh	r9,r7[0x0]
8000375c:	15 fc       	ld.ub	r12,r10[0x7]
8000375e:	f5 3b 00 08 	ld.ub	r11,r10[8]
80003762:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
80003766:	5c 8b       	casts.h	r11
80003768:	f2 0b 19 00 	cp.h	r11,r9
		// End of DATA phase
		uhd_ctrl_phase_zlp_in();
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
8000376c:	e0 80 00 97 	breq	8000389a <uhd_ctrl_phase_data_out+0x156>
80003770:	f5 0c 00 10 	ld.sh	r12,r10[16]
80003774:	30 08       	mov	r8,0
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80003776:	f0 0c 19 00 	cp.h	r12,r8
8000377a:	c5 d0       	breq	80003834 <uhd_ctrl_phase_data_out+0xf0>
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
8000377c:	fe 6c 05 00 	mov	r12,-129792
80003780:	78 0e       	ld.w	lr,r12[0x0]
80003782:	78 08       	ld.w	r8,r12[0x0]
80003784:	e0 18 fc ff 	andl	r8,0xfcff
	uhd_ack_out_ready(0);
80003788:	a9 b8       	sbr	r8,0x9
8000378a:	99 08       	st.w	r12[0x0],r8
8000378c:	fe 68 05 60 	mov	r8,-129696
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
80003790:	30 2c       	mov	r12,2
80003792:	91 0c       	st.w	r8[0x0],r12
80003794:	30 88       	mov	r8,8
	}

#ifdef USB_HOST_HUB_SUPPORT
	// TODO
#else
	ep_ctrl_size = uhd_get_pipe_size(0);
80003796:	f2 0b 19 00 	cp.h	r11,r9
8000379a:	5f bb       	srhi	r11
8000379c:	fd de c0 83 	bfextu	lr,lr,0x4,0x3
800037a0:	f0 0e 09 4e 	lsl	lr,r8,lr

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800037a4:	30 08       	mov	r8,0
800037a6:	5c 5e       	castu.b	lr
800037a8:	f0 0e 18 00 	cp.b	lr,r8
800037ac:	5f 19       	srne	r9
800037ae:	f7 e9 00 09 	and	r9,r11,r9
			&& ep_ctrl_size && uhd_ctrl_request_first->payload_size) {
800037b2:	f0 09 18 00 	cp.b	r9,r8
800037b6:	c3 10       	breq	80003818 <uhd_ctrl_phase_data_out+0xd4>
800037b8:	f5 08 00 10 	ld.sh	r8,r10[16]
800037bc:	30 0b       	mov	r11,0
800037be:	f6 08 19 00 	cp.h	r8,r11
800037c2:	c2 b0       	breq	80003818 <uhd_ctrl_phase_data_out+0xd4>
800037c4:	16 94       	mov	r4,r11
800037c6:	fc 19 e0 00 	movh	r9,0xe000
800037ca:	c0 68       	rjmp	800037d6 <uhd_ctrl_phase_data_out+0x92>
800037cc:	f5 08 00 10 	ld.sh	r8,r10[16]
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
800037d0:	e8 08 19 00 	cp.h	r8,r4
800037d4:	c2 20       	breq	80003818 <uhd_ctrl_phase_data_out+0xd4>
800037d6:	74 38       	ld.w	r8,r10[0xc]
		uhd_ctrl_nb_trans++;
800037d8:	11 3c       	ld.ub	r12,r8++
800037da:	12 cc       	st.b	r9++,r12
800037dc:	95 38       	st.w	r10[0xc],r8
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
800037de:	8e 08       	ld.sh	r8,r7[0x0]
800037e0:	2f f8       	sub	r8,-1
800037e2:	ae 08       	st.h	r7[0x0],r8
800037e4:	6c 08       	ld.w	r8,r6[0x0]
800037e6:	f1 0a 00 10 	ld.sh	r10,r8[16]

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
	while ((uhd_ctrl_nb_trans < uhd_ctrl_request_first->req.wLength)
800037ea:	20 1a       	sub	r10,1
800037ec:	f1 5a 00 10 	st.h	r8[16],r10
800037f0:	fc 09 01 08 	sub	r8,lr,r9
800037f4:	6c 0a       	ld.w	r10,r6[0x0]
800037f6:	f6 08 18 00 	cp.b	r8,r11
800037fa:	5f 1c       	srne	r12
800037fc:	8e 05       	ld.sh	r5,r7[0x0]
800037fe:	15 f3       	ld.ub	r3,r10[0x7]
80003800:	f5 38 00 08 	ld.ub	r8,r10[8]
80003804:	f1 e3 10 88 	or	r8,r8,r3<<0x8
80003808:	f0 05 19 00 	cp.h	r5,r8
8000380c:	5f 38       	srlo	r8
8000380e:	f9 e8 00 08 	and	r8,r12,r8
		*ptr_ep_data++ = *uhd_ctrl_request_first->payload++;
		uhd_ctrl_nb_trans++;
		ep_ctrl_size--;
		uhd_ctrl_request_first->payload_size--;
	}
	uhd_enable_out_ready_interrupt(0);
80003812:	f6 08 18 00 	cp.b	r8,r11
80003816:	cd b1       	brne	800037cc <uhd_ctrl_phase_data_out+0x88>
80003818:	30 29       	mov	r9,2
	uhd_ack_fifocon(0);
8000381a:	fe 68 05 f0 	mov	r8,-129552
8000381e:	91 09       	st.w	r8[0x0],r9
80003820:	fe 68 06 20 	mov	r8,-129504
	uhd_unfreeze_pipe(0);
80003824:	e0 69 40 00 	mov	r9,16384
80003828:	91 09       	st.w	r8[0x0],r9
8000382a:	e2 69 00 00 	mov	r9,131072
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
				|| !uhd_ctrl_request_first->callback_run(
8000382e:	91 09       	st.w	r8[0x0],r9
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80003830:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
80003834:	74 58       	ld.w	r8,r10[0x14]
80003836:	58 08       	cp.w	r8,0
		return;
	}

	if (!uhd_ctrl_request_first->payload_size) {
		// Buffer empty, then request a new buffer
		if (uhd_ctrl_request_first->callback_run==NULL
80003838:	c1 40       	breq	80003860 <uhd_ctrl_phase_data_out+0x11c>
8000383a:	fe 69 04 24 	mov	r9,-130012
8000383e:	f4 cb ff f4 	sub	r11,r10,-12
80003842:	72 0c       	ld.w	r12,r9[0x0]
80003844:	2f 0a       	sub	r10,-16
80003846:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000384a:	5d 18       	icall	r8
8000384c:	c0 a0       	breq	80003860 <uhd_ctrl_phase_data_out+0x11c>
8000384e:	6c 0a       	ld.w	r10,r6[0x0]
80003850:	8e 09       	ld.sh	r9,r7[0x0]
80003852:	15 fb       	ld.ub	r11,r10[0x7]
80003854:	f5 38 00 08 	ld.ub	r8,r10[8]
80003858:	f1 eb 10 8b 	or	r11,r8,r11<<0x8
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
8000385c:	5c 8b       	casts.h	r11
8000385e:	c8 fb       	rjmp	8000377c <uhd_ctrl_phase_data_out+0x38>
80003860:	fe 69 05 00 	mov	r9,-129792
80003864:	72 08       	ld.w	r8,r9[0x0]
80003866:	e0 18 fc ff 	andl	r8,0xfcff
	uhd_ack_in_received(0);
8000386a:	a9 a8       	sbr	r8,0x8
8000386c:	93 08       	st.w	r9[0x0],r8
8000386e:	fe 69 05 60 	mov	r9,-129696
	uhd_ack_short_packet(0);
80003872:	30 18       	mov	r8,1
80003874:	93 08       	st.w	r9[0x0],r8
	uhd_enable_in_received_interrupt(0);
80003876:	e0 6a 00 80 	mov	r10,128
8000387a:	93 0a       	st.w	r9[0x0],r10
	uhd_ack_fifocon(0);
8000387c:	fe 69 05 f0 	mov	r9,-129552
80003880:	93 08       	st.w	r9[0x0],r8
80003882:	fe 68 06 20 	mov	r8,-129504
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80003886:	e0 69 40 00 	mov	r9,16384
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
	uhd_ack_in_received(0);
	uhd_ack_short_packet(0);
	uhd_enable_in_received_interrupt(0);
	uhd_ack_fifocon(0);
	uhd_unfreeze_pipe(0);
8000388a:	91 09       	st.w	r8[0x0],r9
8000388c:	30 39       	mov	r9,3
8000388e:	8b 09       	st.w	r5[0x0],r9
				uhd_get_configured_address(0),
				&uhd_ctrl_request_first->payload,
				&uhd_ctrl_request_first->payload_size)) {
			// DATA phase aborted by host
			uhd_ctrl_phase_zlp_in();
			return;
80003890:	e2 69 00 00 	mov	r9,131072
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80003894:	91 09       	st.w	r8[0x0],r9
80003896:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000389a:	fe 6a 05 00 	mov	r10,-129792
8000389e:	74 09       	ld.w	r9,r10[0x0]
800038a0:	e0 19 fc ff 	andl	r9,0xfcff
	uhd_ack_in_received(0);
800038a4:	a9 a9       	sbr	r9,0x8
800038a6:	95 09       	st.w	r10[0x0],r9
800038a8:	fe 69 05 60 	mov	r9,-129696
800038ac:	ce 4b       	rjmp	80003874 <uhd_ctrl_phase_data_out+0x130>
800038ae:	d7 03       	nop

800038b0 <uhd_get_pipe>:
800038b0:	eb cd 40 fe 	pushm	r1-r7,lr
 * \param endp  Endpoint number
 *
 * \return Pipe number
 */
static uint8_t uhd_get_pipe(usb_add_t add, usb_ep_t endp)
{
800038b4:	fe 6e 05 00 	mov	lr,-129792
800038b8:	18 98       	mov	r8,r12
800038ba:	30 09       	mov	r9,0
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800038bc:	fe 63 00 00 	mov	r3,-131072
800038c0:	30 14       	mov	r4,1
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800038c2:	37 f2       	mov	r2,127
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
800038c4:	e0 61 00 80 	mov	r1,128
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800038c8:	e6 f7 04 1c 	ld.w	r7,r3[1052]
 * \param endp  Endpoint number
 *
 * \return Pipe number
 */
static uint8_t uhd_get_pipe(usb_add_t add, usb_ep_t endp)
{
800038cc:	f9 d9 c0 08 	bfextu	r12,r9,0x0,0x8
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800038d0:	e8 09 09 46 	lsl	r6,r4,r9
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800038d4:	18 9a       	mov	r10,r12
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
800038d6:	f8 c5 ff ff 	sub	r5,r12,-1
	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800038da:	e2 1a 00 fc 	andl	r10,0xfc,COH
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800038de:	ed e7 00 07 	and	r7,r6,r7
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800038e2:	e0 3a fb dc 	sub	r10,130012
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
800038e6:	58 07       	cp.w	r7,0
800038e8:	c0 f0       	breq	80003906 <uhd_get_pipe+0x56>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
800038ea:	74 07       	ld.w	r7,r10[0x0]
800038ec:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
800038f0:	a3 7a       	lsl	r10,0x3
800038f2:	e4 0a 09 4a 	lsl	r10,r2,r10
800038f6:	14 67       	and	r7,r10
800038f8:	5c 9a       	brev	r10
800038fa:	f4 0a 12 00 	clz	r10,r10
800038fe:	ee 0a 0a 4a 	lsr	r10,r7,r10
80003902:	14 38       	cp.w	r8,r10
80003904:	c0 90       	breq	80003916 <uhd_get_pipe+0x66>
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80003906:	f9 d5 c0 08 	bfextu	r12,r5,0x0,0x8
8000390a:	2f f9       	sub	r9,-1
8000390c:	2f ce       	sub	lr,-4
static uint8_t uhd_get_pipe(usb_add_t add, usb_ep_t endp)
{
	uint8_t pipe;

	// Search pipe
	for (pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
8000390e:	58 79       	cp.w	r9,7
80003910:	cd c1       	brne	800038c8 <uhd_get_pipe+0x18>
			continue;
		}
		break;
	}
	return pipe;
}
80003912:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80003916:	7c 07       	ld.w	r7,lr[0x0]
80003918:	7c 0a       	ld.w	r10,lr[0x0]
8000391a:	ef d7 c2 04 	bfextu	r7,r7,0x10,0x4
8000391e:	f5 da c1 02 	bfextu	r10,r10,0x8,0x2
80003922:	58 1a       	cp.w	r10,1
80003924:	e2 0a 17 00 	moveq	r10,r1
80003928:	f9 ba 01 00 	movne	r10,0
8000392c:	0e 4a       	or	r10,r7
8000392e:	14 3b       	cp.w	r11,r10
80003930:	ce b1       	brne	80003906 <uhd_get_pipe+0x56>
			continue;
		}
		break;
	}
	return pipe;
}
80003932:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80003936:	d7 03       	nop

80003938 <uhd_pipe_finish_job>:
 *
 * \param pipe   Pipe number
 * \param status Status of the transfer
 */
static void uhd_pipe_finish_job(uint8_t pipe, uhd_trans_status_t status)
{
80003938:	eb cd 40 c0 	pushm	r6-r7,lr
	uhd_pipe_job_t *ptr_job;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
8000393c:	e0 68 06 48 	mov	r8,1608
80003940:	f8 c9 00 01 	sub	r9,r12,1
80003944:	f2 09 00 29 	add	r9,r9,r9<<0x2
80003948:	f0 09 00 29 	add	r9,r8,r9<<0x2
	if (ptr_job->busy == false) {
8000394c:	72 08       	ld.w	r8,r9[0x0]
8000394e:	58 08       	cp.w	r8,0
		return; // No job running
	}
	ptr_job->busy = false;
80003950:	c3 04       	brge	800039b0 <uhd_pipe_finish_job+0x78>
80003952:	30 0a       	mov	r10,0
80003954:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
	if (NULL == ptr_job->call_end) {
80003958:	93 08       	st.w	r9[0x0],r8
8000395a:	72 48       	ld.w	r8,r9[0x10]
8000395c:	58 08       	cp.w	r8,0
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
8000395e:	c2 90       	breq	800039b0 <uhd_pipe_finish_job+0x78>
80003960:	f8 0e 15 02 	lsl	lr,r12,0x2
80003964:	e0 3e fb 00 	sub	lr,129792
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_end) {
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
80003968:	ef dc c0 02 	bfextu	r7,r12,0x0,0x2
8000396c:	7c 06       	ld.w	r6,lr[0x0]
8000396e:	16 9a       	mov	r10,r11
80003970:	e2 1c 03 fc 	andl	r12,0x3fc,COH
80003974:	7c 0b       	ld.w	r11,lr[0x0]
80003976:	e0 3c fb dc 	sub	r12,130012
8000397a:	fd d6 c2 04 	bfextu	lr,r6,0x10,0x4
8000397e:	a3 77       	lsl	r7,0x3
80003980:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80003984:	e0 66 00 80 	mov	r6,128
80003988:	58 1b       	cp.w	r11,1
8000398a:	ec 0b 17 00 	moveq	r11,r6
8000398e:	f9 bb 01 00 	movne	r11,0
80003992:	1c 4b       	or	r11,lr
80003994:	78 0e       	ld.w	lr,r12[0x0]
80003996:	37 fc       	mov	r12,127
80003998:	f8 07 09 4c 	lsl	r12,r12,r7
8000399c:	f9 ee 00 0e 	and	lr,r12,lr
800039a0:	72 39       	ld.w	r9,r9[0xc]
800039a2:	5c 9c       	brev	r12
800039a4:	f8 0c 12 00 	clz	r12,r12
800039a8:	fc 0c 0a 4c 	lsr	r12,lr,r12
800039ac:	5c 5c       	castu.b	r12
800039ae:	5d 18       	icall	r8
800039b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800039b4 <uhd_ep_abort_pipe>:
800039b4:	d4 01       	pushm	lr
800039b6:	fe 68 00 00 	mov	r8,-131072
 * \param status Reason of abort
 */
static void uhd_ep_abort_pipe(uint8_t pipe, uhd_trans_status_t status)
{
	// Stop transfer
	uhd_reset_pipe(pipe);
800039ba:	e0 7a 00 00 	mov	r10,65536
800039be:	f0 fe 04 1c 	ld.w	lr,r8[1052]
800039c2:	f4 0c 09 4a 	lsl	r10,r10,r12
800039c6:	f5 ee 10 0e 	or	lr,r10,lr
800039ca:	5c da       	com	r10
800039cc:	f1 4e 04 1c 	st.w	r8[1052],lr
800039d0:	f0 fe 04 1c 	ld.w	lr,r8[1052]
800039d4:	1c 6a       	and	r10,lr
800039d6:	f1 4a 04 1c 	st.w	r8[1052],r10

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
800039da:	f8 08 15 02 	lsl	r8,r12,0x2
800039de:	fe 6a 05 00 	mov	r10,-129792
800039e2:	f0 0a 00 0e 	add	lr,r8,r10
800039e6:	7c 0a       	ld.w	r10,lr[0x0]
800039e8:	ab aa       	sbr	r10,0xa
800039ea:	9d 0a       	st.w	lr[0x0],r10
	uhd_enable_stall_interrupt(pipe);
800039ec:	fe 6e 05 f0 	mov	lr,-129552
800039f0:	f0 0e 00 0a 	add	r10,r8,lr
800039f4:	34 0e       	mov	lr,64
800039f6:	95 0e       	st.w	r10[0x0],lr
	uhd_enable_pipe_error_interrupt(pipe);

	uhd_disable_out_ready_interrupt(pipe);
800039f8:	e0 38 f9 e0 	sub	r8,129504
	uhd_reset_pipe(pipe);

	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
	uhd_enable_stall_interrupt(pipe);
	uhd_enable_pipe_error_interrupt(pipe);
800039fc:	30 8e       	mov	lr,8
800039fe:	95 0e       	st.w	r10[0x0],lr

	uhd_disable_out_ready_interrupt(pipe);
	uhd_pipe_dma_set_control(pipe, 0);
80003a00:	30 09       	mov	r9,0
	// Autoswitch bank and interrupts has been reseted, then re-enable it
	uhd_enable_pipe_bank_autoswitch(pipe);
	uhd_enable_stall_interrupt(pipe);
	uhd_enable_pipe_error_interrupt(pipe);

	uhd_disable_out_ready_interrupt(pipe);
80003a02:	30 2a       	mov	r10,2
80003a04:	91 0a       	st.w	r8[0x0],r10
	uhd_pipe_dma_set_control(pipe, 0);
80003a06:	f8 08 15 04 	lsl	r8,r12,0x4
80003a0a:	e0 38 f9 00 	sub	r8,129280
80003a0e:	91 29       	st.w	r8[0x8],r9
	uhd_pipe_finish_job(pipe, status);
80003a10:	c9 4f       	rcall	80003938 <uhd_pipe_finish_job>
80003a12:	d8 02       	popm	pc

80003a14 <uhd_pipe_trans_complet>:
}
80003a14:	eb cd 40 f8 	pushm	r3-r7,lr
80003a18:	e0 69 06 48 	mov	r9,1608
	iram_size_t max_trans;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &uhd_pipe_job[pipe - 1];
80003a1c:	f8 c8 00 01 	sub	r8,r12,1
80003a20:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003a24:	f2 08 00 28 	add	r8,r9,r8<<0x2

	if (!ptr_job->busy) {
80003a28:	70 0b       	ld.w	r11,r8[0x0]
80003a2a:	58 0b       	cp.w	r11,0
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
80003a2c:	c5 f4       	brge	80003aea <uhd_pipe_trans_complet+0xd6>
80003a2e:	70 3a       	ld.w	r10,r8[0xc]
80003a30:	70 26       	ld.w	r6,r8[0x8]
80003a32:	0c 3a       	cp.w	r10,r6
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
80003a34:	c5 d0       	breq	80003aee <uhd_pipe_trans_complet+0xda>
80003a36:	fe 67 05 00 	mov	r7,-129792
80003a3a:	f8 0e 15 02 	lsl	lr,r12,0x2
80003a3e:	fc 07 00 09 	add	r9,lr,r7
80003a42:	72 07       	ld.w	r7,r9[0x0]
80003a44:	ef d7 c1 02 	bfextu	r7,r7,0x8,0x2
80003a48:	58 17       	cp.w	r7,1
80003a4a:	e0 80 00 97 	breq	80003b78 <uhd_pipe_trans_complet+0x164>
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
				 max_trans = 256L * uhd_get_pipe_size(pipe);
80003a4e:	e0 77 00 00 	mov	r7,65536
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
80003a52:	14 16       	sub	r6,r10
80003a54:	0c 37       	cp.w	r7,r6
80003a56:	ec 07 17 b0 	movhi	r7,r6
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
80003a5a:	e0 57 00 00 	cp.w	r7,65536
80003a5e:	e0 80 00 b1 	breq	80003bc0 <uhd_pipe_trans_complet+0x1ac>
			// Set 0 to transfer the maximum
			uhd_dma_ctrl = (0 <<
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		} else {
			uhd_dma_ctrl = (next_trans <<
80003a62:	ee 06 15 10 	lsl	r6,r7,0x10
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
80003a66:	72 05       	ld.w	r5,r9[0x0]
80003a68:	eb d5 c1 02 	bfextu	r5,r5,0x8,0x2
80003a6c:	58 25       	cp.w	r5,2
80003a6e:	e0 80 00 98 	breq	80003b9e <uhd_pipe_trans_complet+0x18a>
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
80003a72:	72 0b       	ld.w	r11,r9[0x0]
80003a74:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
80003a78:	58 1b       	cp.w	r11,1
80003a7a:	e0 80 00 a5 	breq	80003bc4 <uhd_pipe_trans_complet+0x1b0>
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
				// Enable short packet reception
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOT_IRQ_EN_MASK
80003a7e:	e8 16 00 14 	orl	r6,0x14
						| AVR32_USBB_UHDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
80003a82:	70 1b       	ld.w	r11,r8[0x4]
80003a84:	14 0b       	add	r11,r10
80003a86:	f8 0a 15 04 	lsl	r10,r12,0x4
80003a8a:	e0 3a f9 00 	sub	r10,129280

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003a8e:	95 1b       	st.w	r10[0x4],r11
80003a90:	e1 b5 00 00 	mfsr	r5,0x0
				AVR32_USBB_UHDMA1_CONTROL_CH_EN_MASK;

		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
80003a94:	d3 03       	ssrf	0x10
80003a96:	74 3b       	ld.w	r11,r10[0xc]
80003a98:	ed bb 00 04 	bld	r11,0x4
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
80003a9c:	c1 a0       	breq	80003ad0 <uhd_pipe_trans_complet+0xbc>
80003a9e:	72 0b       	ld.w	r11,r9[0x0]
80003aa0:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80003aa4:	58 1b       	cp.w	r11,1
				uhd_in_request_number(pipe,
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
80003aa6:	c4 d0       	breq	80003b40 <uhd_pipe_trans_complet+0x12c>
80003aa8:	e0 3e f9 e0 	sub	lr,129504
80003aac:	e0 69 10 00 	mov	r9,4096
			uhd_unfreeze_pipe(pipe);
80003ab0:	9d 09       	st.w	lr[0x0],r9
80003ab2:	e2 69 00 00 	mov	r9,131072
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		uhd_pipe_dma_set_addr(pipe, (U32) &ptr_job->buf[ptr_job->nb_trans]);
		uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80003ab6:	9d 09       	st.w	lr[0x0],r9
80003ab8:	e8 16 00 21 	orl	r6,0x21
						(next_trans+uhd_get_pipe_size(pipe)-1)/uhd_get_pipe_size(pipe));
			}
			uhd_disable_bank_interrupt(pipe);
			uhd_unfreeze_pipe(pipe);
			uhd_pipe_dma_set_control(pipe, uhd_dma_ctrl);
			ptr_job->nb_trans += next_trans;
80003abc:	95 26       	st.w	r10[0x8],r6
80003abe:	70 39       	ld.w	r9,r8[0xc]
80003ac0:	f2 07 00 07 	add	r7,r9,r7
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003ac4:	91 37       	st.w	r8[0xc],r7
80003ac6:	e6 15 00 01 	andh	r5,0x1,COH
			cpu_irq_restore(flags);
			return;
80003aca:	c3 90       	breq	80003b3c <uhd_pipe_trans_complet+0x128>
80003acc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003ad0:	e6 15 00 01 	andh	r5,0x1,COH
      cpu_irq_enable();
80003ad4:	c0 21       	brne	80003ad8 <uhd_pipe_trans_complet+0xc4>
		}
		cpu_irq_restore(flags);
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
80003ad6:	d5 03       	csrf	0x10
80003ad8:	70 3a       	ld.w	r10,r8[0xc]
	}
	if (uhd_is_pipe_out(pipe)) {
80003ada:	91 2a       	st.w	r8[0x8],r10
80003adc:	72 09       	ld.w	r9,r9[0x0]
80003ade:	f3 d9 c1 02 	bfextu	r9,r9,0x8,0x2
80003ae2:	58 29       	cp.w	r9,2
			uhd_enable_out_ready_interrupt(pipe);
			return;
		}
	}
	// Call callback to signal end of transfer
	uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
80003ae4:	c1 00       	breq	80003b04 <uhd_pipe_trans_complet+0xf0>
80003ae6:	30 0b       	mov	r11,0
80003ae8:	c2 8f       	rcall	80003938 <uhd_pipe_finish_job>
80003aea:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
80003aee:	f8 0e 15 02 	lsl	lr,r12,0x2
80003af2:	fe 6b 05 00 	mov	r11,-129792
80003af6:	fc 0b 00 09 	add	r9,lr,r11
		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}
	if (uhd_is_pipe_out(pipe)) {
80003afa:	72 09       	ld.w	r9,r9[0x0]
80003afc:	f3 d9 c1 02 	bfextu	r9,r9,0x8,0x2
80003b00:	58 29       	cp.w	r9,2
80003b02:	cf 21       	brne	80003ae6 <uhd_pipe_trans_complet+0xd2>
		if (ptr_job->b_shortpacket) {
80003b04:	70 08       	ld.w	r8,r8[0x0]
80003b06:	ed b8 00 1e 	bld	r8,0x1e
80003b0a:	ce e1       	brne	80003ae6 <uhd_pipe_trans_complet+0xd2>
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			uhd_ack_out_ready(pipe);
80003b0c:	fe 6a 05 60 	mov	r10,-129696
80003b10:	fc 0a 00 08 	add	r8,lr,r10
80003b14:	91 09       	st.w	r8[0x0],r9
			if (Is_uhd_write_enabled(pipe)) {
80003b16:	fe 67 05 30 	mov	r7,-129744
80003b1a:	fc 07 00 08 	add	r8,lr,r7
80003b1e:	70 08       	ld.w	r8,r8[0x0]
80003b20:	ed b8 00 10 	bld	r8,0x10
80003b24:	c0 61       	brne	80003b30 <uhd_pipe_trans_complet+0x11c>
				// Force interrupt in case of pipe already free
				uhd_raise_out_ready(pipe);
80003b26:	fe 6b 05 90 	mov	r11,-129648
80003b2a:	fc 0b 00 08 	add	r8,lr,r11
80003b2e:	91 09       	st.w	r8[0x0],r9
			}
			uhd_enable_out_ready_interrupt(pipe);
80003b30:	e0 3e fa 10 	sub	lr,129552
80003b34:	30 28       	mov	r8,2
80003b36:	9d 08       	st.w	lr[0x0],r8
			return;
80003b38:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003b3c:	d5 03       	csrf	0x10
80003b3e:	cc 7b       	rjmp	80003acc <uhd_pipe_trans_complet+0xb8>
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if( !(uhd_pipe_dma_get_status(pipe)
				& AVR32_USBB_UHDMA1_STATUS_EOT_STA_MASK)) {
			if (uhd_is_pipe_in(pipe)) {
				uhd_in_request_number(pipe,
80003b40:	fe 6b 06 50 	mov	r11,-129456
80003b44:	fc 0b 00 0c 	add	r12,lr,r11
80003b48:	78 0b       	ld.w	r11,r12[0x0]
80003b4a:	72 03       	ld.w	r3,r9[0x0]
80003b4c:	e0 1b ff 00 	andl	r11,0xff00
80003b50:	72 04       	ld.w	r4,r9[0x0]
80003b52:	f3 d3 c0 83 	bfextu	r9,r3,0x4,0x3
80003b56:	e9 d4 c0 83 	bfextu	r4,r4,0x4,0x3
80003b5a:	30 83       	mov	r3,8
80003b5c:	2f d4       	sub	r4,-3
80003b5e:	e6 09 09 49 	lsl	r9,r3,r9
80003b62:	20 19       	sub	r9,1
80003b64:	0e 09       	add	r9,r7
80003b66:	f2 04 0a 49 	lsr	r9,r9,r4
80003b6a:	20 19       	sub	r9,1
80003b6c:	f3 d9 c0 08 	bfextu	r9,r9,0x0,0x8
80003b70:	f3 eb 10 0b 	or	r11,r9,r11
80003b74:	99 0b       	st.w	r12[0x0],r11
80003b76:	c9 9b       	rjmp	80003aa8 <uhd_pipe_trans_complet+0x94>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
		max_trans = UHD_PIPE_MAX_TRANS;
		if (uhd_is_pipe_in(pipe)) {
			// 256 is the maximum of IN requests via UPINRQ
			if ((256L*uhd_get_pipe_size(pipe))<UHD_PIPE_MAX_TRANS) {
80003b78:	72 05       	ld.w	r5,r9[0x0]
80003b7a:	30 87       	mov	r7,8
80003b7c:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80003b80:	ee 05 09 45 	lsl	r5,r7,r5
80003b84:	ea 07 09 45 	lsl	r5,r5,r7
80003b88:	e0 45 ff ff 	cp.w	r5,65535
80003b8c:	fe 99 ff 61 	brgt	80003a4e <uhd_pipe_trans_complet+0x3a>
				 max_trans = 256L * uhd_get_pipe_size(pipe);
80003b90:	72 05       	ld.w	r5,r9[0x0]
80003b92:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80003b96:	ee 05 09 47 	lsl	r7,r7,r5
80003b9a:	a9 67       	lsl	r7,0x8
80003b9c:	c5 bb       	rjmp	80003a52 <uhd_pipe_trans_complet+0x3e>
					AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UHDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}

		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
80003b9e:	72 05       	ld.w	r5,r9[0x0]
80003ba0:	30 84       	mov	r4,8
80003ba2:	eb d5 c0 83 	bfextu	r5,r5,0x4,0x3
80003ba6:	e8 05 09 45 	lsl	r5,r4,r5
80003baa:	20 15       	sub	r5,1
80003bac:	ef e5 00 05 	and	r5,r7,r5
80003bb0:	fe 90 ff 69 	breq	80003a82 <uhd_pipe_trans_complet+0x6e>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
80003bb4:	30 05       	mov	r5,0
		if (uhd_is_pipe_out(pipe)) {
			if (0 != next_trans % uhd_get_pipe_size(pipe)) {
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
80003bb6:	08 46       	or	r6,r4
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
80003bb8:	f7 d5 d3 c1 	bfins	r11,r5,0x1e,0x1
80003bbc:	91 0b       	st.w	r8[0x0],r11
80003bbe:	c6 2b       	rjmp	80003a82 <uhd_pipe_trans_complet+0x6e>
			// The USB hardware supports a maximum
			// transfer size of UHD_PIPE_MAX_TRANS Bytes
			next_trans = max_trans;
		}

		if (next_trans == UHD_PIPE_MAX_TRANS) {
80003bc0:	30 06       	mov	r6,0
80003bc2:	c5 2b       	rjmp	80003a66 <uhd_pipe_trans_complet+0x52>
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
					|| (next_trans <= uhd_get_pipe_size(pipe))) {
80003bc4:	72 0b       	ld.w	r11,r9[0x0]
				uhd_dma_ctrl |= AVR32_USBB_UHDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != uhd_get_pipe_type(pipe))
80003bc6:	30 85       	mov	r5,8
80003bc8:	f7 db c0 83 	bfextu	r11,r11,0x4,0x3
80003bcc:	ea 0b 09 4b 	lsl	r11,r5,r11
80003bd0:	0e 3b       	cp.w	r11,r7
80003bd2:	fe 93 ff 58 	brlo	80003a82 <uhd_pipe_trans_complet+0x6e>
80003bd6:	c5 4b       	rjmp	80003a7e <uhd_pipe_trans_complet+0x6a>

80003bd8 <uhd_ep_run>:
80003bd8:	eb cd 40 f8 	pushm	r3-r7,lr
80003bdc:	fa c4 ff e8 	sub	r4,sp,-24
		bool b_shortpacket,
		uint8_t *buf,
		iram_size_t buf_size,
		uint16_t timeout,
		uhd_callback_trans_t callback)
{
80003be0:	10 95       	mov	r5,r8
80003be2:	68 13       	ld.w	r3,r4[0x4]
80003be4:	14 97       	mov	r7,r10
80003be6:	12 96       	mov	r6,r9
80003be8:	68 04       	ld.w	r4,r4[0x0]
	irqflags_t flags;
	uint8_t pipe;
	uhd_pipe_job_t *ptr_job;

	pipe = uhd_get_pipe(add,endp);
80003bea:	c6 3e       	rcall	800038b0 <uhd_get_pipe>
80003bec:	30 78       	mov	r8,7
	if (pipe == AVR32_USBB_EPT_NUM) {
80003bee:	f0 0c 18 00 	cp.b	r12,r8
80003bf2:	c2 a0       	breq	80003c46 <uhd_ep_run+0x6e>
80003bf4:	f8 c8 00 01 	sub	r8,r12,1
	  print_dbg("\r\n uhd error: pipe not found");
		return false; // pipe not found
	}

	// Get job about pipe
	ptr_job = &uhd_pipe_job[pipe-1];
80003bf8:	e0 69 06 48 	mov	r9,1608
80003bfc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80003c00:	f2 08 00 28 	add	r8,r9,r8<<0x2

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003c04:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
80003c08:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
80003c0a:	70 0a       	ld.w	r10,r8[0x0]
80003c0c:	14 99       	mov	r9,r10
80003c0e:	e6 19 80 00 	andh	r9,0x8000,COH
80003c12:	c0 70       	breq	80003c20 <uhd_ep_run+0x48>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003c14:	ed bb 00 10 	bld	r11,0x10
80003c18:	c0 20       	breq	80003c1c <uhd_ep_run+0x44>
      cpu_irq_enable();
80003c1a:	d5 03       	csrf	0x10
   }

	barrier();
80003c1c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
		cpu_irq_restore(flags);
		//		print_dbg("\r\n uhd error: job is already underway");
		return false; // Job already on going
	}
	ptr_job->busy = true;
80003c20:	30 1e       	mov	lr,1
80003c22:	f5 de d3 e1 	bfins	r10,lr,0x1f,0x1
80003c26:	91 0a       	st.w	r8[0x0],r10

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
80003c28:	b0 14       	st.h	r8[0x2],r4
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
80003c2a:	91 39       	st.w	r8[0xc],r9
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->call_end = callback;
80003c2c:	91 43       	st.w	r8[0x10],r3
	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80003c2e:	70 09       	ld.w	r9,r8[0x0]
		return false; // Job already on going
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
80003c30:	91 16       	st.w	r8[0x4],r6
	ptr_job->buf_size = buf_size;
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80003c32:	f3 d7 d3 c1 	bfins	r9,r7,0x1e,0x1
	}
	ptr_job->busy = true;

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
	ptr_job->buf_size = buf_size;
80003c36:	91 25       	st.w	r8[0x8],r5
	ptr_job->nb_trans = 0;
	ptr_job->timeout = timeout;
	ptr_job->b_shortpacket = b_shortpacket;
80003c38:	91 09       	st.w	r8[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003c3a:	ed bb 00 10 	bld	r11,0x10
80003c3e:	c0 a1       	brne	80003c52 <uhd_ep_run+0x7a>
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
80003c40:	ce ae       	rcall	80003a14 <uhd_pipe_trans_complet>
80003c42:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
80003c46:	fe cc 8c 26 	sub	r12,pc,-29658
	uint8_t pipe;
	uhd_pipe_job_t *ptr_job;

	pipe = uhd_get_pipe(add,endp);
	if (pipe == AVR32_USBB_EPT_NUM) {
	  print_dbg("\r\n uhd error: pipe not found");
80003c4a:	fe b0 f8 b7 	rcall	80002db8 <print_dbg>
80003c4e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
      cpu_irq_enable();
80003c52:	d5 03       	csrf	0x10
	ptr_job->b_shortpacket = b_shortpacket;
	ptr_job->call_end = callback;
	cpu_irq_restore(flags);

	// Request first transfer
	uhd_pipe_trans_complet(pipe);
80003c54:	ce 0e       	rcall	80003a14 <uhd_pipe_trans_complet>
80003c56:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
80003c5a:	d7 03       	nop

80003c5c <uhd_ctrl_request_end>:
80003c5c:	eb cd 40 e0 	pushm	r5-r7,lr
80003c60:	30 09       	mov	r9,0
80003c62:	e0 68 2c 74 	mov	r8,11380
80003c66:	18 95       	mov	r5,r12
80003c68:	b0 09       	st.h	r8[0x0],r9
80003c6a:	e0 69 2c 68 	mov	r9,11368
80003c6e:	72 0c       	ld.w	r12,r9[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003c70:	78 66       	ld.w	r6,r12[0x18]
	cpu_irq_disable();
80003c72:	e1 b8 00 00 	mfsr	r8,0x0

	// Remove request from the control request list
	callback_end = uhd_ctrl_request_first->callback_end;
	request_to_free = uhd_ctrl_request_first;
	flags = cpu_irq_save();
	uhd_ctrl_request_first = uhd_ctrl_request_first->next_request;
80003c76:	d3 03       	ssrf	0x10
80003c78:	72 0a       	ld.w	r10,r9[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003c7a:	74 77       	ld.w	r7,r10[0x1c]
80003c7c:	93 07       	st.w	r9[0x0],r7
80003c7e:	ed b8 00 10 	bld	r8,0x10
	b_new_request = (uhd_ctrl_request_first != NULL);
	cpu_irq_restore(flags);
	free(request_to_free);
80003c82:	c1 e1       	brne	80003cbe <uhd_ctrl_request_end+0x62>

	// Call callback
	if (callback_end != NULL) {
80003c84:	e0 a0 33 5e 	rcall	8000a340 <free>
		callback_end(uhd_get_configured_address(0), status, uhd_ctrl_nb_trans);
80003c88:	58 06       	cp.w	r6,0
80003c8a:	c0 b0       	breq	80003ca0 <uhd_ctrl_request_end+0x44>
80003c8c:	fe 68 04 24 	mov	r8,-130012
80003c90:	70 0c       	ld.w	r12,r8[0x0]
80003c92:	e0 68 2c 6c 	mov	r8,11372
80003c96:	0a 9b       	mov	r11,r5
80003c98:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
	}

	// If a setup request is pending and no started by previous callback
	if (b_new_request) {
80003c9c:	90 8a       	ld.uh	r10,r8[0x0]
		uhd_ctrl_phase_setup();
80003c9e:	5d 16       	icall	r6
80003ca0:	58 07       	cp.w	r7,0
	}
	if (uhd_b_suspend_requested) {
80003ca2:	c0 20       	breq	80003ca6 <uhd_ctrl_request_end+0x4a>
80003ca4:	c1 0c       	rcall	80003cc4 <uhd_ctrl_phase_setup>
80003ca6:	e0 68 06 c3 	mov	r8,1731
80003caa:	30 09       	mov	r9,0
80003cac:	11 8a       	ld.ub	r10,r8[0x0]
		// A suspend request has been delay after all setup request
		uhd_b_suspend_requested = false;
80003cae:	f2 0a 18 00 	cp.b	r10,r9
		uhd_suspend();
80003cb2:	c0 40       	breq	80003cba <uhd_ctrl_request_end+0x5e>
80003cb4:	b0 89       	st.b	r8[0x0],r9
80003cb6:	fe b0 fd 1f 	rcall	800036f4 <uhd_suspend>
      cpu_irq_enable();
80003cba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003cbe:	d5 03       	csrf	0x10
80003cc0:	ce 2b       	rjmp	80003c84 <uhd_ctrl_request_end+0x28>
80003cc2:	d7 03       	nop

80003cc4 <uhd_ctrl_phase_setup>:
80003cc4:	eb cd 40 c0 	pushm	r6-r7,lr
80003cc8:	20 2d       	sub	sp,8
80003cca:	e0 68 2c 64 	mov	r8,11364
80003cce:	30 07       	mov	r7,0
80003cd0:	30 8a       	mov	r10,8
80003cd2:	91 07       	st.w	r8[0x0],r7
80003cd4:	e0 66 2c 68 	mov	r6,11368
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80003cd8:	1a 9c       	mov	r12,sp
80003cda:	6c 0b       	ld.w	r11,r6[0x0]
80003cdc:	2f fb       	sub	r11,-1

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
	uhd_ctrl_nb_trans = 0;
80003cde:	e0 a0 35 53 	rcall	8000a784 <memcpy>
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80003ce2:	e0 68 2c 6c 	mov	r8,11372
	volatile uint64_t *ptr_ep_data;

	//	print_dbg("\r\n control request setup phase ");

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));
80003ce6:	b0 07       	st.h	r8[0x0],r7

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
80003ce8:	fe 68 00 00 	mov	r8,-131072
80003cec:	40 09       	lddsp	r9,sp[0x0]
80003cee:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80003cf2:	5c ca       	swap.bh	r10

	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
80003cf4:	5c 8a       	casts.h	r10
80003cf6:	f0 fb 04 1c 	ld.w	r11,r8[1052]
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
80003cfa:	f3 da d0 10 	bfins	r9,r10,0x0,0x10
80003cfe:	40 18       	lddsp	r8,sp[0x4]
80003d00:	f0 0a 14 10 	asr	r10,r8,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80003d04:	5c ca       	swap.bh	r10
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
80003d06:	5c 8a       	casts.h	r10
80003d08:	f7 db c0 01 	bfextu	r11,r11,0x0,0x1
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80003d0c:	f1 da d2 10 	bfins	r8,r10,0x10,0x10
80003d10:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
	}
#error TODO check address in list
	// Reconfigure USB address of pipe 0 used for all control endpoints
	uhd_configure_address(0, uhd_ctrl_request_first->add);
#else
	if (!Is_uhd_pipe_enabled(0) ||
80003d14:	5c ca       	swap.bh	r10
			(uhd_ctrl_request_first->add != uhd_get_configured_address(0))) {
80003d16:	5c 8a       	casts.h	r10
80003d18:	58 0b       	cp.w	r11,0
80003d1a:	c0 a0       	breq	80003d2e <uhd_ctrl_phase_setup+0x6a>
80003d1c:	fe 6b 04 24 	mov	r11,-130012
80003d20:	76 0b       	ld.w	r11,r11[0x0]
80003d22:	6c 0c       	ld.w	r12,r6[0x0]
80003d24:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
		uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
80003d28:	19 8c       	ld.ub	r12,r12[0x0]
80003d2a:	16 3c       	cp.w	r12,r11
80003d2c:	c0 60       	breq	80003d38 <uhd_ctrl_phase_setup+0x74>

	uhd_ctrl_request_timeout = 5000;
	uhd_enable_setup_ready_interrupt(0);
	uhd_ack_fifocon(0);
	uhd_unfreeze_pipe(0);
}
80003d2e:	30 1c       	mov	r12,1
80003d30:	c9 6f       	rcall	80003c5c <uhd_ctrl_request_end>
80003d32:	2f ed       	sub	sp,-8
		return; // Endpoint not valid
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
80003d34:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d38:	fe 6c 05 00 	mov	r12,-129792
80003d3c:	78 0b       	ld.w	r11,r12[0x0]
80003d3e:	e0 1b fc ff 	andl	r11,0xfcff
	memcpy( &setup.req, &uhd_ctrl_request_first->req, sizeof(usb_setup_req_t));

	// Manage LSB/MSB to fit with CPU usage
	setup.req.wValue = cpu_to_le16(setup.req.wValue);
	setup.req.wIndex = cpu_to_le16(setup.req.wIndex);
	setup.req.wLength = cpu_to_le16(setup.req.wLength);
80003d42:	99 0b       	st.w	r12[0x0],r11
	}
#endif

	// Fill pipe
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_SETUP);
	uhd_ack_setup_ready(0);
80003d44:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
80003d48:	30 4c       	mov	r12,4
80003d4a:	fe 6b 05 60 	mov	r11,-129696
	Assert(sizeof(setup) == sizeof(uint64_t));
	ptr_ep_data = (volatile uint64_t *)&uhd_get_pipe_fifo_access(0, 64);
	*ptr_ep_data = setup.value64;
80003d4e:	97 0c       	st.w	r11[0x0],r12
80003d50:	10 9a       	mov	r10,r8
80003d52:	12 9b       	mov	r11,r9
80003d54:	fc 18 e0 00 	movh	r8,0xe000

	uhd_ctrl_request_timeout = 5000;
80003d58:	f0 eb 00 00 	st.d	r8[0],r10
80003d5c:	e0 69 13 88 	mov	r9,5000
	uhd_enable_setup_ready_interrupt(0);
80003d60:	e0 68 2c 74 	mov	r8,11380
80003d64:	b0 09       	st.h	r8[0x0],r9
	uhd_ack_fifocon(0);
80003d66:	fe 68 05 f0 	mov	r8,-129552
80003d6a:	91 0c       	st.w	r8[0x0],r12
80003d6c:	e0 69 40 00 	mov	r9,16384
	uhd_unfreeze_pipe(0);
80003d70:	fe 68 06 20 	mov	r8,-129504
80003d74:	91 09       	st.w	r8[0x0],r9
}
80003d76:	e2 69 00 00 	mov	r9,131072
80003d7a:	91 09       	st.w	r8[0x0],r9
80003d7c:	2f ed       	sub	sp,-8
80003d7e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d82:	d7 03       	nop

80003d84 <uhd_setup_request>:
80003d84:	eb cd 40 fc 	pushm	r2-r7,lr
80003d88:	20 1d       	sub	sp,4
80003d8a:	18 97       	mov	r7,r12
80003d8c:	50 0b       	stdsp	sp[0x0],r11
80003d8e:	14 92       	mov	r2,r10
80003d90:	12 96       	mov	r6,r9
80003d92:	10 93       	mov	r3,r8
		usb_setup_req_t *req,
		uint8_t *payload,
		uint16_t payload_size,
		uhd_callback_setup_run_t callback_run,
		uhd_callback_setup_end_t callback_end)
{
80003d94:	40 84       	lddsp	r4,sp[0x20]
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
80003d96:	32 0c       	mov	r12,32
80003d98:	e0 a0 32 dc 	rcall	8000a350 <malloc>
	if (request == NULL) {
80003d9c:	40 0b       	lddsp	r11,sp[0x0]
{
	irqflags_t flags;
	struct uhd_ctrl_request_t *request;
	bool b_start_request = false;

	request = malloc( sizeof(struct uhd_ctrl_request_t) );
80003d9e:	18 95       	mov	r5,r12
	if (request == NULL) {
80003da0:	c2 60       	breq	80003dec <uhd_setup_request+0x68>
		Assert(false);
		return false;
	}

	// Fill structure
	request->add = (uint8_t) add;
80003da2:	18 c7       	st.b	r12++,r7
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
80003da4:	30 8a       	mov	r10,8
80003da6:	e0 a0 34 ef 	rcall	8000a784 <memcpy>
	request->payload = payload;
	request->payload_size = payload_size;
	request->callback_run = callback_run;
	request->callback_end = callback_end;
	request->next_request = NULL;
80003daa:	30 08       	mov	r8,0
	}

	// Fill structure
	request->add = (uint8_t) add;
	memcpy(&request->req, req, sizeof(usb_setup_req_t));
	request->payload = payload;
80003dac:	8b 32       	st.w	r5[0xc],r2
	request->payload_size = payload_size;
80003dae:	eb 56 00 10 	st.h	r5[16],r6
	request->callback_run = callback_run;
80003db2:	8b 53       	st.w	r5[0x14],r3
	request->callback_end = callback_end;
80003db4:	8b 64       	st.w	r5[0x18],r4
	request->next_request = NULL;
80003db6:	8b 78       	st.w	r5[0x1c],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003db8:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003dbc:	d3 03       	ssrf	0x10

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
80003dbe:	e0 69 2c 68 	mov	r9,11368
80003dc2:	72 0b       	ld.w	r11,r9[0x0]
80003dc4:	58 0b       	cp.w	r11,0
		uhd_ctrl_request_first = request;
		b_start_request = true;
	} else {
		uhd_ctrl_request_last->next_request = request;
80003dc6:	c1 60       	breq	80003df2 <uhd_setup_request+0x6e>
80003dc8:	10 99       	mov	r9,r8
80003dca:	e0 68 2c 70 	mov	r8,11376
	}
	uhd_ctrl_request_last = request;
80003dce:	70 0b       	ld.w	r11,r8[0x0]
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003dd0:	97 75       	st.w	r11[0x1c],r5
80003dd2:	91 05       	st.w	r8[0x0],r5
80003dd4:	ed ba 00 10 	bld	r10,0x10
	cpu_irq_restore(flags);

	if (b_start_request) {
80003dd8:	c0 81       	brne	80003de8 <uhd_setup_request+0x64>
		// Start immediately request
		uhd_ctrl_phase_setup();
80003dda:	58 09       	cp.w	r9,0
80003ddc:	c0 41       	brne	80003de4 <uhd_setup_request+0x60>
80003dde:	2f fd       	sub	sp,-4
80003de0:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80003de4:	c7 0f       	rcall	80003cc4 <uhd_ctrl_phase_setup>
      cpu_irq_enable();
80003de6:	cf cb       	rjmp	80003dde <uhd_setup_request+0x5a>
80003de8:	d5 03       	csrf	0x10
	}
	return true;
}
80003dea:	cf 8b       	rjmp	80003dda <uhd_setup_request+0x56>
80003dec:	2f fd       	sub	sp,-4
80003dee:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
	request->next_request = NULL;

	// Add this request in the queue
	flags = cpu_irq_save();
	if (uhd_ctrl_request_first == NULL) {
		uhd_ctrl_request_first = request;
80003df2:	93 05       	st.w	r9[0x0],r5
80003df4:	e0 68 2c 70 	mov	r8,11376
80003df8:	30 19       	mov	r9,1
80003dfa:	ce cb       	rjmp	80003dd2 <uhd_setup_request+0x4e>

80003dfc <uhd_ep_free>:
80003dfc:	d4 31       	pushm	r0-r7,lr
80003dfe:	20 2d       	sub	sp,8
80003e00:	30 17       	mov	r7,1
80003e02:	18 91       	mov	r1,r12
80003e04:	16 90       	mov	r0,r11
80003e06:	30 06       	mov	r6,0
80003e08:	fe 65 00 00 	mov	r5,-131072
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80003e0c:	0e 94       	mov	r4,r7
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80003e0e:	30 63       	mov	r3,6
		if (!Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80003e10:	37 f2       	mov	r2,127
			continue;
		}
		if (endp != 0xFF) {
80003e12:	3f f8       	mov	r8,-1
80003e14:	c0 48       	rjmp	80003e1c <uhd_ep_free+0x20>
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80003e16:	2f f7       	sub	r7,-1
80003e18:	2f f6       	sub	r6,-1
80003e1a:	5c 57       	castu.b	r7
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80003e1c:	ea fa 04 1c 	ld.w	r10,r5[1052]
	return false;
}


void uhd_ep_free(usb_add_t add, usb_ep_t endp)
{
80003e20:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (!Is_uhd_pipe_enabled(pipe)) {
80003e24:	e8 0c 09 49 	lsl	r9,r4,r12
80003e28:	f3 ea 00 0a 	and	r10,r9,r10
80003e2c:	c1 50       	breq	80003e56 <uhd_ep_free+0x5a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
80003e2e:	18 9a       	mov	r10,r12
80003e30:	e2 1a 00 fc 	andl	r10,0xfc,COH
80003e34:	e0 3a fb dc 	sub	r10,130012
80003e38:	74 0b       	ld.w	r11,r10[0x0]
80003e3a:	f5 dc c0 02 	bfextu	r10,r12,0x0,0x2
80003e3e:	a3 7a       	lsl	r10,0x3
80003e40:	e4 0a 09 4a 	lsl	r10,r2,r10
80003e44:	f5 eb 00 0b 	and	r11,r10,r11
80003e48:	5c 9a       	brev	r10
80003e4a:	f4 0a 12 00 	clz	r10,r10
80003e4e:	f6 0a 0a 4a 	lsr	r10,r11,r10
80003e52:	14 31       	cp.w	r1,r10
80003e54:	c0 70       	breq	80003e62 <uhd_ep_free+0x66>
		}
		return;
	}
#endif
	// Search endpoint(s) in all pipes
	for (uint8_t pipe = 0; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80003e56:	e6 07 18 00 	cp.b	r7,r3
80003e5a:	fe 98 ff de 	brls	80003e16 <uhd_ep_free+0x1a>
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
	}
}
80003e5e:	2f ed       	sub	sp,-8
80003e60:	d8 32       	popm	r0-r7,pc
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
80003e62:	f0 00 18 00 	cp.b	r0,r8
80003e66:	c2 c0       	breq	80003ebe <uhd_ep_free+0xc2>
			// Disable specific endpoint number
			if (endp != uhd_get_pipe_endpoint_address(pipe)) {
80003e68:	f8 0a 15 02 	lsl	r10,r12,0x2
80003e6c:	e0 3a fb 00 	sub	r10,129792
80003e70:	74 0e       	ld.w	lr,r10[0x0]
80003e72:	fd de c2 04 	bfextu	lr,lr,0x10,0x4
80003e76:	74 0b       	ld.w	r11,r10[0x0]
80003e78:	50 0e       	stdsp	sp[0x0],lr
80003e7a:	e0 6e 00 80 	mov	lr,128
80003e7e:	f7 db c1 02 	bfextu	r11,r11,0x8,0x2
80003e82:	58 1b       	cp.w	r11,1
80003e84:	fc 0b 17 00 	moveq	r11,lr
80003e88:	f9 bb 01 00 	movne	r11,0
80003e8c:	40 0e       	lddsp	lr,sp[0x0]
80003e8e:	1c 4b       	or	r11,lr
80003e90:	16 30       	cp.w	r0,r11
80003e92:	ce 21       	brne	80003e56 <uhd_ep_free+0x5a>
				continue; // Mismatch
			}
		}
		// Unalloc pipe
		uhd_disable_pipe(pipe);
80003e94:	ea fb 04 1c 	ld.w	r11,r5[1052]
80003e98:	5c d9       	com	r9
80003e9a:	16 69       	and	r9,r11
80003e9c:	eb 49 04 1c 	st.w	r5[1052],r9
		uhd_unallocate_memory(pipe);
80003ea0:	74 09       	ld.w	r9,r10[0x0]
80003ea2:	a1 d9       	cbr	r9,0x1
80003ea4:	95 09       	st.w	r10[0x0],r9

		// Stop transfer on this pipe
#ifndef USB_HOST_HUB_SUPPORT
		if (pipe == 0) {
80003ea6:	58 0c       	cp.w	r12,0
80003ea8:	c1 01       	brne	80003ec8 <uhd_ep_free+0xcc>
			// Endpoint control
			if (uhd_ctrl_request_timeout) {
80003eaa:	e0 6a 2c 74 	mov	r10,11380
80003eae:	94 09       	ld.sh	r9,r10[0x0]
80003eb0:	58 09       	cp.w	r9,0
				uhd_ctrl_request_end(UHD_TRANS_DISCONNECT);
80003eb2:	cd 20       	breq	80003e56 <uhd_ep_free+0x5a>
80003eb4:	50 18       	stdsp	sp[0x4],r8
80003eb6:	30 1c       	mov	r12,1
80003eb8:	cd 2e       	rcall	80003c5c <uhd_ctrl_request_end>
80003eba:	40 18       	lddsp	r8,sp[0x4]
80003ebc:	ca db       	rjmp	80003e16 <uhd_ep_free+0x1a>
			continue;
		}
		if (add != uhd_get_configured_address(pipe)) {
			continue;
		}
		if (endp != 0xFF) {
80003ebe:	f8 0a 15 02 	lsl	r10,r12,0x2
80003ec2:	e0 3a fb 00 	sub	r10,129792
80003ec6:	ce 7b       	rjmp	80003e94 <uhd_ep_free+0x98>
			}
			continue;
		}
#endif
		// Endpoint interrupt, bulk or isochronous
		uhd_ep_abort_pipe(pipe, UHD_TRANS_DISCONNECT);
80003ec8:	50 18       	stdsp	sp[0x4],r8
80003eca:	30 1b       	mov	r11,1
80003ecc:	fe b0 fd 74 	rcall	800039b4 <uhd_ep_abort_pipe>
80003ed0:	40 18       	lddsp	r8,sp[0x4]
80003ed2:	cc 2b       	rjmp	80003e56 <uhd_ep_free+0x5a>

80003ed4 <uhd_ep_alloc>:
80003ed4:	eb cd 40 f8 	pushm	r3-r7,lr
80003ed8:	30 08       	mov	r8,0
80003eda:	fe 66 00 00 	mov	r6,-131072
80003ede:	30 17       	mov	r7,1
	uhd_enable_pipe_interrupt(0);
	return true;
}

bool uhd_ep_alloc(usb_add_t add, usb_ep_desc_t * ep_desc)
{
80003ee0:	f0 c9 ff ff 	sub	r9,r8,-1
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003ee4:	ec fa 04 1c 	ld.w	r10,r6[1052]
	uhd_enable_pipe_error_interrupt(0);
	uhd_enable_pipe_interrupt(0);
	return true;
}

bool uhd_ep_alloc(usb_add_t add, usb_ep_desc_t * ep_desc)
80003ee8:	2f f8       	sub	r8,-1
{
80003eea:	eb d9 c0 08 	bfextu	r5,r9,0x0,0x8
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
80003eee:	fe 6e 00 00 	mov	lr,-131072
80003ef2:	ee 08 09 49 	lsl	r9,r7,r8
80003ef6:	f3 ea 00 0a 	and	r10,r9,r10
80003efa:	c0 50       	breq	80003f04 <uhd_ep_alloc+0x30>
	uint8_t ep_type;
	uint8_t ep_dir;
	uint8_t ep_interval;
	uint8_t bank;

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
80003efc:	58 68       	cp.w	r8,6
80003efe:	cf 11       	brne	80003ee0 <uhd_ep_alloc+0xc>
		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
		uhd_enable_stall_interrupt(pipe);
		uhd_enable_pipe_error_interrupt(pipe);
		uhd_enable_pipe_interrupt(pipe);
		return true;
80003f00:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
80003f04:	fc f7 04 1c 	ld.w	r7,lr[1052]
80003f08:	f3 e7 10 07 	or	r7,r9,r7
80003f0c:	fd 47 04 1c 	st.w	lr[1052],r7
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80003f10:	30 26       	mov	r6,2
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
80003f12:	17 a7       	ld.ub	r7,r11[0x2]
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80003f14:	17 be       	ld.ub	lr,r11[0x3]
		if (Is_uhd_pipe_enabled(pipe)) {
			continue;
		}
		uhd_enable_pipe(pipe);
		ep_addr = ep_desc->bEndpointAddress & USB_EP_ADDR_MASK;
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
80003f16:	ee 0a 18 00 	cp.b	r10,r7
80003f1a:	f9 b4 09 01 	movgt	r4,1
80003f1e:	f9 b4 0a 02 	movle	r4,2
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
80003f22:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
		// Bank choice
		switch(ep_type) {
80003f26:	ec 0e 18 00 	cp.b	lr,r6
80003f2a:	e0 80 00 82 	breq	8000402e <uhd_ep_alloc+0x15a>
80003f2e:	30 36       	mov	r6,3
80003f30:	ec 0e 18 00 	cp.b	lr,r6
80003f34:	c0 90       	breq	80003f46 <uhd_ep_alloc+0x72>
80003f36:	30 1a       	mov	r10,1
80003f38:	f4 0e 18 00 	cp.b	lr,r10
80003f3c:	ce 21       	brne	80003f00 <uhd_ep_alloc+0x2c>
80003f3e:	17 e6       	ld.ub	r6,r11[0x6]
80003f40:	30 4a       	mov	r10,4
80003f42:	b9 66       	lsl	r6,0x18
		case 1:
			bank = AVR32_USBB_UECFG0_EPBK_SINGLE;
			break;
		case 2:
			bank = AVR32_USBB_UECFG0_EPBK_DOUBLE;
			break;
80003f44:	c0 38       	rjmp	80003f4a <uhd_ep_alloc+0x76>
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
80003f46:	17 e6       	ld.ub	r6,r11[0x6]
80003f48:	b9 66       	lsl	r6,0x18
		default:
			Assert(false);
			return false;
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
80003f4a:	17 d3       	ld.ub	r3,r11[0x5]
80003f4c:	ef d7 c0 04 	bfextu	r7,r7,0x0,0x4
80003f50:	ad 6e       	lsl	lr,0xc
80003f52:	17 cb       	ld.ub	r11,r11[0x4]
80003f54:	fd e7 11 0e 	or	lr,lr,r7<<0x10
80003f58:	e7 eb 10 8b 	or	r11,r3,r11<<0x8
80003f5c:	ab ae       	sbr	lr,0xa
80003f5e:	fd e4 10 8e 	or	lr,lr,r4<<0x8
80003f62:	fe 64 05 00 	mov	r4,-129792
80003f66:	fd e6 10 06 	or	r6,lr,r6
80003f6a:	ea 07 15 02 	lsl	r7,r5,0x2
80003f6e:	ed ea 10 0a 	or	r10,r6,r10
80003f72:	16 9e       	mov	lr,r11
80003f74:	30 86       	mov	r6,8
80003f76:	ee 04 00 0b 	add	r11,r7,r4
80003f7a:	5c ce       	swap.bh	lr
80003f7c:	e0 64 04 00 	mov	r4,1024
80003f80:	5c 7e       	castu.h	lr
80003f82:	fc 06 0c 4e 	max	lr,lr,r6
80003f86:	fc 04 0d 4e 	min	lr,lr,r4
80003f8a:	a1 7e       	lsl	lr,0x1
80003f8c:	20 1e       	sub	lr,1
80003f8e:	fc 0e 12 00 	clz	lr,lr
80003f92:	fc 0e 11 1c 	rsub	lr,lr,28
80003f96:	f5 ee 10 4a 	or	r10,r10,lr<<0x4
80003f9a:	97 0a       	st.w	r11[0x0],r10
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
		if (!Is_uhd_pipe_configured(pipe)) {
80003f9c:	fe 6a 05 30 	mov	r10,-129744
80003fa0:	ee 0a 00 0e 	add	lr,r7,r10
		}

		uhd_configure_pipe(pipe, ep_interval, ep_addr, ep_type, ep_dir,
				le16_to_cpu(ep_desc->wMaxPacketSize),
				bank, AVR32_USBB_UPCFG0_AUTOSW_MASK);
		uhd_allocate_memory(pipe);
80003fa4:	76 0a       	ld.w	r10,r11[0x0]
80003fa6:	a1 ba       	sbr	r10,0x1
80003fa8:	97 0a       	st.w	r11[0x0],r10
		if (!Is_uhd_pipe_configured(pipe)) {
80003faa:	7c 0a       	ld.w	r10,lr[0x0]
80003fac:	e6 1a 00 04 	andh	r10,0x4,COH
80003fb0:	c0 c1       	brne	80003fc8 <uhd_ep_alloc+0xf4>
			uhd_disable_pipe(pipe);
80003fb2:	fe 68 00 00 	mov	r8,-131072
80003fb6:	5c d9       	com	r9
80003fb8:	14 9c       	mov	r12,r10
80003fba:	f0 fa 04 1c 	ld.w	r10,r8[1052]
80003fbe:	14 69       	and	r9,r10
80003fc0:	f1 49 04 1c 	st.w	r8[1052],r9
			return false;
80003fc4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		}
		uhd_configure_address(pipe, add);
80003fc8:	37 fe       	mov	lr,127
80003fca:	f5 d8 c0 02 	bfextu	r10,r8,0x0,0x2
80003fce:	e2 15 00 fc 	andl	r5,0xfc,COH
80003fd2:	a3 7a       	lsl	r10,0x3
80003fd4:	e0 35 fb dc 	sub	r5,130012
80003fd8:	fc 0a 09 4a 	lsl	r10,lr,r10
80003fdc:	6a 0b       	ld.w	r11,r5[0x0]
80003fde:	14 9e       	mov	lr,r10
80003fe0:	5c 9e       	brev	lr
80003fe2:	fc 0e 12 00 	clz	lr,lr
80003fe6:	14 8b       	andn	r11,r10
80003fe8:	f8 0e 09 4c 	lsl	r12,r12,lr
80003fec:	f9 ea 00 0a 	and	r10,r12,r10
80003ff0:	16 4a       	or	r10,r11
80003ff2:	8b 0a       	st.w	r5[0x0],r10
		uhd_enable_pipe(pipe);
80003ff4:	fe 6a 00 00 	mov	r10,-131072
80003ff8:	f4 fb 04 1c 	ld.w	r11,r10[1052]
80003ffc:	16 49       	or	r9,r11
80003ffe:	f5 49 04 1c 	st.w	r10[1052],r9

		// Enable endpoint interrupts
		uhd_enable_pipe_dma_interrupt(pipe);
80004002:	fc 1b 02 00 	movh	r11,0x200
80004006:	f0 c9 00 01 	sub	r9,r8,1
8000400a:	f6 09 09 49 	lsl	r9,r11,r9
8000400e:	f5 49 04 18 	st.w	r10[1048],r9
		uhd_enable_stall_interrupt(pipe);
80004012:	e0 37 fa 10 	sub	r7,129552
80004016:	34 09       	mov	r9,64
80004018:	8f 09       	st.w	r7[0x0],r9
		uhd_enable_pipe_error_interrupt(pipe);
8000401a:	8f 06       	st.w	r7[0x0],r6
		uhd_enable_pipe_interrupt(pipe);
8000401c:	e0 69 01 00 	mov	r9,256
80004020:	30 1c       	mov	r12,1
80004022:	f2 08 09 48 	lsl	r8,r9,r8
80004026:	f5 48 04 18 	st.w	r10[1048],r8
		return true;
8000402a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
		ep_dir = (ep_desc->bEndpointAddress & USB_EP_DIR_IN)?
				AVR32_USBB_UPCFG0_PTOKEN_IN:
				AVR32_USBB_UPCFG0_PTOKEN_OUT,
		ep_type = ep_desc->bmAttributes&USB_EP_TYPE_MASK;
		// Bank choice
		switch(ep_type) {
8000402e:	14 96       	mov	r6,r10
80004030:	30 4a       	mov	r10,4
80004032:	c8 cb       	rjmp	80003f4a <uhd_ep_alloc+0x76>

80004034 <uhd_ep0_alloc>:
	uhd_send_resume();
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
80004034:	d4 01       	pushm	lr
	if (ep_size < 8) {
80004036:	30 78       	mov	r8,7
80004038:	f0 0b 18 00 	cp.b	r11,r8
8000403c:	e0 88 00 3f 	brls	800040ba <uhd_ep0_alloc+0x86>
#error TODO Add USB address in a list
		return true;
	}
#endif

	uhd_enable_pipe(0);
80004040:	fe 69 00 00 	mov	r9,-131072
80004044:	f2 f8 04 1c 	ld.w	r8,r9[1052]
80004048:	a1 a8       	sbr	r8,0x0
8000404a:	f3 48 04 1c 	st.w	r9[1052],r8
	uhd_configure_pipe(0, // Pipe 0
8000404e:	30 8e       	mov	lr,8
80004050:	fe 68 05 00 	mov	r8,-129792
80004054:	f6 0e 0c 4b 	max	r11,r11,lr
80004058:	e0 6a 04 00 	mov	r10,1024
8000405c:	f6 0a 0d 4a 	min	r10,r11,r10
80004060:	a1 7a       	lsl	r10,0x1
80004062:	20 1a       	sub	r10,1
80004064:	f4 0a 12 00 	clz	r10,r10
80004068:	f4 0a 11 1c 	rsub	r10,r10,28
8000406c:	a5 6a       	lsl	r10,0x4
8000406e:	91 0a       	st.w	r8[0x0],r10
#else
			ep_size,
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
80004070:	70 0a       	ld.w	r10,r8[0x0]
80004072:	a1 ba       	sbr	r10,0x1
80004074:	91 0a       	st.w	r8[0x0],r10
	if (!Is_uhd_pipe_configured(0)) {
80004076:	fe 68 05 30 	mov	r8,-129744
8000407a:	70 08       	ld.w	r8,r8[0x0]
8000407c:	e6 18 00 04 	andh	r8,0x4,COH
80004080:	c1 60       	breq	800040ac <uhd_ep0_alloc+0x78>
		uhd_disable_pipe(0);
		return false;
	}
	uhd_configure_address(0, add);
80004082:	fe 6a 04 24 	mov	r10,-130012
80004086:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000408a:	74 08       	ld.w	r8,r10[0x0]
8000408c:	e0 18 ff 80 	andl	r8,0xff80
80004090:	f9 e8 10 08 	or	r8,r12,r8
80004094:	95 08       	st.w	r10[0x0],r8

	// Always enable stall and error interrupts of control endpoint
	uhd_enable_stall_interrupt(0);
80004096:	fe 68 05 f0 	mov	r8,-129552
8000409a:	34 0a       	mov	r10,64
8000409c:	91 0a       	st.w	r8[0x0],r10
	uhd_enable_pipe_error_interrupt(0);
8000409e:	91 0e       	st.w	r8[0x0],lr
	uhd_enable_pipe_interrupt(0);
800040a0:	30 1c       	mov	r12,1
800040a2:	e0 68 01 00 	mov	r8,256
800040a6:	f3 48 04 18 	st.w	r9[1048],r8
	return true;
}
800040aa:	d8 02       	popm	pc
#endif
			AVR32_USBB_UECFG0_EPBK_SINGLE, 0);

	uhd_allocate_memory(0);
	if (!Is_uhd_pipe_configured(0)) {
		uhd_disable_pipe(0);
800040ac:	10 9c       	mov	r12,r8
800040ae:	f2 f8 04 1c 	ld.w	r8,r9[1052]
800040b2:	a1 c8       	cbr	r8,0x0
800040b4:	f3 48 04 1c 	st.w	r9[1052],r8
		return false;
800040b8:	d8 02       	popm	pc
	uhd_sleep_mode(UHD_STATE_IDLE);
}

bool uhd_ep0_alloc(usb_add_t add, uint8_t ep_size)
{
	if (ep_size < 8) {
800040ba:	d8 0a       	popm	pc,r12=0

800040bc <otg_dual_disable>:
# endif
}


void otg_dual_disable(void)
{
800040bc:	d4 01       	pushm	lr
	if (!otg_initialized) {
800040be:	e0 69 06 41 	mov	r9,1601
800040c2:	30 0a       	mov	r10,0
800040c4:	13 88       	ld.ub	r8,r9[0x0]
800040c6:	f4 08 18 00 	cp.b	r8,r10
		return; // Dual role not initialized
	}
	otg_initialized = false;

	// Do not authorize asynchronous USB interrupts
	AVR32_PM.AWEN.usb_waken = 0;
800040ca:	c1 b0       	breq	80004100 <otg_dual_disable+0x44>
800040cc:	fe 78 0c 00 	mov	r8,-62464
800040d0:	30 0c       	mov	r12,0
800040d2:	f0 fb 01 44 	ld.w	r11,r8[324]
800040d6:	f7 dc d0 01 	bfins	r11,r12,0x0,0x1
800040da:	f1 4b 01 44 	st.w	r8[324],r11
	otg_unfreeze_clock();
800040de:	fe 68 08 00 	mov	r8,-129024
800040e2:	70 0b       	ld.w	r11,r8[0x0]
800040e4:	af cb       	cbr	r11,0xe
# ifdef USB_ID
	otg_disable_id_interrupt();
800040e6:	91 0b       	st.w	r8[0x0],r11
800040e8:	70 0b       	ld.w	r11,r8[0x0]
800040ea:	a1 cb       	cbr	r11,0x0
# endif
	otg_disable();
800040ec:	91 0b       	st.w	r8[0x0],r11
800040ee:	70 0b       	ld.w	r11,r8[0x0]
800040f0:	af db       	cbr	r11,0xf
void otg_dual_disable(void)
{
	if (!otg_initialized) {
		return; // Dual role not initialized
	}
	otg_initialized = false;
800040f2:	91 0b       	st.w	r8[0x0],r11
	otg_unfreeze_clock();
# ifdef USB_ID
	otg_disable_id_interrupt();
# endif
	otg_disable();
	otg_disable_pad();
800040f4:	b2 8a       	st.b	r9[0x0],r10
800040f6:	70 09       	ld.w	r9,r8[0x0]
800040f8:	ad c9       	cbr	r9,0xc
	sysclk_disable_usb();
800040fa:	91 09       	st.w	r8[0x0],r9
800040fc:	e0 a0 04 c0 	rcall	80004a7c <sysclk_disable_usb>
80004100:	d8 02       	popm	pc
80004102:	d7 03       	nop

80004104 <uhd_disable>:
80004104:	eb cd 40 c0 	pushm	r6-r7,lr
void uhd_disable(bool b_id_stop)
{
	irqflags_t flags;

	// Check USB clock ready after a potential sleep mode < IDLE
	while (!Is_otg_clock_usable());
80004108:	fe 69 08 04 	mov	r9,-129020
	cpu_irq_restore(flags);
}


void uhd_disable(bool b_id_stop)
{
8000410c:	18 96       	mov	r6,r12
	irqflags_t flags;

	// Check USB clock ready after a potential sleep mode < IDLE
	while (!Is_otg_clock_usable());
8000410e:	72 08       	ld.w	r8,r9[0x0]
80004110:	ed b8 00 0e 	bld	r8,0xe
80004114:	cf d1       	brne	8000410e <uhd_disable+0xa>
	otg_unfreeze_clock();
80004116:	fe 67 08 00 	mov	r7,-129024
8000411a:	6e 08       	ld.w	r8,r7[0x0]
8000411c:	af c8       	cbr	r8,0xe
8000411e:	8f 08       	st.w	r7[0x0],r8

	// Disable Vbus change and error interrupts
	Clr_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSTE_MASK
80004120:	fe 68 00 00 	mov	r8,-131072
80004124:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004128:	e0 19 ff f5 	andl	r9,0xfff5
8000412c:	f1 49 08 00 	st.w	r8[2048],r9
			| AVR32_USBB_USBCON_VBERRE_MASK);

	// Disable main control interrupt
	// (Connection, disconnection, SOF and reset)
	AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_DCONNIEC_MASK
80004130:	37 f9       	mov	r9,127
80004132:	f1 49 04 14 	st.w	r8[1044],r9
			| AVR32_USBB_UHINTECLR_HSOFIEC_MASK
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
80004136:	fe 69 04 00 	mov	r9,-130048
8000413a:	72 08       	ld.w	r8,r9[0x0]
8000413c:	a9 c8       	cbr	r8,0x8
8000413e:	93 08       	st.w	r9[0x0],r8
	uhd_disable_vbus();
80004140:	fe 68 08 08 	mov	r8,-129016
80004144:	e0 69 02 00 	mov	r9,512
	uhc_notify_connection(false);
80004148:	30 0c       	mov	r12,0
			| AVR32_USBB_UHINTECLR_RSTIEC_MASK
			| AVR32_USBB_UHINTECLR_HWUPIEC_MASK
			| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
			| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
	uhd_disable_sof();
	uhd_disable_vbus();
8000414a:	91 09       	st.w	r8[0x0],r9
	uhc_notify_connection(false);
8000414c:	e0 a0 08 da 	rcall	80005300 <uhc_notify_connection>
	otg_freeze_clock();
80004150:	6e 08       	ld.w	r8,r7[0x0]
80004152:	af a8       	sbr	r8,0xe
80004154:	8f 08       	st.w	r7[0x0],r8

#ifdef USB_ID
	uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
	if (!b_id_stop) {
80004156:	58 06       	cp.w	r6,0
80004158:	c0 31       	brne	8000415e <uhd_disable+0x5a>
8000415a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000415e:	e1 b7 00 00 	mfsr	r7,0x0
	cpu_irq_disable();
80004162:	d3 03       	ssrf	0x10
		return; // No need to disable host, it is done automatically by hardware
	}
#endif

	flags = cpu_irq_save();
	otg_dual_disable();
80004164:	ca cf       	rcall	800040bc <otg_dual_disable>
80004166:	e6 17 00 01 	andh	r7,0x1,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000416a:	c0 30       	breq	80004170 <uhd_disable+0x6c>
8000416c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
      cpu_irq_enable();
   }

	barrier();
80004170:	d5 03       	csrf	0x10
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
80004172:	cf db       	rjmp	8000416c <uhd_disable+0x68>

80004174 <otg_dual_enable>:
   }

	barrier();
80004174:	eb cd 40 80 	pushm	r7,lr
80004178:	e0 68 06 41 	mov	r8,1601
8000417c:	30 09       	mov	r9,0
8000417e:	11 8a       	ld.ub	r10,r8[0x0]
	otg_data_memory_barrier();
}

bool otg_dual_enable(void)
{
	if (otg_initialized) {
80004180:	f2 0a 18 00 	cp.b	r10,r9
80004184:	c0 30       	breq	8000418a <otg_dual_enable+0x16>
80004186:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		return false; // Dual role already initialized
	}
	otg_initialized = true;
8000418a:	30 19       	mov	r9,1

	//* Enable USB hardware clock
	sysclk_enable_usb();
8000418c:	b0 89       	st.b	r8[0x0],r9
8000418e:	e0 a0 04 b7 	rcall	80004afc <sysclk_enable_usb>

	//* Link USB interrupt on OTG interrupt in dual role
	irq_register_handler(otg_interrupt, AVR32_USBB_IRQ, UHD_USB_INT_LEVEL);
80004192:	30 0a       	mov	r10,0
80004194:	e0 6b 02 20 	mov	r11,544
80004198:	fe cc fe d0 	sub	r12,pc,-304
	//pm_asyn_wake_up_enable(AVR32_PM_AWEN_USB_WAKEN_MASK);

# ifdef USB_ID
	// By default USBB is already configured with ID pin enable
	// The USBB must be enabled to provide interrupt
	otg_input_id_pin();
8000419c:	fe b0 f2 10 	rcall	800025bc <INTC_register_interrupt>
800041a0:	fe 78 10 00 	mov	r8,-61440
800041a4:	fc 19 00 20 	movh	r9,0x20
800041a8:	91 69       	st.w	r8[0x18],r9
800041aa:	91 99       	st.w	r8[0x24],r9
800041ac:	91 29       	st.w	r8[0x8],r9
	otg_unfreeze_clock();
800041ae:	f1 49 00 74 	st.w	r8[116],r9
800041b2:	fe 68 08 00 	mov	r8,-129024
800041b6:	70 09       	ld.w	r9,r8[0x0]
	otg_enable();
800041b8:	af c9       	cbr	r9,0xe
800041ba:	91 09       	st.w	r8[0x0],r9
800041bc:	70 09       	ld.w	r9,r8[0x0]
	otg_enable_id_interrupt();
800041be:	af b9       	sbr	r9,0xf
800041c0:	91 09       	st.w	r8[0x0],r9
800041c2:	70 09       	ld.w	r9,r8[0x0]
	otg_ack_id_transition();
800041c4:	a1 a9       	sbr	r9,0x0
800041c6:	91 09       	st.w	r8[0x0],r9
800041c8:	30 17       	mov	r7,1
800041ca:	fe 69 08 08 	mov	r9,-129016
	otg_freeze_clock();
800041ce:	93 07       	st.w	r9[0x0],r7
800041d0:	70 09       	ld.w	r9,r8[0x0]
	if (Is_otg_id_device()) {
800041d2:	af a9       	sbr	r9,0xe
800041d4:	91 09       	st.w	r8[0x0],r9
800041d6:	fe 68 08 04 	mov	r8,-129020
800041da:	70 08       	ld.w	r8,r8[0x0]
800041dc:	ed b8 00 0a 	bld	r8,0xa
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
		udc_start();
	} else {
		UHC_MODE_CHANGE(true);
800041e0:	c0 90       	breq	800041f2 <otg_dual_enable+0x7e>
800041e2:	0e 9c       	mov	r12,r7
		uhc_start();
800041e4:	e0 a0 19 b0 	rcall	80007544 <usb_mode_change>
800041e8:	e0 a0 05 54 	rcall	80004c90 <uhc_start>
	return true;  // ID pin management has been enabled
# else
	uhd_sleep_mode(UHD_STATE_OFF);
	return false; // ID pin management has not been enabled
# endif
}
800041ec:	0e 9c       	mov	r12,r7
	otg_enable_id_interrupt();
	otg_ack_id_transition();
	otg_freeze_clock();
	if (Is_otg_id_device()) {
		uhd_sleep_mode(UHD_STATE_WAIT_ID_HOST);
		UHC_MODE_CHANGE(false);
800041ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800041f2:	30 0c       	mov	r12,0
800041f4:	e0 a0 19 a8 	rcall	80007544 <usb_mode_change>
800041f8:	0e 9c       	mov	r12,r7
800041fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800041fe:	d7 03       	nop

80004200 <uhd_enable>:
80004200:	eb cd 40 80 	pushm	r7,lr
80004204:	e1 b7 00 00 	mfsr	r7,0x0
80004208:	d3 03       	ssrf	0x10
8000420a:	cb 5f       	rcall	80004174 <otg_dual_enable>
8000420c:	c0 71       	brne	8000421a <uhd_enable+0x1a>
8000420e:	fe 6b 08 04 	mov	r11,-129020
80004212:	76 08       	ld.w	r8,r11[0x0]
		return;
	}

#ifdef USB_ID
	// Check that the host mode is selected by ID pin
	if (!Is_otg_id_host()) {
80004214:	e2 18 04 00 	andl	r8,0x400,COH
80004218:	c0 70       	breq	80004226 <uhd_enable+0x26>
8000421a:	e6 17 00 01 	andh	r7,0x1,COH
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000421e:	c0 21       	brne	80004222 <uhd_enable+0x22>
80004220:	d5 03       	csrf	0x10
      cpu_irq_enable();
80004222:	e3 cd 80 80 	ldm	sp++,r7,pc
   }

	barrier();
80004226:	fe 79 10 00 	mov	r9,-61440
	otg_force_host_mode();
#endif

	// Enable USB hardware
#ifdef USB_VBOF
	uhd_output_vbof_pin();
8000422a:	fc 1a 00 40 	movh	r10,0x40
8000422e:	93 6a       	st.w	r9[0x18],r10
80004230:	93 9a       	st.w	r9[0x24],r10
80004232:	93 2a       	st.w	r9[0x8],r10
80004234:	f3 4a 00 88 	st.w	r9[136],r10
80004238:	f3 4a 00 78 	st.w	r9[120],r10
8000423c:	fe 69 08 00 	mov	r9,-129024
# if USB_VBOF_ACTIVE_LEVEL == HIGH
	uhd_set_vbof_active_high();
# else // USB_VBOF_ACTIVE_LEVEL == LOW
	uhd_set_vbof_active_low();
80004240:	72 0a       	ld.w	r10,r9[0x0]
80004242:	ad ba       	sbr	r10,0xd
80004244:	93 0a       	st.w	r9[0x0],r10
80004246:	72 0a       	ld.w	r10,r9[0x0]
# endif
#endif
	otg_enable_pad();
80004248:	ad aa       	sbr	r10,0xc
8000424a:	93 0a       	st.w	r9[0x0],r10
8000424c:	72 0a       	ld.w	r10,r9[0x0]
	otg_enable();
8000424e:	af ba       	sbr	r10,0xf
80004250:	93 0a       	st.w	r9[0x0],r10
80004252:	e0 6a 2c 74 	mov	r10,11380

	uhd_ctrl_request_first = NULL;
	uhd_ctrl_request_last = NULL;
	uhd_ctrl_request_timeout = 0;
80004256:	b4 08       	st.h	r10[0x0],r8
	uhd_suspend_start = 0;
	uhd_resume_start = 0;
	uhd_b_suspend_requested = false;

	otg_unfreeze_clock();
80004258:	72 0a       	ld.w	r10,r9[0x0]
8000425a:	af ca       	cbr	r10,0xe
8000425c:	93 0a       	st.w	r9[0x0],r10
	uhd_disable_high_speed_mode();
#  endif
#endif

	// Clear all interrupts that may have been set by a previous host mode
	AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_DCONNIC_MASK
8000425e:	37 fa       	mov	r10,127
80004260:	fe 69 00 00 	mov	r9,-131072
80004264:	f3 4a 04 08 	st.w	r9[1032],r10
			| AVR32_USBB_UHINTCLR_DDISCIC_MASK | AVR32_USBB_UHINTCLR_HSOFIC_MASK
			| AVR32_USBB_UHINTCLR_HWUPIC_MASK | AVR32_USBB_UHINTCLR_RSMEDIC_MASK
			| AVR32_USBB_UHINTCLR_RSTIC_MASK | AVR32_USBB_UHINTCLR_RXRSMIC_MASK;
	otg_ack_vbus_transition();
80004268:	fe 6a 08 08 	mov	r10,-129016
8000426c:	30 2c       	mov	r12,2
8000426e:	95 0c       	st.w	r10[0x0],r12

	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
80004270:	f2 fa 08 00 	ld.w	r10,r9[2048]
80004274:	e8 1a 01 0a 	orl	r10,0x10a
80004278:	f3 4a 08 00 	st.w	r9[2048],r10
# endif
#endif
	otg_enable_pad();
	otg_enable();

	uhd_ctrl_request_first = NULL;
8000427c:	e0 6a 2c 68 	mov	r10,11368
80004280:	10 99       	mov	r9,r8
	uhd_ctrl_request_last = NULL;
80004282:	95 08       	st.w	r10[0x0],r8
80004284:	e0 6a 2c 70 	mov	r10,11376
	uhd_ctrl_request_timeout = 0;
	uhd_suspend_start = 0;
80004288:	95 08       	st.w	r10[0x0],r8
	uhd_resume_start = 0;
8000428a:	e0 68 06 c0 	mov	r8,1728
	uhd_b_suspend_requested = false;
8000428e:	b0 89       	st.b	r8[0x0],r9
80004290:	e0 68 06 c2 	mov	r8,1730
	// Enable Vbus change and error interrupts
	// Disable automatic Vbus control after Vbus error
	Set_bits(AVR32_USBB.usbcon, AVR32_USBB_USBCON_VBUSHWC_MASK
			|AVR32_USBB_USBCON_VBUSTE_MASK
			|AVR32_USBB_USBCON_VBERRE_MASK);
	uhd_enable_vbus();
80004294:	b0 89       	st.b	r8[0x0],r9
80004296:	e0 68 06 c3 	mov	r8,1731
8000429a:	b0 89       	st.b	r8[0x0],r9

	// Force Vbus interrupt when Vbus is always high
	// This is possible due to a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
8000429c:	fe 69 08 0c 	mov	r9,-129012
		otg_raise_vbus_transition();
800042a0:	e0 68 02 00 	mov	r8,512
800042a4:	93 08       	st.w	r9[0x0],r8
	}

	// Enable main control interrupt
	// Connection, SOF and reset
	AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_DCONNIES_MASK
800042a6:	76 08       	ld.w	r8,r11[0x0]
800042a8:	ed b8 00 0b 	bld	r8,0xb
800042ac:	f3 fc 0a 00 	st.weq	r9[0x0],r12
			| AVR32_USBB_UHINTESET_HSOFIES_MASK
			| AVR32_USBB_UHINTESET_RSTIES_MASK;

	otg_freeze_clock();
800042b0:	32 59       	mov	r9,37
800042b2:	fe 68 00 00 	mov	r8,-131072
800042b6:	f1 49 04 18 	st.w	r8[1048],r9
800042ba:	fe 69 08 00 	mov	r9,-129024
800042be:	72 08       	ld.w	r8,r9[0x0]
800042c0:	af a8       	sbr	r8,0xe
800042c2:	93 08       	st.w	r9[0x0],r8
800042c4:	ca bb       	rjmp	8000421a <uhd_enable+0x1a>
800042c6:	d7 03       	nop

800042c8 <otg_interrupt>:
800042c8:	d4 31       	pushm	r0-r7,lr
800042ca:	20 1d       	sub	sp,4
800042cc:	fe 69 08 04 	mov	r9,-129020
800042d0:	72 08       	ld.w	r8,r9[0x0]
800042d2:	ed b8 00 00 	bld	r8,0x0
800042d6:	c0 c0       	breq	800042ee <otg_interrupt+0x26>
			UHC_MODE_CHANGE(true);
			uhc_start();
		}
		return;
	}
	b_mode_device = Is_otg_id_device();
800042d8:	72 08       	ld.w	r8,r9[0x0]
#else
	b_mode_device = Is_otg_device_mode_forced();
#endif

	// Redirection to host or device interrupt
	if (b_mode_device) {
800042da:	ed b8 00 0a 	bld	r8,0xa
800042de:	c2 e1       	brne	8000433a <otg_interrupt+0x72>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
800042e0:	fe 68 00 00 	mov	r8,-131072
800042e4:	f0 f8 08 18 	ld.w	r8,r8[2072]
}
800042e8:	2f fd       	sub	sp,-4
800042ea:	d4 32       	popm	r0-r7,lr
800042ec:	d6 03       	rete
{
	bool b_mode_device;

#ifdef USB_ID
	if (Is_otg_id_transition()) {
		while (!Is_otg_clock_usable());
800042ee:	72 08       	ld.w	r8,r9[0x0]
800042f0:	ed b8 00 0e 	bld	r8,0xe
800042f4:	cf d1       	brne	800042ee <otg_interrupt+0x26>
		otg_unfreeze_clock();
800042f6:	fe 68 08 00 	mov	r8,-129024
800042fa:	70 09       	ld.w	r9,r8[0x0]
800042fc:	af c9       	cbr	r9,0xe
800042fe:	91 09       	st.w	r8[0x0],r9
		otg_ack_id_transition();
80004300:	30 1c       	mov	r12,1
80004302:	fe 69 08 08 	mov	r9,-129016
80004306:	93 0c       	st.w	r9[0x0],r12
		otg_freeze_clock();
80004308:	70 09       	ld.w	r9,r8[0x0]
8000430a:	af a9       	sbr	r9,0xe
8000430c:	91 09       	st.w	r8[0x0],r9
		if (Is_otg_id_device()) {
8000430e:	fe 68 08 04 	mov	r8,-129020
80004312:	70 08       	ld.w	r8,r8[0x0]
80004314:	ed b8 00 0a 	bld	r8,0xa
80004318:	c0 a1       	brne	8000432c <otg_interrupt+0x64>
			uhc_stop(false);
8000431a:	30 0c       	mov	r12,0
8000431c:	e0 a0 04 b6 	rcall	80004c88 <uhc_stop>
			UHC_MODE_CHANGE(false);
80004320:	30 0c       	mov	r12,0
80004322:	e0 a0 19 11 	rcall	80007544 <usb_mode_change>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80004326:	2f fd       	sub	sp,-4
80004328:	d4 32       	popm	r0-r7,lr
8000432a:	d6 03       	rete
			uhc_stop(false);
			UHC_MODE_CHANGE(false);
			udc_start();
		} else {
			udc_stop();
			UHC_MODE_CHANGE(true);
8000432c:	e0 a0 19 0c 	rcall	80007544 <usb_mode_change>
			uhc_start();
80004330:	e0 a0 04 b0 	rcall	80004c90 <uhc_start>
		udd_interrupt();
	} else {
		uhd_interrupt();
	}
	otg_data_memory_barrier();
}
80004334:	2f fd       	sub	sp,-4
80004336:	d4 32       	popm	r0-r7,lr
80004338:	d6 03       	rete
static void uhd_interrupt(void)
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
8000433a:	fe 6a 04 04 	mov	r10,-130044
8000433e:	74 08       	ld.w	r8,r10[0x0]
80004340:	ed b8 00 05 	bld	r8,0x5
80004344:	e0 80 00 a5 	breq	8000448e <otg_interrupt+0x1c6>
		uhd_sof_interrupt();
		return;
	}

	// Manage pipe interrupts
	pipe_int = uhd_get_interrupt_pipe_number();
80004348:	fe 69 00 00 	mov	r9,-131072
8000434c:	f2 f8 04 04 	ld.w	r8,r9[1028]
80004350:	f2 fc 04 10 	ld.w	r12,r9[1040]
80004354:	a9 88       	lsr	r8,0x8
80004356:	f1 ec 02 8c 	and	r12,r8,r12>>0x8
8000435a:	a7 bc       	sbr	r12,0x7
8000435c:	5c 9c       	brev	r12
8000435e:	f8 0c 12 00 	clz	r12,r12
	if (pipe_int == 0) {
80004362:	e0 80 00 c3 	breq	800044e8 <otg_interrupt+0x220>
		// Interrupt acked by control endpoint managed
		uhd_ctrl_interrupt();
		return;
	}
	if (pipe_int != AVR32_USBB_EPT_NUM) {
80004366:	30 78       	mov	r8,7
80004368:	f0 0c 18 00 	cp.b	r12,r8
8000436c:	c5 c1       	brne	80004424 <otg_interrupt+0x15c>
		// Interrupt acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt(pipe_int);
		return;
	}
	pipe_int = uhd_get_pipe_dma_interrupt_number();
8000436e:	f2 fb 04 04 	ld.w	r11,r9[1028]
80004372:	f2 fc 04 10 	ld.w	r12,r9[1040]
80004376:	b9 9b       	lsr	r11,0x19
80004378:	f7 ec 03 9b 	and	r11,r11,r12>>0x19
8000437c:	a7 ab       	sbr	r11,0x6
8000437e:	5c 9b       	brev	r11
80004380:	f6 0b 12 00 	clz	r11,r11
80004384:	f6 cc ff ff 	sub	r12,r11,-1
	if (pipe_int != AVR32_USBB_EPT_NUM) {
80004388:	f0 0c 18 00 	cp.b	r12,r8
8000438c:	c3 b0       	breq	80004402 <otg_interrupt+0x13a>
static void uhd_pipe_interrupt_dma(uint8_t pipe)
{
	uhd_pipe_job_t *ptr_job;
	uint32_t nb_remaining;

	if (uhd_pipe_dma_get_status(pipe)
8000438e:	f8 08 15 04 	lsl	r8,r12,0x4
80004392:	e0 38 f9 00 	sub	r8,129280
80004396:	70 39       	ld.w	r9,r8[0xc]
80004398:	ed b9 00 00 	bld	r9,0x0
8000439c:	ca 20       	breq	800042e0 <otg_interrupt+0x18>
			& AVR32_USBB_UHDMA1_STATUS_CH_EN_MASK) {
		return; // Ignore EOT_STA interrupt
	}
	// Save number of data no transfered
	nb_remaining = (uhd_pipe_dma_get_status(pipe) &
8000439e:	70 3b       	ld.w	r11,r8[0xc]
800043a0:	b1 8b       	lsr	r11,0x10
			AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_MASK)
			>> AVR32_USBB_UHDMA1_STATUS_CH_BYTE_CNT_OFFSET;
	if (nb_remaining) {
800043a2:	c0 d0       	breq	800043bc <otg_interrupt+0xf4>
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];
800043a4:	e0 69 06 48 	mov	r9,1608
800043a8:	f8 c8 00 01 	sub	r8,r12,1
800043ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043b0:	f2 08 00 28 	add	r8,r9,r8<<0x2

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
800043b4:	70 39       	ld.w	r9,r8[0xc]
800043b6:	16 19       	sub	r9,r11

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
800043b8:	91 29       	st.w	r8[0x8],r9
		// Get job corresponding at endpoint
		ptr_job = &uhd_pipe_job[pipe - 1];

		// Transfer no complete (short packet or ZLP) then:
		// Update number of transfered data
		ptr_job->nb_trans -= nb_remaining;
800043ba:	91 39       	st.w	r8[0xc],r9

		// Set transfer complete to stop the transfer
		ptr_job->buf_size = ptr_job->nb_trans;
	}

	if (uhd_is_pipe_out(pipe)) {
800043bc:	f8 0a 15 02 	lsl	r10,r12,0x2
800043c0:	fe 69 05 00 	mov	r9,-129792
800043c4:	f4 09 00 08 	add	r8,r10,r9
800043c8:	70 08       	ld.w	r8,r8[0x0]
800043ca:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
800043ce:	58 28       	cp.w	r8,2
800043d0:	e0 80 01 d1 	breq	80004772 <otg_interrupt+0x4aa>
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
	} else {
		if (!Is_uhd_pipe_frozen(pipe)) {
800043d4:	fe 68 05 c0 	mov	r8,-129600
800043d8:	f4 08 00 09 	add	r9,r10,r8
800043dc:	72 08       	ld.w	r8,r9[0x0]
800043de:	ed b8 00 11 	bld	r8,0x11
800043e2:	c0 80       	breq	800043f2 <otg_interrupt+0x12a>
			// Pipe is not freeze in case of :
			// - incomplete transfer when the request number INRQ is not complete.
			// - low USB speed and with a high CPU frequency,
			// a ACK from host can be always running on USB line.

			if (nb_remaining) {
800043e4:	58 0b       	cp.w	r11,0
800043e6:	c0 90       	breq	800043f8 <otg_interrupt+0x130>
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
800043e8:	e0 3a fa 10 	sub	r10,129552
800043ec:	e2 68 00 00 	mov	r8,131072
800043f0:	95 08       	st.w	r10[0x0],r8
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
				}
			}
		}
		uhd_pipe_trans_complet(pipe);
800043f2:	fe b0 fb 11 	rcall	80003a14 <uhd_pipe_trans_complet>
800043f6:	c7 5b       	rjmp	800042e0 <otg_interrupt+0x18>
			if (nb_remaining) {
				// Freeze pipe in case of incomplete transfer
				uhd_freeze_pipe(pipe);
			} else {
				// Wait freeze in case of ASK on going
				while (!Is_uhd_pipe_frozen(pipe)) {
800043f8:	72 08       	ld.w	r8,r9[0x0]
800043fa:	ed b8 00 11 	bld	r8,0x11
800043fe:	cf d1       	brne	800043f8 <otg_interrupt+0x130>
80004400:	cf 9b       	rjmp	800043f2 <otg_interrupt+0x12a>
		// Interrupt DMA acked by bulk/interrupt/isochronous endpoint
		uhd_pipe_interrupt_dma(pipe_int);
		return;
	}
	// USB bus reset detection
	if (Is_uhd_reset_sent()) {
80004402:	74 08       	ld.w	r8,r10[0x0]
80004404:	e2 18 00 04 	andl	r8,0x4,COH
80004408:	e0 80 01 14 	breq	80004630 <otg_interrupt+0x368>
		uhd_ack_reset_sent();
8000440c:	fe 68 04 08 	mov	r8,-130040
80004410:	30 49       	mov	r9,4
80004412:	91 09       	st.w	r8[0x0],r9
		if (uhd_reset_callback != NULL) {
80004414:	e0 68 06 44 	mov	r8,1604
80004418:	70 08       	ld.w	r8,r8[0x0]
8000441a:	58 08       	cp.w	r8,0
8000441c:	fe 90 ff 62 	breq	800042e0 <otg_interrupt+0x18>
			uhd_reset_callback();
80004420:	5d 18       	icall	r8
80004422:	c5 fb       	rjmp	800042e0 <otg_interrupt+0x18>
 *
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
80004424:	fe 69 05 c0 	mov	r9,-129600
80004428:	f8 08 15 02 	lsl	r8,r12,0x2
8000442c:	f0 09 00 0e 	add	lr,r8,r9
80004430:	7c 09       	ld.w	r9,lr[0x0]
80004432:	ed b9 00 0c 	bld	r9,0xc
80004436:	e0 81 00 95 	brne	80004560 <otg_interrupt+0x298>
8000443a:	fe 69 05 30 	mov	r9,-129744
8000443e:	f0 09 00 0a 	add	r10,r8,r9
80004442:	74 0b       	ld.w	r11,r10[0x0]
80004444:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
80004448:	e0 80 01 9c 	breq	80004780 <otg_interrupt+0x4b8>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
8000444c:	7c 09       	ld.w	r9,lr[0x0]
8000444e:	ed b9 00 01 	bld	r9,0x1
80004452:	c0 61       	brne	8000445e <otg_interrupt+0x196>
80004454:	74 09       	ld.w	r9,r10[0x0]
80004456:	ed b9 00 01 	bld	r9,0x1
8000445a:	e0 80 01 3f 	breq	800046d8 <otg_interrupt+0x410>
		uhd_ack_fifocon(pipe);
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
8000445e:	74 09       	ld.w	r9,r10[0x0]
80004460:	e2 19 00 40 	andl	r9,0x40,COH
80004464:	e0 81 01 70 	brne	80004744 <otg_interrupt+0x47c>
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
80004468:	74 0a       	ld.w	r10,r10[0x0]
8000446a:	ed ba 00 03 	bld	r10,0x3
8000446e:	fe 91 ff 39 	brne	800042e0 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
80004472:	e0 38 f9 80 	sub	r8,129408
80004476:	70 0a       	ld.w	r10,r8[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
80004478:	91 09       	st.w	r8[0x0],r9
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
8000447a:	f1 da c0 04 	bfextu	r8,r10,0x0,0x4
8000447e:	20 18       	sub	r8,1
80004480:	58 28       	cp.w	r8,2
80004482:	e0 88 01 43 	brls	80004708 <otg_interrupt+0x440>
80004486:	30 6b       	mov	r11,6
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(pipe)) {
		// Get and ack error
		uhd_ep_abort_pipe(pipe, uhd_pipe_get_error(pipe));
80004488:	fe b0 fa 96 	rcall	800039b4 <uhd_ep_abort_pipe>
8000448c:	c2 ab       	rjmp	800042e0 <otg_interrupt+0x18>
{
	uint8_t pipe_int;

	// Manage SOF interrupt
	if (Is_uhd_sof()) {
		uhd_ack_sof();
8000448e:	32 09       	mov	r9,32
80004490:	fe 68 04 08 	mov	r8,-130040
80004494:	91 09       	st.w	r8[0x0],r9
			return;
		}
	}

	// Manage a delay to enter in suspend
	if (uhd_suspend_start) {
80004496:	e0 68 06 c0 	mov	r8,1728
8000449a:	11 89       	ld.ub	r9,r8[0x0]
8000449c:	58 09       	cp.w	r9,0
8000449e:	c6 60       	breq	8000456a <otg_interrupt+0x2a2>
		if (--uhd_suspend_start == 0) {
800044a0:	20 19       	sub	r9,1
800044a2:	5c 59       	castu.b	r9
800044a4:	b0 89       	st.b	r8[0x0],r9
800044a6:	fe 91 ff 1d 	brne	800042e0 <otg_interrupt+0x18>
			// then wait end of SOF generation
			// to be sure that disable SOF has been accepted
#ifdef AVR32_USBB_USBSTA_SPEED_HIGH // If UTMI
			while (115<uhd_get_frame_position()) {
#else
			while (185<uhd_get_frame_position()) {
800044aa:	fe 69 04 20 	mov	r9,-130016
800044ae:	72 08       	ld.w	r8,r9[0x0]
800044b0:	f1 d8 c2 08 	bfextu	r8,r8,0x10,0x8
800044b4:	e0 48 00 b9 	cp.w	r8,185
800044b8:	e0 88 00 06 	brls	800044c4 <otg_interrupt+0x1fc>
#endif
				if (Is_uhd_disconnection()) {
800044bc:	74 08       	ld.w	r8,r10[0x0]
800044be:	ed b8 00 01 	bld	r8,0x1
800044c2:	cf 61       	brne	800044ae <otg_interrupt+0x1e6>
					break;
				}
			}
			uhd_disable_sof();
800044c4:	fe 69 04 00 	mov	r9,-130048
800044c8:	72 08       	ld.w	r8,r9[0x0]
800044ca:	a9 c8       	cbr	r8,0x8
800044cc:	93 08       	st.w	r9[0x0],r8

			// Ack previous wakeup and resumes interrupts
			AVR32_USBB.uhintclr = AVR32_USBB_UHINTCLR_HWUPIC_MASK
800044ce:	fe 68 00 00 	mov	r8,-131072
800044d2:	35 89       	mov	r9,88
800044d4:	f1 49 04 08 	st.w	r8[1032],r9
					|AVR32_USBB_UHINTCLR_RSMEDIC_MASK
					|AVR32_USBB_UHINTCLR_RXRSMIC_MASK;

			// Enable wakeup/resumes interrupts
			AVR32_USBB.uhinteset = AVR32_USBB_UHINTESET_HWUPIES_MASK
800044d8:	f1 49 04 18 	st.w	r8[1048],r9
					|AVR32_USBB_UHINTESET_RSMEDIES_MASK
					|AVR32_USBB_UHINTESET_RXRSMIES_MASK;

			otg_freeze_clock();
800044dc:	fe 69 08 00 	mov	r9,-129024
800044e0:	72 08       	ld.w	r8,r9[0x0]
800044e2:	af a8       	sbr	r8,0xe
800044e4:	93 08       	st.w	r9[0x0],r8
800044e6:	cf da       	rjmp	800042e0 <otg_interrupt+0x18>
{
	// A setup request is on-going
	Assert(uhd_ctrl_request_timeout!=0);

	// Disable setup, IN and OUT interrupts of control endpoint
	AVR32_USBB.upcon0clr = AVR32_USBB_UPCON0CLR_TXSTPEC_MASK
800044e8:	30 78       	mov	r8,7
800044ea:	f3 48 06 20 	st.w	r9[1568],r8
			| AVR32_USBB_UPCON0CLR_RXINEC_MASK
			| AVR32_USBB_UPCON0CLR_TXOUTEC_MASK;

	// Search event on control endpoint
	if (Is_uhd_setup_ready(0)) {
800044ee:	fe 69 05 30 	mov	r9,-129744
800044f2:	72 08       	ld.w	r8,r9[0x0]
800044f4:	ed b8 00 02 	bld	r8,0x2
800044f8:	c5 71       	brne	800045a6 <otg_interrupt+0x2de>
		// SETUP packet sent
		uhd_freeze_pipe(0);
800044fa:	fe 6b 05 f0 	mov	r11,-129552
800044fe:	e2 6a 00 00 	mov	r10,131072
80004502:	97 0a       	st.w	r11[0x0],r10
		uhd_ack_setup_ready(0);
80004504:	30 49       	mov	r9,4
80004506:	fe 68 05 60 	mov	r8,-129696
8000450a:	91 09       	st.w	r8[0x0],r9
		Assert(uhd_ctrl_request_phase == UHD_CTRL_REQ_PHASE_SETUP);

		// Start DATA phase
		if ((uhd_ctrl_request_first->req.bmRequestType & USB_REQ_DIR_MASK)
8000450c:	18 9e       	mov	lr,r12
8000450e:	e0 69 2c 68 	mov	r9,11368
80004512:	72 09       	ld.w	r9,r9[0x0]
80004514:	13 97       	ld.ub	r7,r9[0x1]
80004516:	f8 07 18 00 	cp.b	r7,r12
8000451a:	e0 85 01 cf 	brlt	800048b8 <otg_interrupt+0x5f0>
				== USB_REQ_DIR_IN ) {
			uhd_ctrl_phase_data_in_start();
		} else {
			if (uhd_ctrl_request_first->req.wLength) {
8000451e:	f3 3e 00 08 	ld.ub	lr,r9[8]
80004522:	13 f9       	ld.ub	r9,r9[0x7]
80004524:	fd e9 10 89 	or	r9,lr,r9<<0x8
80004528:	f8 09 19 00 	cp.h	r9,r12
8000452c:	e0 81 01 33 	brne	80004792 <otg_interrupt+0x4ca>
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
80004530:	fe 6c 05 00 	mov	r12,-129792
80004534:	78 09       	ld.w	r9,r12[0x0]
80004536:	e0 19 fc ff 	andl	r9,0xfcff
8000453a:	a9 a9       	sbr	r9,0x8
8000453c:	99 09       	st.w	r12[0x0],r9
	uhd_ack_in_received(0);
8000453e:	30 19       	mov	r9,1
80004540:	91 09       	st.w	r8[0x0],r9
	uhd_ack_short_packet(0);
80004542:	e0 6c 00 80 	mov	r12,128
80004546:	91 0c       	st.w	r8[0x0],r12
	uhd_enable_in_received_interrupt(0);
80004548:	97 09       	st.w	r11[0x0],r9
	uhd_ack_fifocon(0);
8000454a:	fe 68 06 20 	mov	r8,-129504
8000454e:	e0 69 40 00 	mov	r9,16384
80004552:	91 09       	st.w	r8[0x0],r9
	uhd_unfreeze_pipe(0);
80004554:	91 0a       	st.w	r8[0x0],r10
 * \internal
 * \brief Starts the ZLP IN phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_in(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
80004556:	30 39       	mov	r9,3
80004558:	e0 68 2c 64 	mov	r8,11364
8000455c:	91 09       	st.w	r8[0x0],r9
8000455e:	cc 1a       	rjmp	800042e0 <otg_interrupt+0x18>
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
80004560:	fe 69 05 30 	mov	r9,-129744
80004564:	f0 09 00 0a 	add	r10,r8,r9
80004568:	c7 2b       	rjmp	8000444c <otg_interrupt+0x184>
			uhd_sleep_mode(UHD_STATE_SUSPEND);
		}
		return; // Abort SOF events
	}
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
8000456a:	e0 69 06 c2 	mov	r9,1730
8000456e:	13 88       	ld.ub	r8,r9[0x0]
80004570:	58 08       	cp.w	r8,0
80004572:	c3 60       	breq	800045de <otg_interrupt+0x316>
		if (--uhd_resume_start == 0) {
80004574:	20 18       	sub	r8,1
80004576:	5c 58       	castu.b	r8
80004578:	b2 88       	st.b	r9[0x0],r8
8000457a:	fe 91 fe b3 	brne	800042e0 <otg_interrupt+0x18>
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
8000457e:	e0 69 06 c1 	mov	r9,1729
					uhd_unfreeze_pipe(pipe);
80004582:	e2 6c 00 00 	mov	r12,131072
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
80004586:	13 8b       	ld.ub	r11,r9[0x0]
80004588:	fe 69 06 24 	mov	r9,-129500
 * is enabled because this one can not occurred during the USB ISR
 * (=during INTX is masked).
 * See Technical reference $3.8.3 Masking interrupt requests
 * in peripheral modules.
 */
ISR(otg_interrupt, AVR32_USBB_IRQ_GROUP, UHD_USB_INT_LEVEL)
8000458c:	2f f8       	sub	r8,-1
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
8000458e:	f6 08 08 4a 	asr	r10,r11,r8
					uhd_unfreeze_pipe(pipe);
80004592:	ed ba 00 00 	bld	r10,0x0
80004596:	f3 fc 0a 00 	st.weq	r9[0x0],r12
8000459a:	2f c9       	sub	r9,-4
	}
	// Manage a delay to exit of suspend
	if (uhd_resume_start) {
		if (--uhd_resume_start == 0) {
			// Restore pipes unfreezed
			for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
8000459c:	58 68       	cp.w	r8,6
8000459e:	cf 71       	brne	8000458c <otg_interrupt+0x2c4>
				if ((uhd_pipes_unfreeze >> pipe) & 0x01) {
					uhd_unfreeze_pipe(pipe);
				}
			}
			uhc_notify_resume();
800045a0:	e0 a0 03 86 	rcall	80004cac <uhc_notify_resume>
800045a4:	c9 ea       	rjmp	800042e0 <otg_interrupt+0x18>
				uhd_ctrl_phase_zlp_in();
			}
		}
		return;
	}
	if (Is_uhd_in_received(0)) {
800045a6:	72 0c       	ld.w	r12,r9[0x0]
800045a8:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800045ac:	e0 80 00 b3 	breq	80004712 <otg_interrupt+0x44a>
		// In case of low USB speed and with a high CPU frequency,
		// a ACK from host can be always running on USB line
		// then wait end of ACK on IN pipe.
		while(!Is_uhd_pipe_frozen(0));
800045b0:	fe 69 05 c0 	mov	r9,-129600
800045b4:	72 08       	ld.w	r8,r9[0x0]
800045b6:	ed b8 00 11 	bld	r8,0x11
800045ba:	cf d1       	brne	800045b4 <otg_interrupt+0x2ec>

		// IN packet received
		uhd_ack_in_received(0);
800045bc:	fe 68 05 60 	mov	r8,-129696
800045c0:	30 19       	mov	r9,1
800045c2:	91 09       	st.w	r8[0x0],r9
		switch(uhd_ctrl_request_phase) {
800045c4:	e0 6c 2c 64 	mov	r12,11364
800045c8:	78 08       	ld.w	r8,r12[0x0]
800045ca:	58 28       	cp.w	r8,2
800045cc:	e0 80 01 16 	breq	800047f8 <otg_interrupt+0x530>
800045d0:	58 38       	cp.w	r8,3
800045d2:	fe 91 fe 87 	brne	800042e0 <otg_interrupt+0x18>
		case UHD_CTRL_REQ_PHASE_DATA_IN:
			uhd_ctrl_phase_data_in();
			break;
		case UHD_CTRL_REQ_PHASE_ZLP_IN:
			uhd_ctrl_request_end(UHD_TRANS_NOERROR);
800045d6:	30 0c       	mov	r12,0
800045d8:	fe b0 fb 42 	rcall	80003c5c <uhd_ctrl_request_end>
800045dc:	c8 2a       	rjmp	800042e0 <otg_interrupt+0x18>
			uhc_notify_resume();
		}
		return; // Abort SOF events
	}
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
800045de:	e0 68 2c 74 	mov	r8,11380
800045e2:	90 09       	ld.sh	r9,r8[0x0]
800045e4:	58 09       	cp.w	r9,0
800045e6:	c0 80       	breq	800045f6 <otg_interrupt+0x32e>
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
800045e8:	90 09       	ld.sh	r9,r8[0x0]
800045ea:	20 19       	sub	r9,1
800045ec:	b0 09       	st.h	r8[0x0],r9
800045ee:	90 08       	ld.sh	r8,r8[0x0]
800045f0:	58 08       	cp.w	r8,0
800045f2:	e0 80 01 84 	breq	800048fa <otg_interrupt+0x632>
			// Stop request
			uhd_freeze_pipe(0);
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
800045f6:	e0 67 06 48 	mov	r7,1608
800045fa:	30 08       	mov	r8,0
800045fc:	f0 c6 ff ff 	sub	r6,r8,-1
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
80004600:	6e 09       	ld.w	r9,r7[0x0]
80004602:	58 09       	cp.w	r9,0
80004604:	c0 b4       	brge	8000461a <otg_interrupt+0x352>
			if (ptr_job->timeout) {
80004606:	8e 19       	ld.sh	r9,r7[0x2]
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004608:	f2 ca 00 01 	sub	r10,r9,1
8000460c:	5c 8a       	casts.h	r10
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
		ptr_job = &uhd_pipe_job[pipe-1];
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
8000460e:	58 09       	cp.w	r9,0
80004610:	c0 50       	breq	8000461a <otg_interrupt+0x352>
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
80004612:	ae 1a       	st.h	r7[0x2],r10
80004614:	58 0a       	cp.w	r10,0
80004616:	e0 80 00 a7 	breq	80004764 <otg_interrupt+0x49c>
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
8000461a:	0c 98       	mov	r8,r6
8000461c:	2e c7       	sub	r7,-20
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
		}
	}
	// Manage the timeouts on endpoint transfer
	uhd_pipe_job_t *ptr_job;
	for (uint8_t pipe = 1; pipe < AVR32_USBB_EPT_NUM; pipe++) {
8000461e:	58 66       	cp.w	r6,6
80004620:	ce e1       	brne	800045fc <otg_interrupt+0x334>
				}
			}
		}
	}
	// Notify the UHC
	uhc_notify_sof(false);
80004622:	30 0c       	mov	r12,0
80004624:	e0 a0 02 e8 	rcall	80004bf4 <uhc_notify_sof>

	// Notify the user application
	UHC_SOF_EVENT();
80004628:	e0 a0 17 93 	rcall	8000754e <usb_sof>
8000462c:	fe 9f fe 5a 	bral	800042e0 <otg_interrupt+0x18>
		}
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
80004630:	74 0a       	ld.w	r10,r10[0x0]
80004632:	ed ba 00 01 	bld	r10,0x1
80004636:	c0 81       	brne	80004646 <otg_interrupt+0x37e>
80004638:	fe 6a 04 10 	mov	r10,-130032
8000463c:	74 0a       	ld.w	r10,r10[0x0]
8000463e:	ed ba 00 01 	bld	r10,0x1
80004642:	e0 80 01 a3 	breq	80004988 <otg_interrupt+0x6c0>
		uhd_suspend_start = 0;
		uhd_resume_start = 0;
		uhc_notify_connection(false);
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
80004646:	fe 68 04 04 	mov	r8,-130044
8000464a:	70 08       	ld.w	r8,r8[0x0]
8000464c:	ed b8 00 00 	bld	r8,0x0
80004650:	c0 81       	brne	80004660 <otg_interrupt+0x398>
80004652:	fe 68 04 10 	mov	r8,-130032
80004656:	70 08       	ld.w	r8,r8[0x0]
80004658:	ed b8 00 00 	bld	r8,0x0
8000465c:	e0 80 01 7b 	breq	80004952 <otg_interrupt+0x68a>
		uhc_notify_connection(true);
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
80004660:	fe 69 08 04 	mov	r9,-129020
80004664:	72 08       	ld.w	r8,r9[0x0]
80004666:	ed b8 00 03 	bld	r8,0x3
8000466a:	e0 80 01 40 	breq	800048ea <otg_interrupt+0x622>
		UHC_VBUS_ERROR();
		return;
	}

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
8000466e:	72 08       	ld.w	r8,r9[0x0]
80004670:	ed b8 00 0e 	bld	r8,0xe
80004674:	cf d1       	brne	8000466e <otg_interrupt+0x3a6>
	otg_unfreeze_clock();
80004676:	fe 69 08 00 	mov	r9,-129024
8000467a:	72 08       	ld.w	r8,r9[0x0]
8000467c:	af c8       	cbr	r8,0xe
8000467e:	93 08       	st.w	r9[0x0],r8

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
80004680:	fe 68 04 10 	mov	r8,-130032
80004684:	70 08       	ld.w	r8,r8[0x0]
80004686:	ed b8 00 06 	bld	r8,0x6
8000468a:	e0 81 00 88 	brne	8000479a <otg_interrupt+0x4d2>
8000468e:	fe 68 04 04 	mov	r8,-130044
80004692:	70 09       	ld.w	r9,r8[0x0]
80004694:	ed b9 00 06 	bld	r9,0x6
80004698:	c0 90       	breq	800046aa <otg_interrupt+0x3e2>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
8000469a:	70 09       	ld.w	r9,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
8000469c:	ed b9 00 03 	bld	r9,0x3
800046a0:	c0 50       	breq	800046aa <otg_interrupt+0x3e2>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
800046a2:	70 08       	ld.w	r8,r8[0x0]

	// Check USB clock ready after asynchronous interrupt
	while (!Is_otg_clock_usable());
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
800046a4:	ed b8 00 04 	bld	r8,0x4
800046a8:	c7 91       	brne	8000479a <otg_interrupt+0x4d2>
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
800046aa:	fe 68 00 00 	mov	r8,-131072
800046ae:	35 89       	mov	r9,88
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800046b0:	fe 6a 04 00 	mov	r10,-130048
	otg_unfreeze_clock();

	if (Is_uhd_wakeup_interrupt_enabled() && (Is_uhd_wakeup() ||
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
800046b4:	f1 49 04 14 	st.w	r8[1044],r9
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800046b8:	74 08       	ld.w	r8,r10[0x0]
800046ba:	a9 a8       	sbr	r8,0x8
		if ((!Is_uhd_downstream_resume())
800046bc:	fe 69 04 04 	mov	r9,-130044
			Is_uhd_downstream_resume() || Is_uhd_upstream_resume())) {
		// Disable wakeup/resumes interrupts
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_enable_sof();
800046c0:	95 08       	st.w	r10[0x0],r8
		if ((!Is_uhd_downstream_resume())
800046c2:	72 08       	ld.w	r8,r9[0x0]
				&&(!Is_uhd_disconnection())) {
800046c4:	ed b8 00 03 	bld	r8,0x3
800046c8:	f3 f8 10 00 	ld.wne	r8,r9[0x0]
			if (Is_uhd_high_speed_mode()) {
				uhd_send_resume();
			}
		}
		// Wait 50ms before restarting transfer
		uhd_resume_start = 50;
800046cc:	e0 68 06 c2 	mov	r8,1730
800046d0:	33 29       	mov	r9,50
800046d2:	b0 89       	st.b	r8[0x0],r9
800046d4:	fe 9f fe 06 	bral	800042e0 <otg_interrupt+0x18>
		uhd_disable_bank_interrupt(pipe);
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
		return;
	}
	if (Is_uhd_out_ready_interrupt_enabled(pipe) && Is_uhd_out_ready(pipe)) {
		uhd_disable_out_ready_interrupt(pipe);
800046d8:	30 2a       	mov	r10,2
800046da:	fe 6c 06 20 	mov	r12,-129504
800046de:	f0 0c 00 09 	add	r9,r8,r12
800046e2:	93 0a       	st.w	r9[0x0],r10
		// One bank is free then send a ZLP
		uhd_ack_out_ready(pipe);
800046e4:	fe 6c 05 60 	mov	r12,-129696
800046e8:	f0 0c 00 0b 	add	r11,r8,r12
800046ec:	97 0a       	st.w	r11[0x0],r10
		uhd_ack_fifocon(pipe);
800046ee:	e0 6a 40 00 	mov	r10,16384
800046f2:	93 0a       	st.w	r9[0x0],r10
		uhd_unfreeze_pipe(pipe);
800046f4:	e2 6a 00 00 	mov	r10,131072
800046f8:	93 0a       	st.w	r9[0x0],r10
		uhd_enable_bank_interrupt(pipe);
800046fa:	e0 38 fa 10 	sub	r8,129552
800046fe:	e0 69 10 00 	mov	r9,4096
80004702:	91 09       	st.w	r8[0x0],r9
80004704:	fe 9f fd ee 	bral	800042e0 <otg_interrupt+0x18>
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
80004708:	fe c9 96 f4 	sub	r9,pc,-26892
8000470c:	f2 08 03 2b 	ld.w	r11,r9[r8<<0x2]
80004710:	cb ca       	rjmp	80004488 <otg_interrupt+0x1c0>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_out_ready(0)) {
80004712:	72 08       	ld.w	r8,r9[0x0]
80004714:	ed b8 00 01 	bld	r8,0x1
80004718:	c5 a1       	brne	800047cc <otg_interrupt+0x504>
		// OUT packet sent
		uhd_freeze_pipe(0);
8000471a:	e2 69 00 00 	mov	r9,131072
8000471e:	fe 68 05 f0 	mov	r8,-129552
80004722:	91 09       	st.w	r8[0x0],r9
		uhd_ack_out_ready(0);
80004724:	fe 68 05 60 	mov	r8,-129696
80004728:	30 29       	mov	r9,2
8000472a:	91 09       	st.w	r8[0x0],r9
		switch(uhd_ctrl_request_phase) {
8000472c:	e0 68 2c 64 	mov	r8,11364
80004730:	70 08       	ld.w	r8,r8[0x0]
80004732:	58 18       	cp.w	r8,1
80004734:	c2 f0       	breq	80004792 <otg_interrupt+0x4ca>
80004736:	58 48       	cp.w	r8,4
80004738:	fe 91 fd d4 	brne	800042e0 <otg_interrupt+0x18>
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
		// Get and ack error
		uhd_ctrl_request_end(uhd_pipe_get_error(0));
8000473c:	fe b0 fa 90 	rcall	80003c5c <uhd_ctrl_request_end>
80004740:	fe 9f fd d0 	bral	800042e0 <otg_interrupt+0x18>
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
80004744:	fe 6a 05 60 	mov	r10,-129696
80004748:	f0 0a 00 09 	add	r9,r8,r10
8000474c:	34 0a       	mov	r10,64
		uhd_reset_data_toggle(pipe);
8000474e:	e0 38 fa 10 	sub	r8,129552
		uhd_unfreeze_pipe(pipe);
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
80004752:	93 0a       	st.w	r9[0x0],r10
		uhd_reset_data_toggle(pipe);
80004754:	e4 69 00 00 	mov	r9,262144
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
80004758:	30 4b       	mov	r11,4
		uhd_enable_bank_interrupt(pipe);
		return;
	}
	if (Is_uhd_stall(pipe)) {
		uhd_ack_stall(pipe);
		uhd_reset_data_toggle(pipe);
8000475a:	91 09       	st.w	r8[0x0],r9
		uhd_ep_abort_pipe(pipe, UHD_TRANS_STALL);
8000475c:	fe b0 f9 2c 	rcall	800039b4 <uhd_ep_abort_pipe>
80004760:	fe 9f fd c0 	bral	800042e0 <otg_interrupt+0x18>
		if (ptr_job->busy == true) {
			if (ptr_job->timeout) {
				// Timeout enabled on this job
				if (--ptr_job->timeout == 0) {
					// Abort job
					uhd_ep_abort_pipe(pipe,UHD_TRANS_TIMEOUT);
80004764:	f0 c6 ff ff 	sub	r6,r8,-1
80004768:	30 7b       	mov	r11,7
8000476a:	0c 9c       	mov	r12,r6
8000476c:	fe b0 f9 24 	rcall	800039b4 <uhd_ep_abort_pipe>
80004770:	c5 5b       	rjmp	8000461a <otg_interrupt+0x352>
	}

	if (uhd_is_pipe_out(pipe)) {
		// Wait that all banks are free to freeze clock of OUT endpoint
		// and call callback
		uhd_enable_bank_interrupt(pipe);
80004772:	e0 3a fa 10 	sub	r10,129552
80004776:	e0 68 10 00 	mov	r8,4096
8000477a:	95 08       	st.w	r10[0x0],r8
8000477c:	fe 9f fd b2 	bral	800042e0 <otg_interrupt+0x18>
 * \param pipe  Pipe number
 */
static void uhd_pipe_interrupt(uint8_t pipe)
{
	if (Is_uhd_bank_interrupt_enabled(pipe) && (0==uhd_nb_busy_bank(pipe))) {
		uhd_disable_bank_interrupt(pipe);
80004780:	e0 38 f9 e0 	sub	r8,129504
80004784:	e0 69 10 00 	mov	r9,4096
80004788:	91 09       	st.w	r8[0x0],r9
		uhd_pipe_finish_job(pipe, UHD_TRANS_NOERROR);
8000478a:	fe b0 f8 d7 	rcall	80003938 <uhd_pipe_finish_job>
8000478e:	fe 9f fd a9 	bral	800042e0 <otg_interrupt+0x18>
		// OUT packet sent
		uhd_freeze_pipe(0);
		uhd_ack_out_ready(0);
		switch(uhd_ctrl_request_phase) {
		case UHD_CTRL_REQ_PHASE_DATA_OUT:
			uhd_ctrl_phase_data_out();
80004792:	fe b0 f7 d9 	rcall	80003744 <uhd_ctrl_phase_data_out>
80004796:	fe 9f fd a5 	bral	800042e0 <otg_interrupt+0x18>
		uhd_sleep_mode(UHD_STATE_IDLE);
		return;
	}

	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
8000479a:	fe 69 08 04 	mov	r9,-129020
8000479e:	72 08       	ld.w	r8,r9[0x0]
800047a0:	ed b8 00 01 	bld	r8,0x1
800047a4:	fe 91 fd 9e 	brne	800042e0 <otg_interrupt+0x18>
		otg_ack_vbus_transition();
800047a8:	30 2a       	mov	r10,2
800047aa:	fe 68 08 08 	mov	r8,-129016
800047ae:	91 0a       	st.w	r8[0x0],r10
		if (Is_otg_vbus_high()) {
800047b0:	72 0c       	ld.w	r12,r9[0x0]
800047b2:	e2 1c 08 00 	andl	r12,0x800,COH
800047b6:	e0 81 00 c9 	brne	80004948 <otg_interrupt+0x680>
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
		} else {
			uhd_sleep_mode(UHD_STATE_NO_VBUS);
			otg_freeze_clock();
800047ba:	fe 69 08 00 	mov	r9,-129024
800047be:	72 08       	ld.w	r8,r9[0x0]
800047c0:	af a8       	sbr	r8,0xe
800047c2:	93 08       	st.w	r9[0x0],r8
			UHC_VBUS_CHANGE(false);
800047c4:	e0 a0 16 c1 	rcall	80007546 <usb_vbus_change>
800047c8:	fe 9f fd 8c 	bral	800042e0 <otg_interrupt+0x18>
			Assert(false);
			break;
		}
		return;
	}
	if (Is_uhd_stall(0)) {
800047cc:	72 08       	ld.w	r8,r9[0x0]
800047ce:	e2 18 00 40 	andl	r8,0x40,COH
800047d2:	e0 81 00 fe 	brne	800049ce <otg_interrupt+0x706>
		// Stall Handshake received
		uhd_ack_stall(0);
		uhd_ctrl_request_end(UHD_TRANS_STALL);
		return;
	}
	if (Is_uhd_pipe_error(0)) {
800047d6:	72 09       	ld.w	r9,r9[0x0]
800047d8:	ed b9 00 03 	bld	r9,0x3
800047dc:	fe 91 fd 82 	brne	800042e0 <otg_interrupt+0x18>
 *
 * \return UHD transfer error
 */
static uhd_trans_status_t uhd_pipe_get_error(uint8_t pipe)
{
	uint32_t error = uhd_error_status(pipe) &
800047e0:	fe 69 06 80 	mov	r9,-129408
800047e4:	72 0a       	ld.w	r10,r9[0x0]
			(AVR32_USBB_UPERR0_DATATGL_MASK |
			AVR32_USBB_UPERR0_TIMEOUT_MASK |
			AVR32_USBB_UPERR0_PID_MASK |
			AVR32_USBB_UPERR0_DATAPID_MASK);
	uhd_ack_all_errors(pipe);
800047e6:	93 08       	st.w	r9[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
800047e8:	f1 da c0 04 	bfextu	r8,r10,0x0,0x4
800047ec:	20 18       	sub	r8,1
800047ee:	58 28       	cp.w	r8,2
800047f0:	e0 88 00 ea 	brls	800049c4 <otg_interrupt+0x6fc>
800047f4:	30 6c       	mov	r12,6
800047f6:	ca 3b       	rjmp	8000473c <otg_interrupt+0x474>
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
800047f8:	fe 68 05 30 	mov	r8,-129744
800047fc:	e0 64 2c 68 	mov	r4,11368
	//! In HUB mode, the control pipe is always configured to 64B
	//! thus the short packet flag must be computed
	b_short_packet = (nb_byte_received != uhd_get_pipe_size(0));
	uhd_ack_short_packet(0);
#else
	b_short_packet = Is_uhd_short_packet(0);
80004800:	70 06       	ld.w	r6,r8[0x0]
80004802:	fc 12 e0 00 	movh	r2,0xe000
	bool b_short_packet;
	uint8_t *ptr_ep_data;
	uint8_t nb_byte_received;

	// Get information to read data
	nb_byte_received = uhd_byte_count(0);
80004806:	70 08       	ld.w	r8,r8[0x0]
80004808:	ed d6 c2 88 	bfextu	r6,r6,0x14,0x8
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
8000480c:	50 08       	stdsp	sp[0x0],r8
8000480e:	08 91       	mov	r1,r4
80004810:	30 07       	mov	r7,0
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
80004812:	30 05       	mov	r5,0
80004814:	e0 63 2c 6c 	mov	r3,11372

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
80004818:	fe 60 04 24 	mov	r0,-130012
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
8000481c:	68 0a       	ld.w	r10,r4[0x0]
8000481e:	ee 06 18 00 	cp.b	r6,r7
80004822:	5f 18       	srne	r8
80004824:	f5 09 00 10 	ld.sh	r9,r10[16]
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
80004828:	ec ce 00 01 	sub	lr,r6,1
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
8000482c:	ea 09 19 00 	cp.h	r9,r5
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
80004830:	5f 1c       	srne	r12
80004832:	f4 cb ff f4 	sub	r11,r10,-12
#endif

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
80004836:	f1 ec 00 0c 	and	r12,r8,r12
8000483a:	ee 0c 18 00 	cp.b	r12,r7
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
8000483e:	c2 d1       	brne	80004898 <otg_interrupt+0x5d0>
80004840:	ea 09 19 00 	cp.h	r9,r5
80004844:	5f 09       	sreq	r9
80004846:	12 68       	and	r8,r9
80004848:	ee 08 18 00 	cp.b	r8,r7
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
				|| !uhd_ctrl_request_first->callback_run(
8000484c:	c6 10       	breq	8000490e <otg_interrupt+0x646>
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
8000484e:	74 58       	ld.w	r8,r10[0x14]
80004850:	58 08       	cp.w	r8,0
				|| !uhd_ctrl_request_first->callback_run(
				uhd_get_configured_address(0),
80004852:	c0 70       	breq	80004860 <otg_interrupt+0x598>
		nb_byte_received--;
	}

	if (!uhd_ctrl_request_first->payload_size && nb_byte_received) {
		// payload buffer is full to store data remaining
		if (uhd_ctrl_request_first->callback_run == NULL
80004854:	60 0c       	ld.w	r12,r0[0x0]
80004856:	2f 0a       	sub	r10,-16
80004858:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000485c:	5d 18       	icall	r8
 * \brief Starts the ZLP OUT phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_out(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
8000485e:	cd f1       	brne	8000481c <otg_interrupt+0x554>
80004860:	fe 69 05 00 	mov	r9,-129792
80004864:	72 08       	ld.w	r8,r9[0x0]
80004866:	e0 18 fc ff 	andl	r8,0xfcff
8000486a:	a9 b8       	sbr	r8,0x9
	uhd_ack_out_ready(0);
8000486c:	93 08       	st.w	r9[0x0],r8
8000486e:	30 28       	mov	r8,2
80004870:	fe 69 05 60 	mov	r9,-129696
	uhd_enable_out_ready_interrupt(0);
80004874:	93 08       	st.w	r9[0x0],r8
80004876:	fe 69 05 f0 	mov	r9,-129552
	uhd_ack_fifocon(0);
8000487a:	93 08       	st.w	r9[0x0],r8
8000487c:	fe 68 06 20 	mov	r8,-129504
80004880:	e0 69 40 00 	mov	r9,16384
 * \internal
 * \brief Starts the ZLP OUT phase on control endpoint
 */
static void uhd_ctrl_phase_zlp_out(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
80004884:	91 09       	st.w	r8[0x0],r9
80004886:	e0 6a 2c 64 	mov	r10,11364
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_OUT);
	uhd_ack_out_ready(0);
	uhd_enable_out_ready_interrupt(0);
	uhd_ack_fifocon(0);
	uhd_unfreeze_pipe(0);
8000488a:	30 49       	mov	r9,4
8000488c:	95 09       	st.w	r10[0x0],r9
8000488e:	e2 69 00 00 	mov	r9,131072
80004892:	91 09       	st.w	r8[0x0],r9

	ptr_ep_data = (uint8_t *) & uhd_get_pipe_fifo_access(0, 8);
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
80004894:	fe 9f fd 26 	bral	800042e0 <otg_interrupt+0x18>
80004898:	05 39       	ld.ub	r9,r2++
8000489a:	74 38       	ld.w	r8,r10[0xc]
		uhd_ctrl_nb_trans++;
8000489c:	10 c9       	st.b	r8++,r9
8000489e:	95 38       	st.w	r10[0xc],r8
800048a0:	86 08       	ld.sh	r8,r3[0x0]
		uhd_ctrl_request_first->payload_size--;
		nb_byte_received--;
800048a2:	2f f8       	sub	r8,-1
800048a4:	a6 08       	st.h	r3[0x0],r8
uhd_ctrl_receiv_in_read_data:
	// Copy data from pipe to payload buffer
	while (uhd_ctrl_request_first->payload_size && nb_byte_received) {
		*uhd_ctrl_request_first->payload++ = *ptr_ep_data++;
		uhd_ctrl_nb_trans++;
		uhd_ctrl_request_first->payload_size--;
800048a6:	ed de c0 08 	bfextu	r6,lr,0x0,0x8
800048aa:	62 08       	ld.w	r8,r1[0x0]
800048ac:	f1 09 00 10 	ld.sh	r9,r8[16]
800048b0:	20 19       	sub	r9,1
800048b2:	f1 59 00 10 	st.h	r8[16],r9
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
	uhd_configure_pipe_token(0, AVR32_USBB_PTOKEN_IN);
800048b6:	cb 3b       	rjmp	8000481c <otg_interrupt+0x554>
800048b8:	fe 6c 05 00 	mov	r12,-129792
800048bc:	78 09       	ld.w	r9,r12[0x0]
800048be:	e0 19 fc ff 	andl	r9,0xfcff
	uhd_ack_in_received(0);
800048c2:	a9 a9       	sbr	r9,0x8
800048c4:	99 09       	st.w	r12[0x0],r9
	uhd_ack_short_packet(0);
800048c6:	30 19       	mov	r9,1
800048c8:	91 09       	st.w	r8[0x0],r9
800048ca:	e0 6c 00 80 	mov	r12,128
	uhd_enable_in_received_interrupt(0);
	uhd_ack_fifocon(0);
800048ce:	91 0c       	st.w	r8[0x0],r12
800048d0:	97 09       	st.w	r11[0x0],r9
800048d2:	fe 68 06 20 	mov	r8,-129504
800048d6:	e0 69 40 00 	mov	r9,16384
 * \internal
 * \brief Starts the DATA IN phase on control endpoint
 */
static void uhd_ctrl_phase_data_in_start(void)
{
	uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
800048da:	91 09       	st.w	r8[0x0],r9
800048dc:	91 0a       	st.w	r8[0x0],r10
800048de:	30 29       	mov	r9,2
800048e0:	e0 68 2c 64 	mov	r8,11364
		return;
	}

	// Manage Vbus error
	if (Is_uhd_vbus_error_interrupt()) {
		uhd_ack_vbus_error_interrupt();
800048e4:	91 09       	st.w	r8[0x0],r9
800048e6:	fe 9f fc fd 	bral	800042e0 <otg_interrupt+0x18>
800048ea:	30 89       	mov	r9,8
		UHC_VBUS_ERROR();
800048ec:	fe 68 08 08 	mov	r8,-129016
800048f0:	91 09       	st.w	r8[0x0],r9
800048f2:	e0 a0 16 2b 	rcall	80007548 <usb_vbus_error>
	// Manage the timeout on endpoint control transfer
	if (uhd_ctrl_request_timeout) {
		// Setup request on-going
		if (--uhd_ctrl_request_timeout == 0) {
			// Stop request
			uhd_freeze_pipe(0);
800048f6:	fe 9f fc f5 	bral	800042e0 <otg_interrupt+0x18>
800048fa:	e2 69 00 00 	mov	r9,131072
800048fe:	fe 68 05 f0 	mov	r8,-129552
			uhd_ctrl_request_end(UHD_TRANS_TIMEOUT);
80004902:	30 7c       	mov	r12,7
80004904:	91 09       	st.w	r8[0x0],r9
80004906:	fe b0 f9 ab 	rcall	80003c5c <uhd_ctrl_request_end>
		// thus the data load can restart.
		goto uhd_ctrl_receiv_in_read_data;
	}

	// Test short packet
	if ((uhd_ctrl_nb_trans == uhd_ctrl_request_first->req.wLength)
8000490a:	fe 9f fe 76 	bral	800045f6 <otg_interrupt+0x32e>
8000490e:	15 f9       	ld.ub	r9,r10[0x7]
80004910:	f5 38 00 08 	ld.ub	r8,r10[8]
80004914:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004918:	e0 69 2c 6c 	mov	r9,11372
8000491c:	92 09       	ld.sh	r9,r9[0x0]
8000491e:	f0 09 19 00 	cp.h	r9,r8
80004922:	c9 f0       	breq	80004860 <otg_interrupt+0x598>
		uhd_ctrl_phase_zlp_out();
		return;
	}

	// Send a new IN packet request
	uhd_enable_in_received_interrupt(0);
80004924:	40 08       	lddsp	r8,sp[0x0]
80004926:	ed b8 00 07 	bld	r8,0x7
8000492a:	c9 b0       	breq	80004860 <otg_interrupt+0x598>
	uhd_ack_fifocon(0);
8000492c:	30 19       	mov	r9,1
8000492e:	fe 68 05 f0 	mov	r8,-129552
80004932:	91 09       	st.w	r8[0x0],r9
80004934:	fe 68 06 20 	mov	r8,-129504
	uhd_unfreeze_pipe(0);
80004938:	e0 69 40 00 	mov	r9,16384
8000493c:	91 09       	st.w	r8[0x0],r9
8000493e:	e2 69 00 00 	mov	r9,131072
	// Manage Vbus state change
	if (Is_otg_vbus_transition()) {
		otg_ack_vbus_transition();
		if (Is_otg_vbus_high()) {
			uhd_sleep_mode(UHD_STATE_DISCONNECT);
			UHC_VBUS_CHANGE(true);
80004942:	91 09       	st.w	r8[0x0],r9
80004944:	fe 9f fc ce 	bral	800042e0 <otg_interrupt+0x18>
80004948:	30 1c       	mov	r12,1
		uhd_resume_start = 0;
		uhc_notify_connection(false);
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
8000494a:	e0 a0 15 fe 	rcall	80007546 <usb_vbus_change>
8000494e:	fe 9f fc c9 	bral	800042e0 <otg_interrupt+0x18>
		uhd_disable_connection_int();
80004952:	fe 68 04 08 	mov	r8,-130040
80004956:	30 1c       	mov	r12,1
		uhd_enable_disconnection_int();
80004958:	91 0c       	st.w	r8[0x0],r12
8000495a:	fe 68 04 14 	mov	r8,-130028
		uhd_enable_sof();
8000495e:	91 0c       	st.w	r8[0x0],r12
		return;
	}
	if (Is_uhd_connection() && Is_uhd_connection_int_enabled()) {
		uhd_ack_connection();
		uhd_disable_connection_int();
		uhd_enable_disconnection_int();
80004960:	fe 68 04 18 	mov	r8,-130024
		uhd_enable_sof();
80004964:	fe 6a 04 00 	mov	r10,-130048
80004968:	30 29       	mov	r9,2
		uhd_sleep_mode(UHD_STATE_IDLE);
		uhd_suspend_start = 0;
8000496a:	91 09       	st.w	r8[0x0],r9
8000496c:	74 08       	ld.w	r8,r10[0x0]
8000496e:	a9 a8       	sbr	r8,0x8
		uhd_resume_start = 0;
80004970:	95 08       	st.w	r10[0x0],r8
80004972:	e0 68 06 c0 	mov	r8,1728
		uhc_notify_connection(true);
80004976:	30 09       	mov	r9,0
80004978:	b0 89       	st.b	r8[0x0],r9
8000497a:	e0 68 06 c2 	mov	r8,1730
		return;
	}

	// Manage dis/connection event
	if (Is_uhd_disconnection() && Is_uhd_disconnection_int_enabled()) {
		uhd_ack_disconnection();
8000497e:	b0 89       	st.b	r8[0x0],r9
80004980:	e0 a0 04 c0 	rcall	80005300 <uhc_notify_connection>
		uhd_disable_disconnection_int();
80004984:	fe 9f fc ae 	bral	800042e0 <otg_interrupt+0x18>
80004988:	30 2a       	mov	r10,2
		// Stop reset signal, in case of disconnection during reset
		uhd_stop_reset();
8000498a:	fe 6b 04 08 	mov	r11,-130040
8000498e:	97 0a       	st.w	r11[0x0],r10
80004990:	fe 6b 04 14 	mov	r11,-130028
		// Disable wakeup/resumes interrupts,
		// in case of disconnection during suspend mode
		AVR32_USBB.uhinteclr = AVR32_USBB_UHINTECLR_HWUPIEC_MASK
80004994:	97 0a       	st.w	r11[0x0],r10
80004996:	fe 6b 04 00 	mov	r11,-130048
				| AVR32_USBB_UHINTECLR_RSMEDIEC_MASK
				| AVR32_USBB_UHINTECLR_RXRSMIEC_MASK;
		uhd_sleep_mode(UHD_STATE_DISCONNECT);
		uhd_enable_connection_int();
8000499a:	76 0a       	ld.w	r10,r11[0x0]
8000499c:	a9 da       	cbr	r10,0x9
8000499e:	97 0a       	st.w	r11[0x0],r10
800049a0:	35 8a       	mov	r10,88
		uhd_suspend_start = 0;
800049a2:	f3 4a 04 14 	st.w	r9[1044],r10
		uhd_resume_start = 0;
800049a6:	fe 69 04 18 	mov	r9,-130024
800049aa:	30 1a       	mov	r10,1
		uhc_notify_connection(false);
800049ac:	93 0a       	st.w	r9[0x0],r10
800049ae:	e0 69 06 c0 	mov	r9,1728
800049b2:	b2 88       	st.b	r9[0x0],r8
		return; // No callback linked to job
	}
	ptr_job->call_end(uhd_get_configured_address(pipe),
			uhd_get_pipe_endpoint_address(pipe),
			status, ptr_job->nb_trans);
}
800049b4:	e0 69 06 c2 	mov	r9,1730
800049b8:	10 9c       	mov	r12,r8
800049ba:	b2 88       	st.b	r9[0x0],r8
		}
		return;
	}
	if (Is_uhd_stall(0)) {
		// Stall Handshake received
		uhd_ack_stall(0);
800049bc:	e0 a0 04 a2 	rcall	80005300 <uhc_notify_connection>
800049c0:	fe 9f fc 90 	bral	800042e0 <otg_interrupt+0x18>
800049c4:	fe c9 99 b0 	sub	r9,pc,-26192
		uhd_ctrl_request_end(UHD_TRANS_STALL);
800049c8:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
800049cc:	cb 8a       	rjmp	8000473c <otg_interrupt+0x474>
800049ce:	34 09       	mov	r9,64
800049d0:	fe 68 05 60 	mov	r8,-129696
800049d4:	30 4c       	mov	r12,4
800049d6:	91 09       	st.w	r8[0x0],r9
800049d8:	fe b0 f9 42 	rcall	80003c5c <uhd_ctrl_request_end>
800049dc:	fe 9f fc 82 	bral	800042e0 <otg_interrupt+0x18>

800049e0 <osc_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800049e0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800049e4:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint32_t   oscctrl;

	flags = cpu_irq_save();

	switch (id) {
800049e6:	58 0c       	cp.w	r12,0
800049e8:	c0 f0       	breq	80004a06 <osc_enable+0x26>
800049ea:	30 29       	mov	r9,2
800049ec:	f2 0c 18 00 	cp.b	r12,r9
800049f0:	c0 61       	brne	800049fc <osc_enable+0x1c>
	case OSC_ID_OSC32:
		oscctrl = OSC32_STARTUP_VALUE
				<< AVR32_PM_OSCCTRL32_STARTUP_OFFSET;
		oscctrl |= OSC32_MODE_VALUE << AVR32_PM_OSCCTRL32_MODE_OFFSET;
		oscctrl |= 1 << AVR32_PM_OSCCTRL32_OSC32EN_OFFSET;
		AVR32_PM.oscctrl32 = oscctrl;
800049f2:	e2 6a 01 01 	mov	r10,131329
800049f6:	fe 79 0c 00 	mov	r9,-62464
800049fa:	93 ca       	st.w	r9[0x30],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800049fc:	ed b8 00 10 	bld	r8,0x10
80004a00:	c0 20       	breq	80004a04 <osc_enable+0x24>
      cpu_irq_enable();
80004a02:	d5 03       	csrf	0x10
		/* unhandled_case(id); */
		break;
	}

	cpu_irq_restore(flags);
}
80004a04:	5e fc       	retal	r12
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
80004a06:	fe 79 0c 00 	mov	r9,-62464
80004a0a:	e0 6a 03 07 	mov	r10,775
80004a0e:	93 aa       	st.w	r9[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80004a10:	72 0a       	ld.w	r10,r9[0x0]
80004a12:	a3 aa       	sbr	r10,0x2
80004a14:	93 0a       	st.w	r9[0x0],r10
		break;
80004a16:	cf 3b       	rjmp	800049fc <osc_enable+0x1c>

80004a18 <sysclk_priv_disable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004a18:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80004a1c:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80004a1e:	fe 79 0c 00 	mov	r9,-62464
80004a22:	73 58       	ld.w	r8,r9[0x54]
80004a24:	ed b8 00 06 	bld	r8,0x6
80004a28:	cf d1       	brne	80004a22 <sysclk_priv_disable_module+0xa>
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80004a2a:	a3 6c       	lsl	r12,0x2
	mask &= ~(1U << module_index);
80004a2c:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80004a2e:	e0 2c f3 f8 	sub	r12,62456
	mask &= ~(1U << module_index);
80004a32:	f0 0b 09 48 	lsl	r8,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Disable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80004a36:	78 09       	ld.w	r9,r12[0x0]
	mask &= ~(1U << module_index);
80004a38:	5c d8       	com	r8
80004a3a:	12 68       	and	r8,r9
	*(&AVR32_PM.cpumask + bus_id) = mask;
80004a3c:	99 08       	st.w	r12[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004a3e:	ed ba 00 10 	bld	r10,0x10
80004a42:	c0 20       	breq	80004a46 <sysclk_priv_disable_module+0x2e>
      cpu_irq_enable();
80004a44:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004a46:	5e fc       	retal	r12

80004a48 <sysclk_disable_pbb_module>:
/**
 * \brief Disable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_disable_pbb_module(unsigned int index)
{
80004a48:	eb cd 40 80 	pushm	r7,lr
	irqflags_t flags;

	/* Disable the module */
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_PBB, index);
80004a4c:	18 9b       	mov	r11,r12
80004a4e:	30 3c       	mov	r12,3
80004a50:	ce 4f       	rcall	80004a18 <sysclk_priv_disable_module>
80004a52:	e1 b7 00 00 	mfsr	r7,0x0

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004a56:	d3 03       	ssrf	0x10
	cpu_irq_disable();
80004a58:	e0 69 06 c4 	mov	r9,1732

	/* Disable the bridge if possible */
	flags = cpu_irq_save();

	sysclk_pbb_refcount--;
80004a5c:	13 88       	ld.ub	r8,r9[0x0]
80004a5e:	20 18       	sub	r8,1
80004a60:	5c 58       	castu.b	r8
80004a62:	b2 88       	st.b	r9[0x0],r8
	if (!sysclk_pbb_refcount)
80004a64:	c0 70       	breq	80004a72 <sysclk_disable_pbb_module+0x2a>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004a66:	e6 17 00 01 	andh	r7,0x1,COH
80004a6a:	c0 21       	brne	80004a6e <sysclk_disable_pbb_module+0x26>
      cpu_irq_enable();
80004a6c:	d5 03       	csrf	0x10
		sysclk_disable_hsb_module(SYSCLK_PBB_BRIDGE);

	cpu_irq_restore(flags);
}
80004a6e:	e3 cd 80 80 	ldm	sp++,r7,pc
 * \brief Disable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_disable_hsb_module(unsigned int index)
{
	sysclk_priv_disable_module(AVR32_PM_CLK_GRP_HSB, index);
80004a72:	30 2b       	mov	r11,2
80004a74:	30 1c       	mov	r12,1
80004a76:	cd 1f       	rcall	80004a18 <sysclk_priv_disable_module>
80004a78:	cf 7b       	rjmp	80004a66 <sysclk_disable_pbb_module+0x1e>
80004a7a:	d7 03       	nop

80004a7c <sysclk_disable_usb>:
80004a7c:	d4 01       	pushm	lr
80004a7e:	30 09       	mov	r9,0
80004a80:	fe 78 0c 00 	mov	r8,-62464
80004a84:	30 1c       	mov	r12,1
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
}

static inline void genclk_disable(unsigned int id)
{
	AVR32_PM.gcctrl[id] = 0;
80004a86:	f1 49 00 70 	st.w	r8[112],r9
80004a8a:	30 3b       	mov	r11,3
80004a8c:	cc 6f       	rcall	80004a18 <sysclk_priv_disable_module>
80004a8e:	30 1c       	mov	r12,1
 */
void sysclk_disable_usb(void)
{
	genclk_disable(AVR32_PM_GCLK_USBB);
	sysclk_disable_hsb_module(SYSCLK_USBB_DATA);
	sysclk_disable_pbb_module(SYSCLK_USBB_REGS);
80004a90:	cd cf       	rcall	80004a48 <sysclk_disable_pbb_module>
80004a92:	d8 02       	popm	pc

80004a94 <sysclk_priv_enable_module>:
80004a94:	e1 ba 00 00 	mfsr	r10,0x0
}
80004a98:	d3 03       	ssrf	0x10
80004a9a:	fe 79 0c 00 	mov	r9,-62464
80004a9e:	73 58       	ld.w	r8,r9[0x54]

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
80004aa0:	ed b8 00 06 	bld	r8,0x6
80004aa4:	cf d1       	brne	80004a9e <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
	mask |= 1U << module_index;
80004aa6:	30 18       	mov	r8,1
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80004aa8:	a3 6c       	lsl	r12,0x2
	mask |= 1U << module_index;
80004aaa:	f0 0b 09 4b 	lsl	r11,r8,r11
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80004aae:	e0 2c f3 f8 	sub	r12,62456
80004ab2:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
80004ab4:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
80004ab6:	99 0b       	st.w	r12[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004ab8:	ed ba 00 10 	bld	r10,0x10
80004abc:	c0 20       	breq	80004ac0 <sysclk_priv_enable_module+0x2c>
      cpu_irq_enable();
80004abe:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80004ac0:	5e fc       	retal	r12
80004ac2:	d7 03       	nop

80004ac4 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
80004ac4:	eb cd 40 e0 	pushm	r5-r7,lr
80004ac8:	18 96       	mov	r6,r12

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004aca:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
80004ace:	d3 03       	ssrf	0x10
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_pbb_refcount)
80004ad0:	e0 67 06 c4 	mov	r7,1732
80004ad4:	0f 88       	ld.ub	r8,r7[0x0]
80004ad6:	58 08       	cp.w	r8,0
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);

	sysclk_pbb_refcount++;
80004ad8:	c0 c0       	breq	80004af0 <sysclk_enable_pbb_module+0x2c>
80004ada:	2f f8       	sub	r8,-1
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004adc:	ae 88       	st.b	r7[0x0],r8
80004ade:	e6 15 00 01 	andh	r5,0x1,COH
      cpu_irq_enable();
80004ae2:	c0 21       	brne	80004ae6 <sysclk_enable_pbb_module+0x22>

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
80004ae4:	d5 03       	csrf	0x10
80004ae6:	30 3c       	mov	r12,3
80004ae8:	0c 9b       	mov	r11,r6
80004aea:	cd 5f       	rcall	80004a94 <sysclk_priv_enable_module>
}
80004aec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
80004af0:	30 2b       	mov	r11,2
80004af2:	30 1c       	mov	r12,1
80004af4:	cd 0f       	rcall	80004a94 <sysclk_priv_enable_module>
80004af6:	0f 88       	ld.ub	r8,r7[0x0]
80004af8:	cf 1b       	rjmp	80004ada <sysclk_enable_pbb_module+0x16>
80004afa:	d7 03       	nop

80004afc <sysclk_enable_usb>:
80004afc:	eb cd 40 80 	pushm	r7,lr
80004b00:	30 1c       	mov	r12,1
80004b02:	ce 1f       	rcall	80004ac4 <sysclk_enable_pbb_module>
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
80004b04:	30 3b       	mov	r11,3
80004b06:	30 1c       	mov	r12,1
80004b08:	cc 6f       	rcall	80004a94 <sysclk_priv_enable_module>
80004b0a:	fe 77 0c 00 	mov	r7,-62464

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004b0e:	6f 58       	ld.w	r8,r7[0x54]
80004b10:	ed b8 00 01 	bld	r8,0x1

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
80004b14:	c1 10       	breq	80004b36 <sysclk_enable_usb+0x3a>
80004b16:	6f 5c       	ld.w	r12,r7[0x54]
80004b18:	e2 1c 00 80 	andl	r12,0x80,COH

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80004b1c:	c1 40       	breq	80004b44 <sysclk_enable_usb+0x48>
80004b1e:	fe 78 0c 00 	mov	r8,-62464
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004b22:	e0 6a 02 0d 	mov	r10,525
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80004b26:	ea 1a 3f 0f 	orh	r10,0x3f0f
80004b2a:	10 99       	mov	r9,r8
80004b2c:	91 9a       	st.w	r8[0x24],r10

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004b2e:	73 58       	ld.w	r8,r9[0x54]
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004b30:	ed b8 00 01 	bld	r8,0x1
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80004b34:	cf d1       	brne	80004b2e <sysclk_enable_usb+0x32>
80004b36:	30 79       	mov	r9,7
80004b38:	fe 78 0c 00 	mov	r8,-62464
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80004b3c:	f1 49 00 70 	st.w	r8[112],r9
80004b40:	e3 cd 80 80 	ldm	sp++,r7,pc
	sysclk_enable_hsb_module(SYSCLK_USBB_DATA);
	genclk_enable_config(AVR32_PM_GCLK_USBB, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
}
80004b44:	c4 ef       	rcall	800049e0 <osc_enable>
80004b46:	6f 58       	ld.w	r8,r7[0x54]
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
80004b48:	ed b8 00 07 	bld	r8,0x7
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC0RDY));
80004b4c:	cf d1       	brne	80004b46 <sysclk_enable_usb+0x4a>
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80004b4e:	ce 8b       	rjmp	80004b1e <sysclk_enable_usb+0x22>

80004b50 <sysclk_init>:
80004b50:	eb cd 40 80 	pushm	r7,lr
80004b54:	fe 77 0c 00 	mov	r7,-62464
80004b58:	6f 58       	ld.w	r8,r7[0x54]
80004b5a:	ed b8 00 00 	bld	r8,0x0
80004b5e:	c1 10       	breq	80004b80 <sysclk_init+0x30>
80004b60:	6f 5c       	ld.w	r12,r7[0x54]
80004b62:	e2 1c 00 80 	andl	r12,0x80,COH

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80004b66:	c2 c0       	breq	80004bbe <sysclk_init+0x6e>
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004b68:	fe 78 0c 00 	mov	r8,-62464
		vco_hz *= 2;
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80004b6c:	e0 6a 02 05 	mov	r10,517
80004b70:	ea 1a 3f 0a 	orh	r10,0x3f0a

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004b74:	10 99       	mov	r9,r8
static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004b76:	91 8a       	st.w	r8[0x20],r10

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004b78:	73 58       	ld.w	r8,r9[0x54]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80004b7a:	ed b8 00 00 	bld	r8,0x0
80004b7e:	cf d1       	brne	80004b78 <sysclk_init+0x28>

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80004b80:	e0 6c 14 80 	mov	r12,5248
80004b84:	ea 1c 03 ef 	orh	r12,0x3ef
80004b88:	fe b0 ea 99 	rcall	800020ba <flashc_set_bus_freq>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004b8c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80004b90:	d3 03       	ssrf	0x10
	uint32_t   mcctrl;

	Assert(src <= SYSCLK_SRC_PLL0);

	flags = cpu_irq_save();
	mcctrl = AVR32_PM.mcctrl & ~AVR32_PM_MCCTRL_MCSEL_MASK;
80004b92:	fe 7a 0c 00 	mov	r10,-62464
80004b96:	74 08       	ld.w	r8,r10[0x0]
80004b98:	e0 18 ff fc 	andl	r8,0xfffc
	mcctrl |= src << AVR32_PM_MCCTRL_MCSEL;
80004b9c:	a1 b8       	sbr	r8,0x1
	AVR32_PM.mcctrl = mcctrl;
80004b9e:	95 08       	st.w	r10[0x0],r8
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004ba0:	ed b9 00 10 	bld	r9,0x10
80004ba4:	c0 20       	breq	80004ba8 <sysclk_init+0x58>
      cpu_irq_enable();
80004ba6:	d5 03       	csrf	0x10
	/* If the user has specified clock masks, enable only requested clocks */
#if defined(CONFIG_SYSCLK_INIT_CPUMASK)
	AVR32_PM.cpumask = SYSCLK_INIT_MINIMAL_CPUMASK | CONFIG_SYSCLK_INIT_CPUMASK;
#endif
#if defined(CONFIG_SYSCLK_INIT_PBAMASK)
	AVR32_PM.pbamask = SYSCLK_INIT_MINIMAL_PBAMASK | CONFIG_SYSCLK_INIT_PBAMASK;
80004ba8:	fe 78 0c 00 	mov	r8,-62464
80004bac:	e0 69 43 6f 	mov	r9,17263
80004bb0:	91 49       	st.w	r8[0x10],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_PBBMASK)
	AVR32_PM.pbbmask = SYSCLK_INIT_MINIMAL_PBBMASK | CONFIG_SYSCLK_INIT_PBBMASK;
80004bb2:	31 59       	mov	r9,21
80004bb4:	91 59       	st.w	r8[0x14],r9
#endif
#if defined(CONFIG_SYSCLK_INIT_HSBMASK)
	AVR32_PM.hsbmask = SYSCLK_INIT_MINIMAL_HSBMASK | CONFIG_SYSCLK_INIT_HSBMASK;
80004bb6:	36 39       	mov	r9,99
80004bb8:	91 39       	st.w	r8[0xc],r9

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80004bba:	e3 cd 80 80 	ldm	sp++,r7,pc
static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
80004bbe:	c1 1f       	rcall	800049e0 <osc_enable>
80004bc0:	6f 58       	ld.w	r8,r7[0x54]
80004bc2:	ed b8 00 07 	bld	r8,0x7
80004bc6:	cf d1       	brne	80004bc0 <sysclk_init+0x70>
80004bc8:	cd 0b       	rjmp	80004b68 <sysclk_init+0x18>
80004bca:	d7 03       	nop

80004bcc <uhc_enumeration_step2>:
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80004bcc:	fe c9 ff 14 	sub	r9,pc,-236
80004bd0:	e0 68 06 e8 	mov	r8,1768
  uhc_sof_timeout = timeout;
80004bd4:	91 09       	st.w	r8[0x0],r9
80004bd6:	31 49       	mov	r9,20
 * Lets USB line in IDLE state during 20ms.
 */
static void uhc_enumeration_step2(void)
{
  uhc_enable_timeout_callback(20, uhc_enumeration_step3);
}
80004bd8:	e0 68 2c 76 	mov	r8,11382
80004bdc:	b0 89       	st.b	r8[0x0],r9
80004bde:	5e fc       	retal	r12

80004be0 <uhc_enumeration_step8>:
80004be0:	fe c9 fd e8 	sub	r9,pc,-536
80004be4:	e0 68 06 e8 	mov	r8,1768
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
  uhc_sof_timeout = timeout;
80004be8:	91 09       	st.w	r8[0x0],r9
80004bea:	36 49       	mov	r9,100
 */
static void uhc_enumeration_step8(void)
{
  // Wait 100ms
  uhc_enable_timeout_callback(100, uhc_enumeration_step9);
}
80004bec:	e0 68 2c 76 	mov	r8,11382
80004bf0:	b0 89       	st.b	r8[0x0],r9
80004bf2:	5e fc       	retal	r12

80004bf4 <uhc_notify_sof>:
80004bf4:	eb cd 40 e0 	pushm	r5-r7,lr
80004bf8:	fe c7 98 68 	sub	r7,pc,-26520
  }
  // Device connection on root
  uhc_connection_tree(b_plug, &g_uhc_device_root);
}

void uhc_notify_sof(bool b_micro)
80004bfc:	18 95       	mov	r5,r12
80004bfe:	ee c6 ff b4 	sub	r6,r7,-76
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    if (uhc_uhis[i].sof_notify != NULL) {
80004c02:	2f 47       	sub	r7,-12
80004c04:	6e 08       	ld.w	r8,r7[0x0]
80004c06:	58 08       	cp.w	r8,0
      uhc_uhis[i].sof_notify(b_micro);
80004c08:	c0 30       	breq	80004c0e <uhc_notify_sof+0x1a>
80004c0a:	0a 9c       	mov	r12,r5
80004c0c:	5d 18       	icall	r8
}

void uhc_notify_sof(bool b_micro)
{
  // Call all UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
80004c0e:	2f 07       	sub	r7,-16
80004c10:	0c 37       	cp.w	r7,r6
    if (uhc_uhis[i].sof_notify != NULL) {
      uhc_uhis[i].sof_notify(b_micro);
    }
  }

  if (!b_micro) {
80004c12:	cf 91       	brne	80004c04 <uhc_notify_sof+0x10>
80004c14:	58 05       	cp.w	r5,0
    // Manage SOF timeout
    if (uhc_sof_timeout) {
80004c16:	c0 a1       	brne	80004c2a <uhc_notify_sof+0x36>
80004c18:	e0 68 2c 76 	mov	r8,11382
80004c1c:	11 89       	ld.ub	r9,r8[0x0]
      if (--uhc_sof_timeout == 0) {
80004c1e:	58 09       	cp.w	r9,0
80004c20:	c0 50       	breq	80004c2a <uhc_notify_sof+0x36>
80004c22:	20 19       	sub	r9,1
80004c24:	5c 59       	castu.b	r9
80004c26:	b0 89       	st.b	r8[0x0],r9
80004c28:	c0 30       	breq	80004c2e <uhc_notify_sof+0x3a>
	uhc_sof_timeout_callback();
80004c2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c2e:	e0 68 06 e8 	mov	r8,1768
80004c32:	70 08       	ld.w	r8,r8[0x0]
80004c34:	5d 18       	icall	r8
80004c36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004c3a:	d7 03       	nop

80004c3c <uhc_remotewakeup>:
80004c3c:	d4 01       	pushm	lr
80004c3e:	20 2d       	sub	sp,8
  usb_setup_req_t req;
  uhc_device_t *dev;

  dev = &g_uhc_device_root;
  while(1) {
    if (dev->conf_desc->bmAttributes & USB_CONFIG_ATTR_REMOTE_WAKEUP) {
80004c40:	e0 69 06 c8 	mov	r9,1736
80004c44:	72 68       	ld.w	r8,r9[0x18]
80004c46:	11 f8       	ld.ub	r8,r8[0x7]
80004c48:	ed b8 00 05 	bld	r8,0x5
      if (b_enable) {
	req.bRequest = USB_REQ_SET_FEATURE;
80004c4c:	c1 c1       	brne	80004c84 <uhc_remotewakeup+0x48>
80004c4e:	58 0c       	cp.w	r12,0
80004c50:	f9 b8 01 03 	movne	r8,3
80004c54:	fb f8 1e 01 	st.bne	sp[0x1],r8
      } else {
	req.bRequest = USB_REQ_CLEAR_FEATURE;
80004c58:	f9 b8 00 01 	moveq	r8,1
80004c5c:	fb f8 0e 01 	st.beq	sp[0x1],r8
      req.bmRequestType = USB_REQ_RECIP_DEVICE
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
      req.wIndex = 0;
      req.wLength = 0;
      uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80004c60:	f3 3c 00 12 	ld.ub	r12,r9[18]
80004c64:	30 08       	mov	r8,0
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
      req.wIndex = 0;
      req.wLength = 0;
80004c66:	30 09       	mov	r9,0
	req.bRequest = USB_REQ_CLEAR_FEATURE;
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
      req.wIndex = 0;
80004c68:	ba 38       	st.h	sp[0x6],r8
      req.wLength = 0;
      uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80004c6a:	ba 28       	st.h	sp[0x4],r8
80004c6c:	1a d9       	st.w	--sp,r9
      if (b_enable) {
	req.bRequest = USB_REQ_SET_FEATURE;
      } else {
	req.bRequest = USB_REQ_CLEAR_FEATURE;
      }
      req.bmRequestType = USB_REQ_RECIP_DEVICE
80004c6e:	12 98       	mov	r8,r9
	|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_OUT;
      req.wValue = USB_DEV_FEATURE_REMOTE_WAKEUP;
80004c70:	ba c9       	st.b	sp[0x4],r9
      req.wIndex = 0;
      req.wLength = 0;
      uhd_setup_request(dev->address,&req,NULL,0,NULL,NULL);
80004c72:	30 19       	mov	r9,1
80004c74:	fa cb ff fc 	sub	r11,sp,-4
80004c78:	ba 39       	st.h	sp[0x6],r9
80004c7a:	10 9a       	mov	r10,r8
80004c7c:	10 99       	mov	r9,r8
80004c7e:	fe b0 f8 83 	rcall	80003d84 <uhd_setup_request>
    dev = dev->next;
#else
    break;
#endif
  }
}
80004c82:	2f fd       	sub	sp,-4
80004c84:	2f ed       	sub	sp,-8
80004c86:	d8 02       	popm	pc

80004c88 <uhc_stop>:
80004c88:	d4 01       	pushm	lr
80004c8a:	fe b0 fa 3d 	rcall	80004104 <uhd_disable>
80004c8e:	d8 02       	popm	pc

80004c90 <uhc_start>:

void uhc_stop(bool b_id_stop)
{
  // Stop UHD
  uhd_disable(b_id_stop);
}
80004c90:	d4 01       	pushm	lr
80004c92:	3f f9       	mov	r9,-1
 *
 * @{
 */
void uhc_start(void)
{
  g_uhc_device_root.address = UHC_USB_ADD_NOT_VALID;
80004c94:	e0 68 06 c8 	mov	r8,1736
80004c98:	f1 69 00 12 	st.b	r8[18],r9
  uhc_sof_timeout = 0; // No callback registered on a SOF timeout
80004c9c:	30 09       	mov	r9,0
80004c9e:	e0 68 2c 76 	mov	r8,11382
  uhd_enable();
80004ca2:	b0 89       	st.b	r8[0x0],r9
}
80004ca4:	fe b0 fa ae 	rcall	80004200 <uhd_enable>
80004ca8:	d8 02       	popm	pc
80004caa:	d7 03       	nop

80004cac <uhc_notify_resume>:
80004cac:	d4 01       	pushm	lr
80004cae:	30 0c       	mov	r12,0
80004cb0:	cc 6f       	rcall	80004c3c <uhc_remotewakeup>
80004cb2:	e0 a0 14 4d 	rcall	8000754c <usb_wakeup>
}

void uhc_notify_resume(void)
{
  uhc_remotewakeup(false);
  UHC_WAKEUP_EVENT();
80004cb6:	d8 02       	popm	pc

80004cb8 <uhc_enumeration_step3>:
}
80004cb8:	d4 01       	pushm	lr
80004cba:	fe cc ff ea 	sub	r12,pc,-22
80004cbe:	fe b0 f5 11 	rcall	800036e0 <uhd_send_reset>
80004cc2:	d8 02       	popm	pc

80004cc4 <uhc_enumeration_step7>:
 * Reset USB line.
 */
static void uhc_enumeration_step3(void)
{
  uhc_enumeration_reset(uhc_enumeration_step4);
}
80004cc4:	d4 01       	pushm	lr
80004cc6:	fe cc 00 e6 	sub	r12,pc,230
80004cca:	fe b0 f5 0b 	rcall	800036e0 <uhd_send_reset>
 * Reset USB line.
 */
static void uhc_enumeration_step7(void)
{
  uhc_enumeration_reset(uhc_enumeration_step8);
}
80004cce:	d8 02       	popm	pc

80004cd0 <uhc_enumeration_step4>:
80004cd0:	d4 01       	pushm	lr
80004cd2:	fe b0 f4 f9 	rcall	800036c4 <uhd_get_speed>
80004cd6:	e0 68 06 c8 	mov	r8,1736
 * \brief Device enumeration step 4
 * Lets USB line in IDLE state during 100ms.
 */
static void uhc_enumeration_step4(void)
{
  uhc_dev_enum->speed = uhd_get_speed();
80004cda:	fe c9 ff 82 	sub	r9,pc,-126
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80004cde:	91 5c       	st.w	r8[0x14],r12
  uhc_sof_timeout = timeout;
80004ce0:	e0 68 06 e8 	mov	r8,1768
80004ce4:	91 09       	st.w	r8[0x0],r9
 */
static void uhc_enumeration_step4(void)
{
  uhc_dev_enum->speed = uhd_get_speed();
  uhc_enable_timeout_callback(100, uhc_enumeration_step5);
}
80004ce6:	36 49       	mov	r9,100
80004ce8:	e0 68 2c 76 	mov	r8,11382
80004cec:	b0 89       	st.b	r8[0x0],r9
80004cee:	d8 02       	popm	pc

80004cf0 <uhc_enumeration_error>:
80004cf0:	d4 21       	pushm	r4-r7,lr
80004cf2:	18 96       	mov	r6,r12
80004cf4:	58 7c       	cp.w	r12,7
80004cf6:	c2 c0       	breq	80004d4e <uhc_enumeration_error+0x5e>
80004cf8:	e0 67 06 c8 	mov	r7,1736
{
  if (status == UHC_ENUM_DISCONNECT) {
    uhc_enum_try = 0;
    return; // Abort enumeration process
  }
  uhd_ep_free(uhc_dev_enum->address, 0xFF);
80004cfc:	e0 6b 00 ff 	mov	r11,255
80004d00:	ef 3c 00 12 	ld.ub	r12,r7[18]
80004d04:	fe b0 f8 7c 	rcall	80003dfc <uhd_ep_free>

  // Free USB configuration descriptor buffer
  if (uhc_dev_enum->conf_desc != NULL) {
80004d08:	6e 6c       	ld.w	r12,r7[0x18]
80004d0a:	58 0c       	cp.w	r12,0
    free(uhc_dev_enum->conf_desc);
80004d0c:	c0 50       	breq	80004d16 <uhc_enumeration_error+0x26>
80004d0e:	e0 a0 2b 19 	rcall	8000a340 <free>
    uhc_dev_enum->conf_desc = NULL;
80004d12:	30 08       	mov	r8,0
  }
  uhc_dev_enum->address = 0;
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
80004d14:	8f 68       	st.w	r7[0x18],r8
  // Free USB configuration descriptor buffer
  if (uhc_dev_enum->conf_desc != NULL) {
    free(uhc_dev_enum->conf_desc);
    uhc_dev_enum->conf_desc = NULL;
  }
  uhc_dev_enum->address = 0;
80004d16:	e0 65 06 e4 	mov	r5,1764
80004d1a:	30 04       	mov	r4,0
80004d1c:	0b 88       	ld.ub	r8,r5[0x0]
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
80004d1e:	ef 64 00 12 	st.b	r7[18],r4
80004d22:	f0 c9 ff ff 	sub	r9,r8,-1
80004d26:	aa 89       	st.b	r5[0x0],r9
80004d28:	30 39       	mov	r9,3
80004d2a:	f2 08 18 00 	cp.b	r8,r9
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80004d2e:	e0 88 00 0b 	brls	80004d44 <uhc_enumeration_error+0x54>
    uhc_enumeration_step1();
    return;
  }
  // Abort enumeration, set line in suspend mode
  uhc_enumeration_suspend();
  UHC_ENUM_EVENT(uhc_dev_enum, status);
80004d32:	fe b0 f4 e1 	rcall	800036f4 <uhd_suspend>
80004d36:	0c 9b       	mov	r11,r6
80004d38:	e0 6c 06 c8 	mov	r12,1736
  uhc_enum_try = 0;
80004d3c:	e0 a0 14 0a 	rcall	80007550 <usb_enum>
    // Device connected on USB hub
    uhi_hub_send_reset(uhc_dev_enum, callback);
  } else
#endif
    {
      uhd_send_reset(callback);
80004d40:	aa 84       	st.b	r5[0x0],r4
80004d42:	d8 22       	popm	r4-r7,pc
  }
  uhc_dev_enum->address = 0;
  if (uhc_enum_try++ < UHC_ENUM_NB_TRY) {
    // Restart enumeration at beginning
    uhc_enumeration_step1();
    return;
80004d44:	fe cc 01 78 	sub	r12,pc,376
 * \param status        Enumeration error occurred
 */
static void uhc_enumeration_error(uhc_enum_status_t status)
{
  if (status == UHC_ENUM_DISCONNECT) {
    uhc_enum_try = 0;
80004d48:	fe b0 f4 cc 	rcall	800036e0 <uhd_send_reset>
    return; // Abort enumeration process
80004d4c:	d8 22       	popm	r4-r7,pc
80004d4e:	30 09       	mov	r9,0
80004d50:	e0 68 06 e4 	mov	r8,1764
80004d54:	b0 89       	st.b	r8[0x0],r9
80004d56:	d8 22       	popm	r4-r7,pc

80004d58 <uhc_enumeration_step5>:
80004d58:	d4 01       	pushm	lr
80004d5a:	20 2d       	sub	sp,8
80004d5c:	38 08       	mov	r8,-128
80004d5e:	ba 88       	st.b	sp[0x0],r8
80004d60:	30 68       	mov	r8,6
80004d62:	ba 98       	st.b	sp[0x1],r8
80004d64:	e0 68 01 00 	mov	r8,256
80004d68:	ba 18       	st.h	sp[0x2],r8
80004d6a:	30 08       	mov	r8,0
80004d6c:	ba 28       	st.h	sp[0x4],r8
80004d6e:	30 88       	mov	r8,8
  req.wValue = (USB_DT_DEVICE << 8);
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
80004d70:	34 0b       	mov	r11,64

  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_DEVICE << 8);
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
80004d72:	ba 38       	st.h	sp[0x6],r8
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
80004d74:	30 0c       	mov	r12,0
80004d76:	fe b0 f9 5f 	rcall	80004034 <uhd_ep0_alloc>
80004d7a:	c1 60       	breq	80004da6 <uhc_enumeration_step5+0x4e>
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }
  if (!uhd_setup_request(0,
80004d7c:	fe c9 ff cc 	sub	r9,pc,-52
80004d80:	30 08       	mov	r8,0
80004d82:	1a d9       	st.w	--sp,r9
80004d84:	e0 6a 06 c8 	mov	r10,1736
80004d88:	fa cb ff fc 	sub	r11,sp,-4
80004d8c:	31 29       	mov	r9,18
80004d8e:	10 9c       	mov	r12,r8
80004d90:	fe b0 f7 fa 	rcall	80003d84 <uhd_setup_request>
80004d94:	2f fd       	sub	sp,-4
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004d96:	58 0c       	cp.w	r12,0
80004d98:	c0 30       	breq	80004d9e <uhc_enumeration_step5+0x46>
			 &req,
			 (uint8_t*)&uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004d9a:	2f ed       	sub	sp,-8
80004d9c:	d8 02       	popm	pc
80004d9e:	30 6c       	mov	r12,6
    return;
  }
}
80004da0:	ca 8f       	rcall	80004cf0 <uhc_enumeration_error>
80004da2:	2f ed       	sub	sp,-8
  req.wIndex = 0;
  req.wLength = offsetof(uhc_device_t, dev_desc.bMaxPacketSize0)
    + sizeof(uhc_dev_enum->dev_desc.bMaxPacketSize0);

  if (!uhd_ep0_alloc(0, 64)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80004da4:	d8 02       	popm	pc
80004da6:	30 4c       	mov	r12,4
80004da8:	ca 4f       	rcall	80004cf0 <uhc_enumeration_error>
			 NULL,
			 uhc_enumeration_step6)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004daa:	2f ed       	sub	sp,-8
80004dac:	d8 02       	popm	pc
80004dae:	d7 03       	nop

80004db0 <uhc_enumeration_step6>:
80004db0:	d4 01       	pushm	lr
80004db2:	30 79       	mov	r9,7
80004db4:	58 0b       	cp.w	r11,0
80004db6:	5f 18       	srne	r8
80004db8:	f2 0a 19 00 	cp.h	r10,r9
80004dbc:	5f 89       	srls	r9
80004dbe:	f3 e8 10 08 	or	r8,r9,r8
80004dc2:	c0 b1       	brne	80004dd8 <uhc_enumeration_step6+0x28>
				  usb_add_t add,
				  uhd_trans_status_t status,
				  uint16_t payload_trans)
{
  UNUSED(add);
  if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
80004dc4:	e0 68 06 c8 	mov	r8,1736
80004dc8:	11 99       	ld.ub	r9,r8[0x1]
80004dca:	30 18       	mov	r8,1
80004dcc:	f0 09 18 00 	cp.b	r9,r8
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80004dd0:	c0 90       	breq	80004de2 <uhc_enumeration_step6+0x32>
80004dd2:	30 3c       	mov	r12,3
80004dd4:	c8 ef       	rcall	80004cf0 <uhc_enumeration_error>
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
80004dd6:	d8 02       	popm	pc
				  uint16_t payload_trans)
{
  UNUSED(add);
  if ((status != UHD_TRANS_NOERROR) || (payload_trans < 8)
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80004dd8:	58 1b       	cp.w	r11,1
80004dda:	cf c1       	brne	80004dd2 <uhc_enumeration_step6+0x22>
80004ddc:	30 7c       	mov	r12,7
80004dde:	c8 9f       	rcall	80004cf0 <uhc_enumeration_error>
80004de0:	d8 02       	popm	pc
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
80004de2:	fe c9 01 1e 	sub	r9,pc,286
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80004de6:	e0 68 06 e8 	mov	r8,1768
  uhc_sof_timeout = timeout;
80004dea:	91 09       	st.w	r8[0x0],r9
80004dec:	31 49       	mov	r9,20
80004dee:	e0 68 2c 76 	mov	r8,11382
80004df2:	b0 89       	st.b	r8[0x0],r9
80004df4:	d8 02       	popm	pc
80004df6:	d7 03       	nop

80004df8 <uhc_enumeration_step9>:
80004df8:	eb cd 40 80 	pushm	r7,lr
80004dfc:	20 2d       	sub	sp,8
80004dfe:	30 18       	mov	r8,1
80004e00:	e0 67 06 c8 	mov	r7,1736
80004e04:	ba 18       	st.h	sp[0x2],r8
80004e06:	ef 68 00 12 	st.b	r7[18],r8
#else
  req.wValue = UHC_DEVICE_ENUM_ADD;
  uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
  req.wIndex = 0;
  req.wLength = 0;
80004e0a:	30 08       	mov	r8,0
  uhc_dev_enum->address = usb_addr_free;
#else
  req.wValue = UHC_DEVICE_ENUM_ADD;
  uhc_dev_enum->address = UHC_DEVICE_ENUM_ADD;
#endif
  req.wIndex = 0;
80004e0c:	ba 38       	st.h	sp[0x6],r8
 */
static void uhc_enumeration_step9(void)
{
  usb_setup_req_t req;

  req.bmRequestType = USB_REQ_RECIP_DEVICE
80004e0e:	ba 28       	st.h	sp[0x4],r8
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_ADDRESS;
80004e10:	ba 88       	st.b	sp[0x0],r8
#endif
  req.wIndex = 0;
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
80004e12:	30 58       	mov	r8,5
{
  usb_setup_req_t req;

  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_ADDRESS;
80004e14:	30 0b       	mov	r11,0
#endif
  req.wIndex = 0;
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
80004e16:	ba 98       	st.b	sp[0x1],r8
80004e18:	16 9c       	mov	r12,r11
80004e1a:	fe b0 f7 f1 	rcall	80003dfc <uhd_ep_free>
  if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
80004e1e:	0f fb       	ld.ub	r11,r7[0x7]
80004e20:	30 0c       	mov	r12,0
80004e22:	fe b0 f9 09 	rcall	80004034 <uhd_ep0_alloc>
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }

  if (!uhd_setup_request(0,
80004e26:	c1 70       	breq	80004e54 <uhc_enumeration_step9+0x5c>
80004e28:	fe c9 ff c8 	sub	r9,pc,-56
80004e2c:	30 08       	mov	r8,0
80004e2e:	1a d9       	st.w	--sp,r9
80004e30:	0e 9a       	mov	r10,r7
80004e32:	fa cb ff fc 	sub	r11,sp,-4
80004e36:	31 29       	mov	r9,18
80004e38:	10 9c       	mov	r12,r8
80004e3a:	fe b0 f7 a5 	rcall	80003d84 <uhd_setup_request>
80004e3e:	2f fd       	sub	sp,-4
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004e40:	58 0c       	cp.w	r12,0
80004e42:	c0 40       	breq	80004e4a <uhc_enumeration_step9+0x52>
80004e44:	2f ed       	sub	sp,-8
			 &req,
			 (uint8_t*)&uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004e46:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e4a:	30 6c       	mov	r12,6
    return;
  }
}
80004e4c:	c5 2f       	rcall	80004cf0 <uhc_enumeration_error>
80004e4e:	2f ed       	sub	sp,-8
80004e50:	e3 cd 80 80 	ldm	sp++,r7,pc
  req.wLength = 0;

  // After a USB reset, the reallocation is required
  uhd_ep_free(0, 0);
  if (!uhd_ep0_alloc(0, uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80004e54:	30 4c       	mov	r12,4
80004e56:	c4 df       	rcall	80004cf0 <uhc_enumeration_error>
			 NULL,
			 uhc_enumeration_step10)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004e58:	2f ed       	sub	sp,-8
80004e5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e5e:	d7 03       	nop

80004e60 <uhc_enumeration_step10>:
80004e60:	d4 01       	pushm	lr
80004e62:	58 0b       	cp.w	r11,0
80004e64:	c0 80       	breq	80004e74 <uhc_enumeration_step10+0x14>
80004e66:	58 1b       	cp.w	r11,1
80004e68:	f9 bc 00 07 	moveq	r12,7
80004e6c:	f9 bc 01 03 	movne	r12,3
80004e70:	c4 0f       	rcall	80004cf0 <uhc_enumeration_error>
80004e72:	d8 02       	popm	pc
80004e74:	fe c9 ff ec 	sub	r9,pc,-20
 * \param callback Callback to call at the end of timeout
 */
static void uhc_enable_timeout_callback(uint8_t timeout,
					uhc_sof_timeout_callback_t callback)
{
  uhc_sof_timeout_callback = callback;
80004e78:	e0 68 06 e8 	mov	r8,1768
  uhc_sof_timeout = timeout;
80004e7c:	91 09       	st.w	r8[0x0],r9
80004e7e:	31 49       	mov	r9,20
80004e80:	e0 68 2c 76 	mov	r8,11382
80004e84:	b0 89       	st.b	r8[0x0],r9
80004e86:	d8 02       	popm	pc

80004e88 <uhc_enumeration_step11>:
80004e88:	eb cd 40 80 	pushm	r7,lr
80004e8c:	20 2d       	sub	sp,8
80004e8e:	30 0b       	mov	r11,0
80004e90:	16 9c       	mov	r12,r11
80004e92:	fe b0 f7 b5 	rcall	80003dfc <uhd_ep_free>

  // Free address 0 used to start enumeration
  uhd_ep_free(0, 0);

  // Alloc control endpoint with the new USB address
  if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
80004e96:	30 1c       	mov	r12,1
80004e98:	e0 67 06 c8 	mov	r7,1736
80004e9c:	0f fb       	ld.ub	r11,r7[0x7]
80004e9e:	fe b0 f8 cb 	rcall	80004034 <uhd_ep0_alloc>
		     uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80004ea2:	c2 20       	breq	80004ee6 <uhc_enumeration_step11+0x5e>
80004ea4:	38 08       	mov	r8,-128
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
80004ea6:	ba 88       	st.b	sp[0x0],r8
80004ea8:	30 68       	mov	r8,6
  req.wValue = (USB_DT_DEVICE << 8);
80004eaa:	ba 98       	st.b	sp[0x1],r8
80004eac:	e0 68 01 00 	mov	r8,256
  req.wIndex = 0;
80004eb0:	ba 18       	st.h	sp[0x2],r8
80004eb2:	30 08       	mov	r8,0
  req.wLength = sizeof(usb_dev_desc_t);
80004eb4:	ba 28       	st.h	sp[0x4],r8
80004eb6:	31 28       	mov	r8,18
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80004eb8:	ba 38       	st.h	sp[0x6],r8
80004eba:	fe c8 ff ca 	sub	r8,pc,-54
80004ebe:	0e 9a       	mov	r10,r7
80004ec0:	1a d8       	st.w	--sp,r8
80004ec2:	31 29       	mov	r9,18
80004ec4:	fa cb ff fc 	sub	r11,sp,-4
80004ec8:	30 08       	mov	r8,0
80004eca:	30 1c       	mov	r12,1
80004ecc:	fe b0 f7 5c 	rcall	80003d84 <uhd_setup_request>
80004ed0:	2f fd       	sub	sp,-4
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004ed2:	58 0c       	cp.w	r12,0
80004ed4:	c0 40       	breq	80004edc <uhc_enumeration_step11+0x54>
80004ed6:	2f ed       	sub	sp,-8
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) & uhc_dev_enum->dev_desc,
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004ed8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004edc:	30 6c       	mov	r12,6
    return;
  }
}
80004ede:	c0 9f       	rcall	80004cf0 <uhc_enumeration_error>
80004ee0:	2f ed       	sub	sp,-8
80004ee2:	e3 cd 80 80 	ldm	sp++,r7,pc
  uhd_ep_free(0, 0);

  // Alloc control endpoint with the new USB address
  if (!uhd_ep0_alloc(UHC_DEVICE_ENUM_ADD,
		     uhc_dev_enum->dev_desc.bMaxPacketSize0)) {
    uhc_enumeration_error(UHC_ENUM_HARDWARE_LIMIT);
80004ee6:	30 4c       	mov	r12,4
80004ee8:	c0 4f       	rcall	80004cf0 <uhc_enumeration_error>
			 sizeof(usb_dev_desc_t),
			 NULL, uhc_enumeration_step12)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
}
80004eea:	2f ed       	sub	sp,-8
80004eec:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ef0 <uhc_enumeration_step12>:
80004ef0:	eb cd 40 80 	pushm	r7,lr
80004ef4:	20 2d       	sub	sp,8
80004ef6:	31 29       	mov	r9,18
80004ef8:	58 0b       	cp.w	r11,0
80004efa:	5f 18       	srne	r8
80004efc:	f2 0a 19 00 	cp.h	r10,r9
80004f00:	5f 19       	srne	r9
80004f02:	f3 e8 10 08 	or	r8,r9,r8
80004f06:	c0 d1       	brne	80004f20 <uhc_enumeration_step12+0x30>
{
  usb_setup_req_t req;
  uint8_t conf_num;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
80004f08:	e0 67 06 c8 	mov	r7,1736
80004f0c:	30 18       	mov	r8,1
80004f0e:	0f 99       	ld.ub	r9,r7[0x1]
80004f10:	f0 09 18 00 	cp.b	r9,r8
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80004f14:	c0 a0       	breq	80004f28 <uhc_enumeration_step12+0x38>
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 sizeof(usb_conf_desc_t),
			 NULL, uhc_enumeration_step13)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004f16:	30 3c       	mov	r12,3
80004f18:	ce ce       	rcall	80004cf0 <uhc_enumeration_error>
    return;
  }
}
80004f1a:	2f ed       	sub	sp,-8
80004f1c:	e3 cd 80 80 	ldm	sp++,r7,pc
  uint8_t conf_num;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_dev_desc_t))
      || (uhc_dev_enum->dev_desc.bDescriptorType != USB_DT_DEVICE)) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
80004f20:	58 1b       	cp.w	r11,1
80004f22:	cf a1       	brne	80004f16 <uhc_enumeration_step12+0x26>
80004f24:	30 7c       	mov	r12,7
80004f26:	cf 9b       	rjmp	80004f18 <uhc_enumeration_step12+0x28>
    conf_num = UHC_DEVICE_CONF(uhc_dev_enum);
  } else {
    conf_num = 1;
  }

  uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
80004f28:	30 9c       	mov	r12,9
80004f2a:	e0 a0 2a 13 	rcall	8000a350 <malloc>
80004f2e:	8f 6c       	st.w	r7[0x18],r12
  if (uhc_dev_enum->conf_desc == NULL) {
80004f30:	c1 c0       	breq	80004f68 <uhc_enumeration_step12+0x78>
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType = USB_REQ_RECIP_DEVICE|USB_REQ_TYPE_STANDARD|USB_REQ_DIR_IN;
80004f32:	38 08       	mov	r8,-128
80004f34:	ba 88       	st.b	sp[0x0],r8
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
80004f36:	30 68       	mov	r8,6
80004f38:	ba 98       	st.b	sp[0x1],r8
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80004f3a:	e0 68 02 00 	mov	r8,512
80004f3e:	ba 18       	st.h	sp[0x2],r8
  req.wIndex = 0;
80004f40:	30 08       	mov	r8,0
80004f42:	ba 28       	st.h	sp[0x4],r8
  req.wLength = sizeof(usb_conf_desc_t);
80004f44:	30 98       	mov	r8,9
80004f46:	ba 38       	st.h	sp[0x6],r8
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80004f48:	fe c8 ff d8 	sub	r8,pc,-40
80004f4c:	18 9a       	mov	r10,r12
80004f4e:	1a d8       	st.w	--sp,r8
80004f50:	30 99       	mov	r9,9
80004f52:	fa cb ff fc 	sub	r11,sp,-4
80004f56:	30 08       	mov	r8,0
80004f58:	30 1c       	mov	r12,1
80004f5a:	fe b0 f7 15 	rcall	80003d84 <uhd_setup_request>
80004f5e:	2f fd       	sub	sp,-4
80004f60:	58 0c       	cp.w	r12,0
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 sizeof(usb_conf_desc_t),
			 NULL, uhc_enumeration_step13)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004f62:	cd c1       	brne	80004f1a <uhc_enumeration_step12+0x2a>
80004f64:	30 6c       	mov	r12,6
  }

  uhc_dev_enum->conf_desc = malloc(sizeof(usb_conf_desc_t));
  if (uhc_dev_enum->conf_desc == NULL) {
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004f66:	cd 9b       	rjmp	80004f18 <uhc_enumeration_step12+0x28>
80004f68:	30 6c       	mov	r12,6
80004f6a:	cc 3e       	rcall	80004cf0 <uhc_enumeration_error>
    return;
80004f6c:	cd 7b       	rjmp	80004f1a <uhc_enumeration_step12+0x2a>
80004f6e:	d7 03       	nop

80004f70 <uhc_enumeration_step13>:
80004f70:	eb cd 40 e0 	pushm	r5-r7,lr
80004f74:	20 2d       	sub	sp,8
80004f76:	30 99       	mov	r9,9
80004f78:	58 0b       	cp.w	r11,0
80004f7a:	5f 18       	srne	r8
80004f7c:	f2 0a 19 00 	cp.h	r10,r9
80004f80:	5f 19       	srne	r9
80004f82:	f3 e8 10 08 	or	r8,r9,r8
  uint8_t conf_num, conf_size;
  uint16_t bus_power = 0;
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
80004f86:	c0 e1       	brne	80004fa2 <uhc_enumeration_step13+0x32>
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
80004f88:	e0 67 06 c8 	mov	r7,1736
80004f8c:	30 29       	mov	r9,2
  uint8_t conf_num, conf_size;
  uint16_t bus_power = 0;
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
80004f8e:	6e 68       	ld.w	r8,r7[0x18]
80004f90:	11 9a       	ld.ub	r10,r8[0x1]
80004f92:	f2 0a 18 00 	cp.b	r10,r9
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80004f96:	c0 a0       	breq	80004faa <uhc_enumeration_step13+0x3a>
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 conf_size,
			 NULL, uhc_enumeration_step14)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80004f98:	30 3c       	mov	r12,3
80004f9a:	ca be       	rcall	80004cf0 <uhc_enumeration_error>
    return;
  }
}
80004f9c:	2f ed       	sub	sp,-8
80004f9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
  usb_setup_req_t req;
  UNUSED(add);

  if ((status != UHD_TRANS_NOERROR) || (payload_trans != sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)) {
    uhc_enumeration_error((status == UHD_TRANS_DISCONNECT)?
80004fa2:	58 1b       	cp.w	r11,1
80004fa4:	cf a1       	brne	80004f98 <uhc_enumeration_step13+0x28>
80004fa6:	30 7c       	mov	r12,7
80004fa8:	cf 9b       	rjmp	80004f9a <uhc_enumeration_step13+0x2a>
    }
    // Go to USB HUB parent
    dev = dev->hub;
  }
#else
  if (!(uhc_dev_enum->conf_desc->bmAttributes
80004faa:	11 f9       	ld.ub	r9,r8[0x7]
80004fac:	ed b9 00 06 	bld	r9,0x6
80004fb0:	c1 10       	breq	80004fd2 <uhc_enumeration_step13+0x62>
	&USB_CONFIG_ATTR_SELF_POWERED)) {
    bus_power = uhc_dev_enum->conf_desc->bMaxPower * 2;
80004fb2:	f1 3a 00 08 	ld.ub	r10,r8[8]
80004fb6:	e0 69 01 f4 	mov	r9,500
80004fba:	a1 7a       	lsl	r10,0x1
80004fbc:	f2 0a 19 00 	cp.h	r10,r9
80004fc0:	e0 88 00 09 	brls	80004fd2 <uhc_enumeration_step13+0x62>
  }
#endif
  if ((bus_power + uhc_power_running) > USB_HOST_POWER_MAX) {
    // USB interfaces consumption too high
    UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_OVERCURRENT);
80004fc4:	0e 9c       	mov	r12,r7
80004fc6:	30 2b       	mov	r11,2
80004fc8:	e0 a0 12 c4 	rcall	80007550 <usb_enum>
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80004fcc:	fe b0 f3 94 	rcall	800036f4 <uhd_suspend>
80004fd0:	ce 6b       	rjmp	80004f9c <uhc_enumeration_step13+0x2c>
  uhc_dev_enum->power = bus_power;
  uhc_power_running += bus_power;
#endif

  // Save information about USB configuration descriptor size
  conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
80004fd2:	11 a6       	ld.ub	r6,r8[0x2]
  conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
80004fd4:	6e 68       	ld.w	r8,r7[0x18]
  Assert(conf_num);
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
80004fd6:	10 9c       	mov	r12,r8
  uhc_power_running += bus_power;
#endif

  // Save information about USB configuration descriptor size
  conf_size = le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength);
  conf_num = uhc_dev_enum->conf_desc->bConfigurationValue;
80004fd8:	11 d5       	ld.ub	r5,r8[0x5]
  Assert(conf_num);
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
80004fda:	e0 a0 29 b3 	rcall	8000a340 <free>
  uhc_dev_enum->conf_desc = malloc(conf_size);
80004fde:	0c 9c       	mov	r12,r6
80004fe0:	e0 a0 29 b8 	rcall	8000a350 <malloc>
80004fe4:	8f 6c       	st.w	r7[0x18],r12
  if (uhc_dev_enum->conf_desc == NULL) {
80004fe6:	c1 b0       	breq	8000501c <uhc_enumeration_step13+0xac>
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
    return;
  }
  // Send USB device descriptor request
  req.bmRequestType =
80004fe8:	38 08       	mov	r8,-128
80004fea:	ba 88       	st.b	sp[0x0],r8
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
80004fec:	30 68       	mov	r8,6
80004fee:	ba 98       	st.b	sp[0x1],r8
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
  req.wIndex = 0;
80004ff0:	30 08       	mov	r8,0
80004ff2:	ba 28       	st.h	sp[0x4],r8
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80004ff4:	fe c8 ff d0 	sub	r8,pc,-48
80004ff8:	ba 36       	st.h	sp[0x6],r6
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80004ffa:	18 9a       	mov	r10,r12
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80004ffc:	20 15       	sub	r5,1
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80004ffe:	0c 99       	mov	r9,r6
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005000:	a9 b5       	sbr	r5,0x9
  // Send USB device descriptor request
  req.bmRequestType =
    USB_REQ_RECIP_DEVICE | USB_REQ_TYPE_STANDARD |
    USB_REQ_DIR_IN;
  req.bRequest = USB_REQ_GET_DESCRIPTOR;
  req.wValue = (USB_DT_CONFIGURATION << 8) | (conf_num - 1);
80005002:	30 1c       	mov	r12,1
  req.wIndex = 0;
  req.wLength = conf_size;
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005004:	ba 15       	st.h	sp[0x2],r5
80005006:	1a d8       	st.w	--sp,r8
80005008:	30 08       	mov	r8,0
8000500a:	fa cb ff fc 	sub	r11,sp,-4
8000500e:	fe b0 f6 bb 	rcall	80003d84 <uhd_setup_request>
80005012:	2f fd       	sub	sp,-4
80005014:	58 0c       	cp.w	r12,0
			 &req,
			 (uint8_t *) uhc_dev_enum->conf_desc,
			 conf_size,
			 NULL, uhc_enumeration_step14)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005016:	cc 31       	brne	80004f9c <uhc_enumeration_step13+0x2c>
80005018:	30 6c       	mov	r12,6
  // Re alloc USB configuration descriptor
  free(uhc_dev_enum->conf_desc);
  uhc_dev_enum->conf_desc = malloc(conf_size);
  if (uhc_dev_enum->conf_desc == NULL) {
    Assert(false);
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
8000501a:	cc 0b       	rjmp	80004f9a <uhc_enumeration_step13+0x2a>
8000501c:	30 6c       	mov	r12,6
8000501e:	c6 9e       	rcall	80004cf0 <uhc_enumeration_error>
    return;
80005020:	cb eb       	rjmp	80004f9c <uhc_enumeration_step13+0x2c>
80005022:	d7 03       	nop

80005024 <uhc_enumeration_step14>:
80005024:	d4 21       	pushm	r4-r7,lr
80005026:	20 2d       	sub	sp,8
80005028:	fe cc 9f c4 	sub	r12,pc,-24636
8000502c:	16 97       	mov	r7,r11
8000502e:	14 95       	mov	r5,r10
80005030:	fe b0 ee c4 	rcall	80002db8 <print_dbg>
80005034:	fe cc 9f b0 	sub	r12,pc,-24656
80005038:	fe b0 ee c0 	rcall	80002db8 <print_dbg>
8000503c:	e0 66 06 c8 	mov	r6,1736
80005040:	ed 3c 00 12 	ld.ub	r12,r6[18]
  ///// TESTING
#if UHC_PRINT_DBG
  print_dbg("\r\n received device descriptor. ");

  print_dbg("\r\n address: ");
  print_dbg_hex(uhc_dev_enum -> address);
80005044:	fe b0 ee 8c 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n speed: ");
80005048:	fe cc 9f b4 	sub	r12,pc,-24652
8000504c:	fe b0 ee b6 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum -> speed);
80005050:	6c 5c       	ld.w	r12,r6[0x14]
80005052:	fe b0 ee 85 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n\r\n");
80005056:	fe cc 9f b6 	sub	r12,pc,-24650
8000505a:	fe b0 ee af 	rcall	80002db8 <print_dbg>

  print_dbg("\r\n dev desc -> bLength : ");
8000505e:	fe cc 9f b6 	sub	r12,pc,-24650
80005062:	fe b0 ee ab 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bLength);
80005066:	0d 8c       	ld.ub	r12,r6[0x0]
80005068:	fe b0 ee 7a 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n dev desc -> bDescriptorType : ");
8000506c:	fe cc 9f a8 	sub	r12,pc,-24664
80005070:	fe b0 ee a4 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDescriptorType);
80005074:	0d 9c       	ld.ub	r12,r6[0x1]
80005076:	fe b0 ee 73 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n dev desc -> bcdUSB : ");
8000507a:	fe cc 9f 92 	sub	r12,pc,-24686
  print_dbg_hex(uhc_dev_enum->dev_desc.bcdUSB);
8000507e:	fe b0 ee 9d 	rcall	80002db8 <print_dbg>
80005082:	8c 9c       	ld.uh	r12,r6[0x2]
  print_dbg("\r\n dev desc -> bDeviceClass : ");
80005084:	fe b0 ee 6c 	rcall	80002d5c <print_dbg_hex>
80005088:	fe cc 9f 84 	sub	r12,pc,-24700
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceClass);
8000508c:	fe b0 ee 96 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n dev desc -> bDeviceSubClass : ");
80005090:	0d cc       	ld.ub	r12,r6[0x4]
80005092:	fe b0 ee 65 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceSubClass);
80005096:	fe cc 9f 72 	sub	r12,pc,-24718
8000509a:	fe b0 ee 8f 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n dev desc -> bDeviceProtocol : ");
8000509e:	0d dc       	ld.ub	r12,r6[0x5]
800050a0:	fe b0 ee 5e 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->dev_desc.bDeviceProtocol);
800050a4:	fe cc 9f 5c 	sub	r12,pc,-24740
  print_dbg("\r\n dev desc -> bMaxPacketSize0 : ");
800050a8:	fe b0 ee 88 	rcall	80002db8 <print_dbg>
800050ac:	0d ec       	ld.ub	r12,r6[0x6]
  print_dbg_hex(uhc_dev_enum->dev_desc.bMaxPacketSize0);
800050ae:	fe b0 ee 57 	rcall	80002d5c <print_dbg_hex>
800050b2:	fe cc 9f 46 	sub	r12,pc,-24762
  print_dbg("\r\n dev desc -> idVendor : ");
800050b6:	fe b0 ee 81 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.idVendor);
800050ba:	0d fc       	ld.ub	r12,r6[0x7]
800050bc:	fe b0 ee 50 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n dev desc -> idProduct : ");
800050c0:	fe cc 9f 30 	sub	r12,pc,-24784
800050c4:	fe b0 ee 7a 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->dev_desc.idProduct);
800050c8:	8c cc       	ld.uh	r12,r6[0x8]
800050ca:	fe b0 ee 49 	rcall	80002d5c <print_dbg_hex>
  print_dbg("\r\n dev desc -> bcdDevice : ");
800050ce:	fe cc 9f 22 	sub	r12,pc,-24798
  print_dbg_hex(uhc_dev_enum->dev_desc.bcdDevice);
800050d2:	fe b0 ee 73 	rcall	80002db8 <print_dbg>
800050d6:	8c dc       	ld.uh	r12,r6[0xa]
  print_dbg("\r\n dev desc -> iManufacturer : ");
800050d8:	fe b0 ee 42 	rcall	80002d5c <print_dbg_hex>
800050dc:	fe cc 9f 14 	sub	r12,pc,-24812
  print_dbg_hex(uhc_dev_enum->dev_desc.iManufacturer);
800050e0:	fe b0 ee 6c 	rcall	80002db8 <print_dbg>
800050e4:	8c ec       	ld.uh	r12,r6[0xc]
  print_dbg("\r\n dev desc -> iProduct : ");
800050e6:	fe b0 ee 3b 	rcall	80002d5c <print_dbg_hex>
800050ea:	fe cc 9f 06 	sub	r12,pc,-24826
  print_dbg_hex(uhc_dev_enum->dev_desc.iProduct);
800050ee:	fe b0 ee 65 	rcall	80002db8 <print_dbg>
800050f2:	ed 3c 00 0e 	ld.ub	r12,r6[14]
  print_dbg("\r\n dev desc -> iSerialNumber : ");
800050f6:	fe b0 ee 33 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->dev_desc.iSerialNumber);
800050fa:	fe cc 9e f6 	sub	r12,pc,-24842
800050fe:	fe b0 ee 5d 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n dev desc -> bNumConfigurations : ");
80005102:	ed 3c 00 0f 	ld.ub	r12,r6[15]
80005106:	fe b0 ee 2b 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->dev_desc.bNumConfigurations);
8000510a:	fe cc 9e ea 	sub	r12,pc,-24854
8000510e:	fe b0 ee 55 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n\r\n");
80005112:	ed 3c 00 10 	ld.ub	r12,r6[16]
	
  print_dbg("\r\n conf desc -> bLength : ");
80005116:	fe b0 ee 23 	rcall	80002d5c <print_dbg_hex>
8000511a:	fe cc 9e da 	sub	r12,pc,-24870
  print_dbg_hex(uhc_dev_enum->conf_desc->bLength);
8000511e:	fe b0 ee 4d 	rcall	80002db8 <print_dbg>
80005122:	ed 3c 00 11 	ld.ub	r12,r6[17]
  print_dbg("\r\n conf desc -> bDescriptorType : ");
80005126:	fe b0 ee 1b 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->conf_desc->bDescriptorType);
8000512a:	fe cc a0 8a 	sub	r12,pc,-24438
8000512e:	fe b0 ee 45 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n conf desc -> wTotalLength : ");
80005132:	fe cc 9e ca 	sub	r12,pc,-24886
80005136:	fe b0 ee 41 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->wTotalLength);
8000513a:	6c 68       	ld.w	r8,r6[0x18]
8000513c:	11 8c       	ld.ub	r12,r8[0x0]
8000513e:	fe b0 ee 0f 	rcall	80002d5c <print_dbg_hex>
80005142:	fe cc 9e be 	sub	r12,pc,-24898
  print_dbg("\r\n conf desc -> bNumInterfaces : ");
80005146:	fe b0 ee 39 	rcall	80002db8 <print_dbg>
8000514a:	6c 68       	ld.w	r8,r6[0x18]
  print_dbg_hex(uhc_dev_enum->conf_desc->bNumInterfaces);
8000514c:	11 9c       	ld.ub	r12,r8[0x1]
8000514e:	fe b0 ee 07 	rcall	80002d5c <print_dbg_hex>
80005152:	fe cc 9e aa 	sub	r12,pc,-24918
  print_dbg("\r\n conf desc -> bConfigurationValue : ");
80005156:	fe b0 ee 31 	rcall	80002db8 <print_dbg>
  print_dbg_hex(uhc_dev_enum->conf_desc->bConfigurationValue);
8000515a:	6c 68       	ld.w	r8,r6[0x18]
8000515c:	11 b9       	ld.ub	r9,r8[0x3]
8000515e:	11 ac       	ld.ub	r12,r8[0x2]
80005160:	f3 ec 10 8c 	or	r12,r9,r12<<0x8
  print_dbg("\r\n conf desc -> iConfiguration : ");
80005164:	fe b0 ed fc 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->conf_desc->iConfiguration);
80005168:	fe cc 9e a0 	sub	r12,pc,-24928
8000516c:	fe b0 ee 26 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n conf desc -> bmAttributes : ");
80005170:	6c 68       	ld.w	r8,r6[0x18]
80005172:	11 cc       	ld.ub	r12,r8[0x4]
80005174:	fe b0 ed f4 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(uhc_dev_enum->conf_desc->bmAttributes);
80005178:	fe cc 9e 8c 	sub	r12,pc,-24948
8000517c:	fe b0 ee 1e 	rcall	80002db8 <print_dbg>
  print_dbg("\r\n conf desc -> bMaxPower : ");
80005180:	6c 68       	ld.w	r8,r6[0x18]
80005182:	11 dc       	ld.ub	r12,r8[0x5]
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
80005184:	fe b0 ed ec 	rcall	80002d5c <print_dbg_hex>
80005188:	fe cc 9e 74 	sub	r12,pc,-24972
8000518c:	fe b0 ee 16 	rcall	80002db8 <print_dbg>
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
80005190:	6c 68       	ld.w	r8,r6[0x18]
80005192:	11 ec       	ld.ub	r12,r8[0x6]
80005194:	fe b0 ed e4 	rcall	80002d5c <print_dbg_hex>
80005198:	fe cc 9e 60 	sub	r12,pc,-24992
8000519c:	fe b0 ee 0e 	rcall	80002db8 <print_dbg>
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
800051a0:	6c 68       	ld.w	r8,r6[0x18]
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
800051a2:	11 fc       	ld.ub	r12,r8[0x7]
800051a4:	fe b0 ed dc 	rcall	80002d5c <print_dbg_hex>
800051a8:	fe cc 9e 50 	sub	r12,pc,-25008
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
800051ac:	fe b0 ee 06 	rcall	80002db8 <print_dbg>
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
			 &req,
			 NULL,
			 0,
			 NULL, uhc_enumeration_step15)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
800051b0:	6c 68       	ld.w	r8,r6[0x18]
    return;
  }
}
800051b2:	f1 3c 00 08 	ld.ub	r12,r8[8]

  if ((status != UHD_TRANS_NOERROR)
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
800051b6:	fe b0 ed d3 	rcall	80002d5c <print_dbg_hex>
800051ba:	58 07       	cp.w	r7,0
800051bc:	5f 18       	srne	r8
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
800051be:	30 89       	mov	r9,8
800051c0:	f2 05 19 00 	cp.h	r5,r9
800051c4:	5f 89       	srls	r9
800051c6:	f3 e8 10 08 	or	r8,r9,r8
  print_dbg_hex(uhc_dev_enum->conf_desc->bMaxPower);
#endif
  /////////////////////////////////
  /////////////////////////////////

  if ((status != UHD_TRANS_NOERROR)
800051ca:	c0 c1       	brne	800051e2 <uhc_enumeration_step14+0x1be>
800051cc:	6c 68       	ld.w	r8,r6[0x18]
      || (payload_trans < sizeof(usb_conf_desc_t))
      || (uhc_dev_enum->conf_desc->bDescriptorType != USB_DT_CONFIGURATION)
      || (payload_trans != le16_to_cpu(uhc_dev_enum->conf_desc->wTotalLength))) {
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
800051ce:	30 29       	mov	r9,2
 *
 * \param add           USB address of the setup request
 * \param status        Transfer status
 * \param payload_trans Number of data transfered during DATA phase
 */
static void uhc_enumeration_step14(
800051d0:	11 9a       	ld.ub	r10,r8[0x1]
800051d2:	f2 0a 18 00 	cp.b	r10,r9
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    switch (uhc_uhis[i].install(uhc_dev_enum)) {
800051d6:	c0 a0       	breq	800051ea <uhc_enumeration_step14+0x1c6>
800051d8:	30 3c       	mov	r12,3
800051da:	fe b0 fd 8b 	rcall	80004cf0 <uhc_enumeration_error>
800051de:	2f ed       	sub	sp,-8
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
800051e0:	d8 22       	popm	r4-r7,pc
    uhc_enumeration_error((status==UHD_TRANS_DISCONNECT)?
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
800051e2:	58 17       	cp.w	r7,1
800051e4:	cf a1       	brne	800051d8 <uhc_enumeration_step14+0x1b4>
      // Abort enumeration, set line in suspend mode
      uhc_enumeration_suspend();
      return;
    }
  }
  if (!b_conf_supported) {
800051e6:	30 7c       	mov	r12,7
800051e8:	cf 9b       	rjmp	800051da <uhc_enumeration_step14+0x1b6>
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
  req.wIndex = 0;
800051ea:	11 b9       	ld.ub	r9,r8[0x3]
    // Abort enumeration, set line in suspend mode
    uhc_enumeration_suspend();
    return;
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
800051ec:	11 a8       	ld.ub	r8,r8[0x2]
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
800051ee:	f3 e8 10 88 	or	r8,r9,r8<<0x8
    return;
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
800051f2:	5c c8       	swap.bh	r8
800051f4:	ea 08 19 00 	cp.h	r8,r5
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
  req.wIndex = 0;
  req.wLength = 0;
800051f8:	cf 01       	brne	800051d8 <uhc_enumeration_step14+0x1b4>
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
  req.wIndex = 0;
800051fa:	fe c7 9e 6a 	sub	r7,pc,-24982
  }
  // Enable device configuration
  req.bmRequestType = USB_REQ_RECIP_DEVICE
    | USB_REQ_TYPE_STANDARD | USB_REQ_DIR_OUT;
  req.bRequest = USB_REQ_SET_CONFIGURATION;
  req.wValue = uhc_dev_enum->conf_desc->bConfigurationValue;
800051fe:	30 04       	mov	r4,0
  req.wIndex = 0;
  req.wLength = 0;
  //  print_dbg("\r\n device enumeration successful; calling uhd_setup_request in uhc.c");
  if (!uhd_setup_request(UHC_DEVICE_ENUM_ADD,
80005200:	ee c5 ff c0 	sub	r5,r7,-64
80005204:	6e 08       	ld.w	r8,r7[0x0]
80005206:	e0 6c 06 c8 	mov	r12,1736
8000520a:	5d 18       	icall	r8
8000520c:	c2 11       	brne	8000524e <uhc_enumeration_step14+0x22a>
8000520e:	30 14       	mov	r4,1
80005210:	2f 07       	sub	r7,-16
80005212:	0a 37       	cp.w	r7,r5
80005214:	cf 81       	brne	80005204 <uhc_enumeration_step14+0x1e0>
80005216:	58 04       	cp.w	r4,0
			 &req,
			 NULL,
			 0,
			 NULL, uhc_enumeration_step15)) {
    uhc_enumeration_error(UHC_ENUM_MEMORY_LIMIT);
80005218:	c2 a0       	breq	8000526c <uhc_enumeration_step14+0x248>
8000521a:	30 09       	mov	r9,0
			  UHC_ENUM_DISCONNECT:UHC_ENUM_FAIL);
    return;
  }
  // Check if unless one USB interface is supported by UHIs
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
    switch (uhc_uhis[i].install(uhc_dev_enum)) {
8000521c:	30 0b       	mov	r11,0
8000521e:	6c 6a       	ld.w	r10,r6[0x18]
    case UHC_ENUM_UNSUPPORTED:
      break;
    default:
      // USB host hardware limitation
      // Free all endpoints
      uhd_ep_free(UHC_DEVICE_ENUM_ADD,0xFF);
80005220:	ba 8b       	st.b	sp[0x0],r11
80005222:	30 9b       	mov	r11,9
80005224:	ba 9b       	st.b	sp[0x1],r11
80005226:	15 da       	ld.ub	r10,r10[0x5]
80005228:	ba 39       	st.h	sp[0x6],r9
      UHC_ENUM_EVENT(uhc_dev_enum,UHC_ENUM_HARDWARE_LIMIT);
8000522a:	ba 29       	st.h	sp[0x4],r9
8000522c:	fe c9 ff b0 	sub	r9,pc,-80
80005230:	ba 1a       	st.h	sp[0x2],r10
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80005232:	30 08       	mov	r8,0
80005234:	1a d9       	st.w	--sp,r9
80005236:	10 9a       	mov	r10,r8
      return;
    }
  }
  if (!b_conf_supported) {
    // No USB interface supported
    UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_UNSUPPORTED);
80005238:	fa cb ff fc 	sub	r11,sp,-4
8000523c:	10 99       	mov	r9,r8
8000523e:	30 1c       	mov	r12,1
    uhi_hub_suspend(uhc_dev_enum);
  } else
#endif
    {
      // Suspend USB line
      uhd_suspend();
80005240:	fe b0 f5 a2 	rcall	80003d84 <uhd_setup_request>
80005244:	2f fd       	sub	sp,-4
80005246:	58 0c       	cp.w	r12,0
80005248:	cc b1       	brne	800051de <uhc_enumeration_step14+0x1ba>
8000524a:	30 6c       	mov	r12,6
8000524c:	cc 7b       	rjmp	800051da <uhc_enumeration_step14+0x1b6>
8000524e:	58 1c       	cp.w	r12,1
80005250:	ce 00       	breq	80005210 <uhc_enumeration_step14+0x1ec>
80005252:	e0 6b 00 ff 	mov	r11,255
80005256:	30 1c       	mov	r12,1
80005258:	fe b0 f5 d2 	rcall	80003dfc <uhd_ep_free>
8000525c:	30 4b       	mov	r11,4
8000525e:	e0 6c 06 c8 	mov	r12,1736
80005262:	e0 a0 11 77 	rcall	80007550 <usb_enum>
80005266:	fe b0 f2 47 	rcall	800036f4 <uhd_suspend>
8000526a:	cb ab       	rjmp	800051de <uhc_enumeration_step14+0x1ba>
8000526c:	30 1b       	mov	r11,1
8000526e:	e0 6c 06 c8 	mov	r12,1736
80005272:	e0 a0 11 6f 	rcall	80007550 <usb_enum>
80005276:	fe b0 f2 3f 	rcall	800036f4 <uhd_suspend>
8000527a:	cb 2b       	rjmp	800051de <uhc_enumeration_step14+0x1ba>

8000527c <uhc_enumeration_step15>:
8000527c:	eb cd 40 e0 	pushm	r5-r7,lr
80005280:	30 08       	mov	r8,0
80005282:	58 0b       	cp.w	r11,0
80005284:	5f 19       	srne	r9
80005286:	f0 0a 19 00 	cp.h	r10,r8
8000528a:	5f 1a       	srne	r10
8000528c:	16 97       	mov	r7,r11
8000528e:	f5 e9 10 09 	or	r9,r10,r9
80005292:	f0 09 18 00 	cp.b	r9,r8
80005296:	c1 60       	breq	800052c2 <uhc_enumeration_step15+0x46>
80005298:	fe c6 9f 08 	sub	r6,pc,-24824
8000529c:	ec c5 ff b8 	sub	r5,r6,-72
800052a0:	2f 86       	sub	r6,-8
800052a2:	6c 08       	ld.w	r8,r6[0x0]
800052a4:	e0 6c 06 c8 	mov	r12,1736
800052a8:	2f 06       	sub	r6,-16
800052aa:	5d 18       	icall	r8
800052ac:	0a 36       	cp.w	r6,r5
800052ae:	cf a1       	brne	800052a2 <uhc_enumeration_step15+0x26>
800052b0:	58 17       	cp.w	r7,1
800052b2:	f9 bc 00 07 	moveq	r12,7
800052b6:	f9 bc 01 03 	movne	r12,3
800052ba:	fe b0 fd 1b 	rcall	80004cf0 <uhc_enumeration_error>
800052be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052c2:	fe c6 9f 32 	sub	r6,pc,-24782
800052c6:	30 07       	mov	r7,0
800052c8:	2f c6       	sub	r6,-4
800052ca:	fe cc 9f 52 	sub	r12,pc,-24750
800052ce:	fe b0 ed 75 	rcall	80002db8 <print_dbg>
800052d2:	0e 9c       	mov	r12,r7
800052d4:	fe b0 ed 6c 	rcall	80002dac <print_dbg_ulong>
  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
800052d8:	6c 08       	ld.w	r8,r6[0x0]
			  UHC_ENUM_DISCONNECT : UHC_ENUM_FAIL);
    return;
  }

  // Enable all UHIs supported
  for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
800052da:	2f f7       	sub	r7,-1
800052dc:	2f 06       	sub	r6,-16
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
  }
  uhc_enum_try = 0;
800052de:	e0 6c 06 c8 	mov	r12,1736
	
  UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
800052e2:	5d 18       	icall	r8
#if UHC_PRINT_DBG
    print_dbg("\r\n enabling UHI, idx: "); print_dbg_ulong(i); 
#endif
    uhc_uhis[i].enable(uhc_dev_enum);
  }
  uhc_enum_try = 0;
800052e4:	58 47       	cp.w	r7,4
	
  UHC_ENUM_EVENT(uhc_dev_enum, UHC_ENUM_SUCCESS);
800052e6:	cf 21       	brne	800052ca <uhc_enumeration_step15+0x4e>
800052e8:	30 09       	mov	r9,0
800052ea:	e0 68 06 e4 	mov	r8,1764
800052ee:	30 0b       	mov	r11,0
800052f0:	b0 89       	st.b	r8[0x0],r9
800052f2:	e0 6c 06 c8 	mov	r12,1736
800052f6:	e0 a0 11 2d 	rcall	80007550 <usb_enum>
800052fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052fe:	d7 03       	nop

80005300 <uhc_notify_connection>:
80005300:	eb cd 40 e0 	pushm	r5-r7,lr
80005304:	18 98       	mov	r8,r12
80005306:	58 0c       	cp.w	r12,0
80005308:	c2 b1       	brne	8000535e <uhc_notify_connection+0x5e>
8000530a:	e0 69 06 c8 	mov	r9,1736
8000530e:	f3 3c 00 12 	ld.ub	r12,r9[18]

#ifdef USB_HOST_HUB_SUPPORT
    uhc_power_running = 0;
#endif
  } else {
    if (g_uhc_device_root.address == UHC_USB_ADD_NOT_VALID) {
80005312:	3f f9       	mov	r9,-1
80005314:	f2 0c 18 00 	cp.b	r12,r9
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
    uhc_enumeration_step1();
  } else {
    if (uhc_dev_enum == dev) {
      // Eventually stop enumeration timeout on-going on this device
      uhc_sof_timeout = 0;
80005318:	c3 70       	breq	80005386 <uhc_notify_connection+0x86>
    }
    // Abort all transfers (endpoint control and other) and free pipe(s)
    uhd_ep_free(dev->address, 0xFF);
8000531a:	e0 69 2c 76 	mov	r9,11382
8000531e:	fe c6 9f 8e 	sub	r6,pc,-24690

/**
 * \name Callbacks used by USB Host Driver (UHD) to notify events
 * @{
 */
void uhc_notify_connection(bool b_plug)
80005322:	b2 88       	st.b	r9[0x0],r8
80005324:	e0 6b 00 ff 	mov	r11,255
    if (uhc_dev_enum == dev) {
      // Eventually stop enumeration timeout on-going on this device
      uhc_sof_timeout = 0;
    }
    // Abort all transfers (endpoint control and other) and free pipe(s)
    uhd_ep_free(dev->address, 0xFF);
80005328:	ec c5 ff b8 	sub	r5,r6,-72

    // Disable all USB interfaces (this includes HUB interface)
    for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
      uhc_uhis[i].uninstall(dev);
8000532c:	fe b0 f5 68 	rcall	80003dfc <uhd_ep_free>
80005330:	2f 86       	sub	r6,-8
80005332:	6c 08       	ld.w	r8,r6[0x0]
80005334:	e0 67 06 c8 	mov	r7,1736
    }
    // Abort all transfers (endpoint control and other) and free pipe(s)
    uhd_ep_free(dev->address, 0xFF);

    // Disable all USB interfaces (this includes HUB interface)
    for (uint8_t i = 0; i < UHC_NB_UHI; i++) {
80005338:	2f 06       	sub	r6,-16
      uhc_uhis[i].uninstall(dev);
    }

    UHC_CONNECTION_EVENT(dev, false);
8000533a:	0e 9c       	mov	r12,r7
8000533c:	5d 18       	icall	r8
8000533e:	0a 36       	cp.w	r6,r5
80005340:	cf 91       	brne	80005332 <uhc_notify_connection+0x32>
    dev->address = UHC_USB_ADD_NOT_VALID;
80005342:	0e 9c       	mov	r12,r7
80005344:	30 0b       	mov	r11,0
80005346:	e0 a0 11 02 	rcall	8000754a <usb_connection>
    // Free USB configuration descriptor buffer
    if (dev->conf_desc != NULL) {
8000534a:	3f f8       	mov	r8,-1
8000534c:	ef 68 00 12 	st.b	r7[18],r8
      free(dev->conf_desc);
80005350:	6e 6c       	ld.w	r12,r7[0x18]
80005352:	58 0c       	cp.w	r12,0
80005354:	c0 30       	breq	8000535a <uhc_notify_connection+0x5a>
  if (b_plug) {
    uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
80005356:	e0 a0 27 f5 	rcall	8000a340 <free>
    uhc_dev_enum->address = 0;
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
8000535a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    uhc_enum_try = 1;
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
    uhc_dev_enum->address = 0;
8000535e:	e0 68 06 c8 	mov	r8,1736
 * \param dev      Information about device connected or disconnected
 */
static void uhc_connection_tree(bool b_plug, uhc_device_t* dev)
{
  if (b_plug) {
    uhc_enum_try = 1;
80005362:	30 09       	mov	r9,0
80005364:	10 9c       	mov	r12,r8
#ifdef USB_HOST_HUB_SUPPORT
    uhc_dev_enum = dev;
#endif
    uhc_dev_enum->conf_desc = NULL;
    uhc_dev_enum->address = 0;
    UHC_CONNECTION_EVENT(uhc_dev_enum, true);
80005366:	f1 69 00 12 	st.b	r8[18],r9
8000536a:	91 69       	st.w	r8[0x18],r9
8000536c:	30 19       	mov	r9,1
    // Device connected on USB hub
    uhi_hub_send_reset(uhc_dev_enum, callback);
  } else
#endif
    {
      uhd_send_reset(callback);
8000536e:	e0 68 06 e4 	mov	r8,1764
80005372:	30 1b       	mov	r11,1
80005374:	b0 89       	st.b	r8[0x0],r9
80005376:	e0 a0 10 ea 	rcall	8000754a <usb_connection>
8000537a:	fe cc 07 ae 	sub	r12,pc,1966
8000537e:	fe b0 f1 b1 	rcall	800036e0 <uhd_send_reset>
80005382:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005386:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000538a:	d7 03       	nop

8000538c <init_adc>:
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
  (*dst)[3] = val & 0xfff;
}

// setup ad7923
void init_adc(void) {
8000538c:	eb cd 40 80 	pushm	r7,lr
  u16 cmd;

  //  cpu_irq_disable();

  // at powerup, the part wants a dummy conversion with DIN high
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80005390:	30 1b       	mov	r11,1
80005392:	fe 7c 28 00 	mov	r12,-55296
80005396:	fe b0 ea 73 	rcall	8000287c <spi_selectChip>
  spi_write(ADC_SPI, 0xffff);
8000539a:	e0 6b ff ff 	mov	r11,65535
8000539e:	fe 7c 28 00 	mov	r12,-55296
800053a2:	fe b0 eb 02 	rcall	800029a6 <spi_write>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800053a6:	30 1b       	mov	r11,1
800053a8:	fe 7c 28 00 	mov	r12,-55296
800053ac:	fe b0 ea 90 	rcall	800028cc <spi_unselectChip>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800053b0:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800053b4:	ee 78 42 40 	mov	r8,1000000
800053b8:	30 09       	mov	r9,0
800053ba:	e0 6a a8 bf 	mov	r10,43199
800053be:	ea 1a 13 ba 	orh	r10,0x13ba
800053c2:	30 0b       	mov	r11,0
800053c4:	e0 a0 26 74 	rcall	8000a0ac <__avr32_udiv64>
800053c8:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800053cc:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800053d0:	14 37       	cp.w	r7,r10
800053d2:	e0 88 00 19 	brls	80005404 <init_adc+0x78>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800053d6:	10 37       	cp.w	r7,r8
800053d8:	fe 98 ff fa 	brls	800053cc <init_adc+0x40>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800053dc:	10 3a       	cp.w	r10,r8
800053de:	cf 72       	brcc	800053cc <init_adc+0x40>
  // wait for powerup time (5us in datasheet)
  delay_us(5);
  
  // write base configuration
  cmd = AD7923_CMD_BASE << 4;
  spi_selectChip( ADC_SPI, ADC_SPI_NPCS );
800053e0:	30 1b       	mov	r11,1
800053e2:	fe 7c 28 00 	mov	r12,-55296
800053e6:	fe b0 ea 4b 	rcall	8000287c <spi_selectChip>
  spi_write( ADC_SPI, cmd );
800053ea:	e0 6b 83 10 	mov	r11,33552
800053ee:	fe 7c 28 00 	mov	r12,-55296
800053f2:	fe b0 ea da 	rcall	800029a6 <spi_write>
  spi_unselectChip( ADC_SPI, ADC_SPI_NPCS );
800053f6:	30 1b       	mov	r11,1
800053f8:	fe 7c 28 00 	mov	r12,-55296
800053fc:	fe b0 ea 68 	rcall	800028cc <spi_unselectChip>

  //  cpu_irq_enable();
}
80005400:	e3 cd 80 80 	ldm	sp++,r7,pc
80005404:	10 37       	cp.w	r7,r8
80005406:	fe 9b ff ed 	brhi	800053e0 <init_adc+0x54>
8000540a:	ce 9b       	rjmp	800053dc <init_adc+0x50>

8000540c <adc_poll>:
8000540c:	eb cd 40 f8 	pushm	r3-r7,lr
80005410:	20 1d       	sub	sp,4
80005412:	c9 fc       	rcall	80005550 <app_pause>
80005414:	30 1b       	mov	r11,1
80005416:	fe 7c 28 00 	mov	r12,-55296
8000541a:	fe b0 ea 31 	rcall	8000287c <spi_selectChip>
  U16 cmd, val;

  // data into AD7923 is a left-justified 12-bit value in a 16-bit word
  // so, always lshift the command before sending
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
8000541e:	e0 6b 83 10 	mov	r11,33552
  spi_write(ADC_SPI, cmd);
80005422:	fe 7c 28 00 	mov	r12,-55296
80005426:	fe b0 ea c0 	rcall	800029a6 <spi_write>
8000542a:	30 1b       	mov	r11,1
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
8000542c:	fe 7c 28 00 	mov	r12,-55296
80005430:	fe b0 ea 4e 	rcall	800028cc <spi_unselectChip>
80005434:	30 1b       	mov	r11,1

  // get channel 0, setup channel 1
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80005436:	fe 7c 28 00 	mov	r12,-55296
8000543a:	fe b0 ea 21 	rcall	8000287c <spi_selectChip>
8000543e:	e0 6b 87 10 	mov	r11,34576
  spi_write(ADC_SPI, cmd);
80005442:	fe 7c 28 00 	mov	r12,-55296
80005446:	fe b0 ea b0 	rcall	800029a6 <spi_write>
8000544a:	fe 7c 28 00 	mov	r12,-55296
  spi_read(ADC_SPI, &val);
8000544e:	fa c7 ff fe 	sub	r7,sp,-2
80005452:	0e 9b       	mov	r11,r7
80005454:	fe b0 ea b7 	rcall	800029c2 <spi_read>
80005458:	30 1b       	mov	r11,1
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
8000545a:	fe 7c 28 00 	mov	r12,-55296
8000545e:	fe b0 ea 37 	rcall	800028cc <spi_unselectChip>
80005462:	9a 18       	ld.sh	r8,sp[0x2]
  (*dst)[0] = val & 0xfff; 
80005464:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
80005468:	e0 66 06 fc 	mov	r6,1788

  // get channel 1, setup channel 2
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
8000546c:	30 1b       	mov	r11,1
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
  spi_read(ADC_SPI, &val);
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
  (*dst)[0] = val & 0xfff; 
8000546e:	ac 08       	st.h	r6[0x0],r8

  // get channel 1, setup channel 2
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
80005470:	fe 7c 28 00 	mov	r12,-55296
80005474:	fe b0 ea 04 	rcall	8000287c <spi_selectChip>
  spi_write(ADC_SPI, cmd);
80005478:	e0 6b 8b 10 	mov	r11,35600
8000547c:	fe 7c 28 00 	mov	r12,-55296
80005480:	fe b0 ea 93 	rcall	800029a6 <spi_write>
  spi_read(ADC_SPI, &val);
80005484:	0e 9b       	mov	r11,r7
80005486:	fe 7c 28 00 	mov	r12,-55296
8000548a:	fe b0 ea 9c 	rcall	800029c2 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
8000548e:	30 1b       	mov	r11,1
80005490:	fe 7c 28 00 	mov	r12,-55296
80005494:	fe b0 ea 1c 	rcall	800028cc <spi_unselectChip>
  (*dst)[1] = val & 0xfff;
80005498:	9a 18       	ld.sh	r8,sp[0x2]
8000549a:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc

  // get channel 2, setup channel 3
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
8000549e:	30 1b       	mov	r11,1
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
  spi_read(ADC_SPI, &val);
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
  (*dst)[1] = val & 0xfff;
800054a0:	ac 18       	st.h	r6[0x2],r8

  // get channel 2, setup channel 3
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
800054a2:	fe 7c 28 00 	mov	r12,-55296
800054a6:	fe b0 e9 eb 	rcall	8000287c <spi_selectChip>
  spi_write(ADC_SPI, cmd);
800054aa:	e0 6b 8f 10 	mov	r11,36624
800054ae:	fe 7c 28 00 	mov	r12,-55296
800054b2:	fe b0 ea 7a 	rcall	800029a6 <spi_write>
  spi_read(ADC_SPI, &val);
800054b6:	0e 9b       	mov	r11,r7
800054b8:	fe 7c 28 00 	mov	r12,-55296
800054bc:	fe b0 ea 83 	rcall	800029c2 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800054c0:	30 1b       	mov	r11,1
800054c2:	fe 7c 28 00 	mov	r12,-55296
800054c6:	fe b0 ea 03 	rcall	800028cc <spi_unselectChip>
  (*dst)[2] = val & 0xfff;
800054ca:	9a 18       	ld.sh	r8,sp[0x2]
800054cc:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc

  // get channel 3, dummy write
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
800054d0:	30 1b       	mov	r11,1
  cmd = ( AD7923_CMD_BASE | AD7923_CTL_ADD1 | AD7923_CTL_ADD0 ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
  spi_read(ADC_SPI, &val);
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
  (*dst)[2] = val & 0xfff;
800054d2:	ac 28       	st.h	r6[0x4],r8

  // get channel 3, dummy write
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
800054d4:	fe 7c 28 00 	mov	r12,-55296
800054d8:	fe b0 e9 d2 	rcall	8000287c <spi_selectChip>
  spi_write(ADC_SPI, cmd);
800054dc:	e0 6b 83 10 	mov	r11,33552
800054e0:	fe 7c 28 00 	mov	r12,-55296
800054e4:	fe b0 ea 61 	rcall	800029a6 <spi_write>
  spi_read(ADC_SPI, &val);
800054e8:	0e 9b       	mov	r11,r7
800054ea:	fe 7c 28 00 	mov	r12,-55296
800054ee:	fe b0 ea 6a 	rcall	800029c2 <spi_read>
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800054f2:	30 1b       	mov	r11,1
  (*dst)[3] = val & 0xfff;
800054f4:	0c 97       	mov	r7,r6
  // get channel 3, dummy write
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
  spi_read(ADC_SPI, &val);
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
800054f6:	fe 7c 28 00 	mov	r12,-55296
800054fa:	fe b0 e9 e9 	rcall	800028cc <spi_unselectChip>
  (*dst)[3] = val & 0xfff;
800054fe:	9a 18       	ld.sh	r8,sp[0x2]
80005500:	e0 65 06 f4 	mov	r5,1780
80005504:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc

  //  cpu_irq_enable();
}

// perform conversion, check for changes, and post events
void adc_poll(void) {
80005508:	ee c4 ff f8 	sub	r4,r7,-8
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
8000550c:	ac 38       	st.h	r6[0x6],r8
  cmd = ( AD7923_CMD_BASE ) << 4;
  spi_selectChip(ADC_SPI, ADC_SPI_NPCS);
  spi_write(ADC_SPI, cmd);
  spi_read(ADC_SPI, &val);
  spi_unselectChip(ADC_SPI, ADC_SPI_NPCS);
  (*dst)[3] = val & 0xfff;
8000550e:	e0 63 06 ec 	mov	r3,1772
  for(i=0; i<4; i++) {        
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
80005512:	fe c6 a1 42 	sub	r6,pc,-24254
80005516:	8e 09       	ld.sh	r9,r7[0x0]
80005518:	8a 88       	ld.uh	r8,r5[0x0]
8000551a:	2f e7       	sub	r7,-2
8000551c:	f3 e8 20 08 	eor	r8,r9,r8
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
80005520:	e2 18 0f fc 	andl	r8,0xffc,COH

  app_pause();

  adc_convert(&adcVal);

  for(i=0; i<4; i++) {        
80005524:	c0 91       	brne	80005536 <adc_poll+0x12a>
80005526:	2f e5       	sub	r5,-2
      e.eventType = adcEventTypes[i];
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
    }
  }
  app_resume();
80005528:	2f c6       	sub	r6,-4
8000552a:	08 37       	cp.w	r7,r4

}
8000552c:	cf 51       	brne	80005516 <adc_poll+0x10a>
8000552e:	c0 dc       	rcall	80005548 <app_resume>
80005530:	2f fd       	sub	sp,-4
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
      e.eventType = adcEventTypes[i];
80005532:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // TODO:
    /// probably want more filtering before posting events
    //    if(adcVal[i] != adcOldVal[i]) {
    /// this is a dirty way! but the two lower bits are pretty noisy.
    if( (adcVal[i] & 0xffc) != ( adcOldVal[i] & 0xffc) ) {
      adcOldVal[i] = adcVal[i];
80005536:	6c 08       	ld.w	r8,r6[0x0]
      e.eventType = adcEventTypes[i];
80005538:	87 19       	st.w	r3[0x4],r9
      e.eventData = (S16)(adcVal[i]);
      post_event(&e);
8000553a:	aa 09       	st.h	r5[0x0],r9
8000553c:	87 08       	st.w	r3[0x0],r8
8000553e:	e0 6c 06 ec 	mov	r12,1772
80005542:	e0 a0 02 2d 	rcall	8000599c <post_event>
80005546:	cf 0b       	rjmp	80005526 <adc_poll+0x11a>

80005548 <app_resume>:
  // disable pdca interrupt
  //  cpu_irq_disable_level(SYS_IRQ_PRIORITY);
  
  //  print_dbg("\r\n enabling tc/ui irq...");
  
  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80005548:	d5 43       	csrf	0x14
  cpu_irq_enable_level(UI_IRQ_PRIORITY);
8000554a:	d5 33       	csrf	0x13
  
  //  }
  
  //  notifyMsg = 0;
  //  inNotify = 0;
}
8000554c:	5e fc       	retal	r12
8000554e:	d7 03       	nop

80005550 <app_pause>:
/*   screen_clear(); */
/*   //  screen_line(0, 0, (char*)msg, 0xf); */
/*   screen_refresh(); */
/* } */

void app_pause(void) {
80005550:	eb cd 40 80 	pushm	r7,lr
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005554:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80005558:	e0 68 03 e8 	mov	r8,1000
8000555c:	30 09       	mov	r9,0
8000555e:	e0 6a d0 e7 	mov	r10,53479
80005562:	ea 1a 27 56 	orh	r10,0x2756
80005566:	30 0b       	mov	r11,0
80005568:	e0 a0 25 a2 	rcall	8000a0ac <__avr32_udiv64>
8000556c:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80005570:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005574:	14 37       	cp.w	r7,r10
80005576:	e0 88 00 0b 	brls	8000558c <app_pause+0x3c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000557a:	10 37       	cp.w	r7,r8
8000557c:	fe 98 ff fa 	brls	80005570 <app_pause+0x20>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80005580:	10 3a       	cp.w	r10,r8
80005582:	cf 72       	brcc	80005570 <app_pause+0x20>
  //  print_pending_events();

  //  delay_ns(100);
  delay_ms(10);

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80005584:	d3 43       	ssrf	0x14
  cpu_irq_disable_level(UI_IRQ_PRIORITY);
80005586:	d3 33       	ssrf	0x13

  /// disable all interrupts and save flags 
  //  flags = cpu_irq_save();
    // enable pdca interrupt
  //  cpu_irq_enable_level(SYS_IRQ_PRIORITY);
}
80005588:	e3 cd 80 80 	ldm	sp++,r7,pc
8000558c:	10 37       	cp.w	r7,r8
8000558e:	fe 98 ff f9 	brls	80005580 <app_pause+0x30>
  //  print_pending_events();

  //  delay_ns(100);
  delay_ms(10);

  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80005592:	d3 43       	ssrf	0x14
  cpu_irq_disable_level(UI_IRQ_PRIORITY);
80005594:	d3 33       	ssrf	0x13

  /// disable all interrupts and save flags 
  //  flags = cpu_irq_save();
    // enable pdca interrupt
  //  cpu_irq_enable_level(SYS_IRQ_PRIORITY);
}
80005596:	e3 cd 80 80 	ldm	sp++,r7,pc
8000559a:	d7 03       	nop

8000559c <init_sys_timers>:
  }
}


//====== external
void init_sys_timers(void) {
8000559c:	d4 01       	pushm	lr
  set_timer(&encTimer,           eEncTimerTag,           20,  &enc_timer_callback,    1);
8000559e:	30 18       	mov	r8,1
800055a0:	fe c9 ff 70 	sub	r9,pc,-144
800055a4:	31 4a       	mov	r10,20
800055a6:	30 0b       	mov	r11,0
800055a8:	e0 6c 07 48 	mov	r12,1864
  set_timer(&adcTimer,           eAdcTimerTag,           20,  &adc_timer_callback,    1);
800055ac:	e0 a0 0d 12 	rcall	80006fd0 <set_timer>
800055b0:	30 18       	mov	r8,1
800055b2:	fe c9 fe fe 	sub	r9,pc,-258
800055b6:	10 9b       	mov	r11,r8
800055b8:	31 4a       	mov	r10,20
  set_timer(&monomePollTimer,    eMonomePollTimerTag,      20,  &monome_poll_timer_callback, 1);
800055ba:	e0 6c 07 1c 	mov	r12,1820
800055be:	e0 a0 0d 09 	rcall	80006fd0 <set_timer>
800055c2:	30 18       	mov	r8,1
800055c4:	fe c9 ff 28 	sub	r9,pc,-216
  //  set_timer(&monomePollTimer,    eMonomePollTimerTag,      5,  &monome_poll_timer_callback, 1);
  set_timer(&monomeRefreshTimer, eMonomeRefreshTimerTag, 20,  &monome_refresh_timer_callback, 1);
800055c8:	31 4a       	mov	r10,20
800055ca:	30 2b       	mov	r11,2
800055cc:	e0 6c 07 08 	mov	r12,1800
800055d0:	e0 a0 0d 00 	rcall	80006fd0 <set_timer>
800055d4:	30 18       	mov	r8,1
  set_timer(&paramChangeTimer,   eParamChangeTimerTag,      1,  &param_change_timer_callback, 1);
800055d6:	fe c9 ff d2 	sub	r9,pc,-46
800055da:	31 4a       	mov	r10,20
800055dc:	30 3b       	mov	r11,3
800055de:	e0 6c 07 64 	mov	r12,1892
800055e2:	e0 a0 0c f7 	rcall	80006fd0 <set_timer>
}
800055e6:	30 18       	mov	r8,1
800055e8:	fe c9 ff ec 	sub	r9,pc,-20
800055ec:	10 9a       	mov	r10,r8
800055ee:	30 4b       	mov	r11,4
800055f0:	e0 6c 07 34 	mov	r12,1844
800055f4:	e0 a0 0c ee 	rcall	80006fd0 <set_timer>
800055f8:	d8 02       	popm	pc
800055fa:	d7 03       	nop

800055fc <param_change_timer_callback>:
800055fc:	d4 01       	pushm	lr
800055fe:	c9 fd       	rcall	8000593c <ctl_perform_all_changes>
80005600:	d8 02       	popm	pc
80005602:	d7 03       	nop

80005604 <monome_refresh_timer_callback>:
80005604:	d4 01       	pushm	lr
80005606:	e0 68 0b c9 	mov	r8,3017
8000560a:	11 89       	ld.ub	r9,r8[0x0]
8000560c:	30 08       	mov	r8,0
8000560e:	f0 09 18 00 	cp.b	r9,r8
80005612:	c0 70       	breq	80005620 <monome_refresh_timer_callback+0x1c>

//monome refresh callback
static void monome_refresh_timer_callback(int tag) {
  if (monomeConnect) {
    //    print_dbg("\r\n posting monome refresh event");
    if(monomeFrameDirty > 0) {
80005614:	e0 69 0b c2 	mov	r9,3010
80005618:	13 89       	ld.ub	r9,r9[0x0]
8000561a:	f0 09 18 00 	cp.b	r9,r8
      e.eventType = kEventMonomeRefresh;
8000561e:	c0 21       	brne	80005622 <monome_refresh_timer_callback+0x1e>
80005620:	d8 02       	popm	pc
      post_event(&e);
80005622:	e0 68 07 5c 	mov	r8,1884
80005626:	30 69       	mov	r9,6
80005628:	10 9c       	mov	r12,r8
8000562a:	91 09       	st.w	r8[0x0],r9
8000562c:	cb 8d       	rcall	8000599c <post_event>
8000562e:	d8 02       	popm	pc

80005630 <enc_timer_callback>:
80005630:	eb cd 40 fc 	pushm	r2-r7,lr
80005634:	30 08       	mov	r8,0
80005636:	e0 66 07 04 	mov	r6,1796
8000563a:	e0 67 2c 78 	mov	r7,11384

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
8000563e:	ac 88       	st.b	r6[0x0],r8
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
80005640:	e0 63 07 30 	mov	r3,1840

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80005644:	30 08       	mov	r8,0
    val = enc[i].val;
80005646:	e0 65 07 5c 	mov	r5,1884
8000564a:	10 92       	mov	r2,r8
8000564c:	30 34       	mov	r4,3
8000564e:	f0 08 00 18 	add	r8,r8,r8<<0x1
80005652:	f0 ca ff ff 	sub	r10,r8,-1
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
80005656:	ee 0a 04 29 	ld.sh	r9,r7[r10<<0x2]
8000565a:	a6 09       	st.h	r3[0x0],r9
8000565c:	ee 0a 00 2a 	add	r10,r7,r10<<0x2
80005660:	94 1a       	ld.sh	r10,r10[0x2]
80005662:	f4 09 19 00 	cp.h	r9,r10
80005666:	e0 89 00 05 	brgt	80005670 <enc_timer_callback+0x40>
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
      e.eventData = val;
      enc[i].val = 0;
8000566a:	5c 3a       	neg	r10
8000566c:	14 39       	cp.w	r9,r10
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
    val = enc[i].val;
    if ( (val > enc[i].thresh) || (val < (enc[i].thresh * -1)) ) {
    //  if( (val > ENC_THRESH) || (val < ENC_NEG_THRESH) ) {
      e.eventType = enc[i].event;
8000566e:	c0 d4       	brge	80005688 <enc_timer_callback+0x58>
80005670:	8b 19       	st.w	r5[0x4],r9
80005672:	f0 c9 ff ff 	sub	r9,r8,-1
      e.eventData = val;
      enc[i].val = 0;
80005676:	ee 08 00 28 	add	r8,r7,r8<<0x2
      post_event(&e);
8000567a:	70 28       	ld.w	r8,r8[0x8]
8000567c:	ee 09 0a 22 	st.h	r7[r9<<0x2],r2

// encoder accumulator polling callback
//// FIXME optimize
static void enc_timer_callback(int tag) {
  static s16 val;
  for(i=0; i<NUM_ENC; i++) {
80005680:	8b 08       	st.w	r5[0x0],r8
80005682:	e0 6c 07 5c 	mov	r12,1884
80005686:	c8 bd       	rcall	8000599c <post_event>
80005688:	0d 88       	ld.ub	r8,r6[0x0]
8000568a:	2f f8       	sub	r8,-1
8000568c:	5c 58       	castu.b	r8
8000568e:	ac 88       	st.b	r6[0x0],r8
      //      print_dbg_ulong(i);
      //      print_dbg(" , val: ");
      //      print_dbg_ulong(val);
    }
  }
}
80005690:	e8 08 18 00 	cp.b	r8,r4
80005694:	fe 98 ff dd 	brls	8000564e <enc_timer_callback+0x1e>
80005698:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

8000569c <monome_poll_timer_callback>:
8000569c:	d4 01       	pushm	lr
8000569e:	e0 68 0b c9 	mov	r8,3017
800056a2:	11 89       	ld.ub	r9,r8[0x0]
800056a4:	30 08       	mov	r8,0
800056a6:	f0 09 18 00 	cp.b	r9,r8

// monome polling callback
static void monome_poll_timer_callback(int tag) {
  if (monomeConnect > 0) {
    // start an ftdi transfer, callback handles event posting
    ftdi_read();
800056aa:	c0 30       	breq	800056b0 <monome_poll_timer_callback+0x14>
800056ac:	e0 a0 12 1a 	rcall	80007ae0 <ftdi_read>
800056b0:	d8 02       	popm	pc
800056b2:	d7 03       	nop

800056b4 <adc_timer_callback>:
800056b4:	d4 01       	pushm	lr
800056b6:	ca be       	rcall	8000540c <adc_poll>
  }
}

// adc polling callback
static void adc_timer_callback(int tag) {
  adc_poll();
800056b8:	d8 02       	popm	pc
}
800056ba:	d7 03       	nop

800056bc <bfin_set_param>:
  
  app_resume();
}

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {
800056bc:	eb cd 40 e0 	pushm	r5-r7,lr

  static ParamValue pval;
  pval.asInt = (s32)x;
800056c0:	f6 08 16 18 	lsr	r8,r11,0x18
800056c4:	e0 66 07 78 	mov	r6,1912
800056c8:	ac 88       	st.b	r6[0x0],r8
800056ca:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
800056ce:	ac 98       	st.b	r6[0x1],r8
800056d0:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
800056d4:	16 97       	mov	r7,r11
800056d6:	ac a8       	st.b	r6[0x2],r8
  
  app_resume();
}

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {
800056d8:	ac bb       	st.b	r6[0x3],r11

  static ParamValue pval;
  pval.asInt = (s32)x;

  print_dbg("\r\n bfin_set_param, idx: ");
800056da:	18 95       	mov	r5,r12
800056dc:	fe cc a2 fc 	sub	r12,pc,-23812
  print_dbg_ulong(idx);
800056e0:	fe b0 eb 6c 	rcall	80002db8 <print_dbg>
800056e4:	0a 9c       	mov	r12,r5

  print_dbg(", val: 0x");
800056e6:	fe b0 eb 63 	rcall	80002dac <print_dbg_ulong>
800056ea:	fe cc a2 ee 	sub	r12,pc,-23826

//void bfin_set_param(u8 idx, f32 x ) {
void bfin_set_param(u8 idx, fix16_t x ) {

  static ParamValue pval;
  pval.asInt = (s32)x;
800056ee:	fe b0 eb 65 	rcall	80002db8 <print_dbg>

  print_dbg("\r\n bfin_set_param, idx: ");
  print_dbg_ulong(idx);

  print_dbg(", val: 0x");
  print_dbg_hex((u32)x);
800056f2:	0e 9c       	mov	r12,r7

  //  app_pause();

  // command
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
800056f4:	30 07       	mov	r7,0
800056f6:	fe b0 eb 33 	rcall	80002d5c <print_dbg_hex>
800056fa:	0e 9b       	mov	r11,r7
800056fc:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, MSG_SET_PARAM_COM);
80005700:	fe b0 e8 be 	rcall	8000287c <spi_selectChip>
80005704:	0e 9b       	mov	r11,r7
80005706:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000570a:	fe b0 e9 4e 	rcall	800029a6 <spi_write>
8000570e:	0e 9b       	mov	r11,r7
80005710:	fe 7c 24 00 	mov	r12,-56320
  //idx
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005714:	fe b0 e8 dc 	rcall	800028cc <spi_unselectChip>
80005718:	0e 9b       	mov	r11,r7
8000571a:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, idx);
8000571e:	fe b0 e8 af 	rcall	8000287c <spi_selectChip>
80005722:	0a 9b       	mov	r11,r5
80005724:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005728:	fe b0 e9 3f 	rcall	800029a6 <spi_write>
8000572c:	0e 9b       	mov	r11,r7
8000572e:	fe 7c 24 00 	mov	r12,-56320
  //val0
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005732:	fe b0 e8 cd 	rcall	800028cc <spi_unselectChip>
80005736:	0e 9b       	mov	r11,r7
80005738:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, pval.asByte[0]);
8000573c:	fe b0 e8 a0 	rcall	8000287c <spi_selectChip>
80005740:	0d 8b       	ld.ub	r11,r6[0x0]
80005742:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005746:	fe b0 e9 30 	rcall	800029a6 <spi_write>
8000574a:	0e 9b       	mov	r11,r7
8000574c:	fe 7c 24 00 	mov	r12,-56320
  // val1
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005750:	fe b0 e8 be 	rcall	800028cc <spi_unselectChip>
80005754:	0e 9b       	mov	r11,r7
80005756:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, pval.asByte[1]);
8000575a:	fe b0 e8 91 	rcall	8000287c <spi_selectChip>
8000575e:	0d 9b       	ld.ub	r11,r6[0x1]
80005760:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005764:	fe b0 e9 21 	rcall	800029a6 <spi_write>
80005768:	0e 9b       	mov	r11,r7
8000576a:	fe 7c 24 00 	mov	r12,-56320
  //val2
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000576e:	fe b0 e8 af 	rcall	800028cc <spi_unselectChip>
80005772:	0e 9b       	mov	r11,r7
80005774:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, pval.asByte[2]);
80005778:	fe b0 e8 82 	rcall	8000287c <spi_selectChip>
8000577c:	0d ab       	ld.ub	r11,r6[0x2]
8000577e:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005782:	fe b0 e9 12 	rcall	800029a6 <spi_write>
80005786:	0e 9b       	mov	r11,r7
80005788:	fe 7c 24 00 	mov	r12,-56320
  //val3
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
8000578c:	fe b0 e8 a0 	rcall	800028cc <spi_unselectChip>
80005790:	0e 9b       	mov	r11,r7
80005792:	fe 7c 24 00 	mov	r12,-56320
  spi_write(BFIN_SPI, pval.asByte[3]);
80005796:	fe b0 e8 73 	rcall	8000287c <spi_selectChip>
8000579a:	0d bb       	ld.ub	r11,r6[0x3]
8000579c:	fe 7c 24 00 	mov	r12,-56320
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800057a0:	fe b0 e9 03 	rcall	800029a6 <spi_write>
800057a4:	0e 9b       	mov	r11,r7
800057a6:	fe 7c 24 00 	mov	r12,-56320

  //  app_resume();
}
800057aa:	fe b0 e8 91 	rcall	800028cc <spi_unselectChip>
800057ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800057b2:	d7 03       	nop

800057b4 <bfin_load_buf>:
800057b4:	d4 31       	pushm	r0-r7,lr
800057b6:	e0 65 0b 94 	mov	r5,2964
800057ba:	6a 08       	ld.w	r8,r5[0x0]
800057bc:	e0 58 00 00 	cp.w	r8,65536
800057c0:	e0 8b 00 b5 	brhi	8000592a <bfin_load_buf+0x176>
800057c4:	cc 6e       	rcall	80005550 <app_pause>
800057c6:	30 6c       	mov	r12,6
800057c8:	fe b0 e6 99 	rcall	800024fa <gpio_set_gpio_pin>
800057cc:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800057d0:	30 09       	mov	r9,0
800057d2:	e0 6a 18 67 	mov	r10,6247
800057d6:	ea 1a 03 ef 	orh	r10,0x3ef
800057da:	30 0b       	mov	r11,0
800057dc:	e0 a0 24 68 	rcall	8000a0ac <__avr32_udiv64>
800057e0:	14 94       	mov	r4,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800057e2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800057e6:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800057ea:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800057ee:	14 38       	cp.w	r8,r10
800057f0:	e0 88 00 94 	brls	80005918 <bfin_load_buf+0x164>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800057f4:	12 38       	cp.w	r8,r9
800057f6:	fe 98 ff fa 	brls	800057ea <bfin_load_buf+0x36>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800057fa:	12 3a       	cp.w	r10,r9
800057fc:	cf 72       	brcc	800057ea <bfin_load_buf+0x36>
void bfin_start_transfer(void) {
  //  volatile u64 delay;
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
  //  delay = 30; while (--delay > 0) {;;}
  delay_ms(1);
  gpio_clr_gpio_pin(BFIN_RESET_PIN);
800057fe:	30 6c       	mov	r12,6
80005800:	fe b0 e6 8a 	rcall	80002514 <gpio_clr_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005804:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80005808:	f0 04 00 0a 	add	r10,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000580c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005810:	14 38       	cp.w	r8,r10
80005812:	e0 88 00 0c 	brls	8000582a <bfin_load_buf+0x76>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80005816:	12 38       	cp.w	r8,r9
80005818:	e0 88 00 04 	brls	80005820 <bfin_load_buf+0x6c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000581c:	12 3a       	cp.w	r10,r9
8000581e:	c0 93       	brcs	80005830 <bfin_load_buf+0x7c>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80005820:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005824:	14 38       	cp.w	r8,r10
80005826:	fe 9b ff f8 	brhi	80005816 <bfin_load_buf+0x62>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000582a:	12 38       	cp.w	r8,r9
8000582c:	fe 98 ff f8 	brls	8000581c <bfin_load_buf+0x68>
  //  delay = 30; while (--delay > 0) {;;}
  delay_ms(1);
  gpio_set_gpio_pin(BFIN_RESET_PIN);  
80005830:	30 6c       	mov	r12,6
80005832:	fe b0 e6 64 	rcall	800024fa <gpio_set_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005836:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000583a:	f0 04 00 04 	add	r4,r8,r4
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000583e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005842:	08 38       	cp.w	r8,r4
80005844:	e0 88 00 0c 	brls	8000585c <bfin_load_buf+0xa8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80005848:	10 39       	cp.w	r9,r8
8000584a:	c0 42       	brcc	80005852 <bfin_load_buf+0x9e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000584c:	08 39       	cp.w	r9,r4
8000584e:	e0 8b 00 09 	brhi	80005860 <bfin_load_buf+0xac>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80005852:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005856:	08 38       	cp.w	r8,r4
80005858:	fe 9b ff f8 	brhi	80005848 <bfin_load_buf+0x94>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000585c:	10 39       	cp.w	r9,r8
8000585e:	cf 72       	brcc	8000584c <bfin_load_buf+0x98>
  //  delay = 3000; while (--delay > 0) {;;}
  delay_ms(1);
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
80005860:	30 0b       	mov	r11,0
80005862:	fe 7c 24 00 	mov	r12,-56320
80005866:	fe b0 e8 0b 	rcall	8000287c <spi_selectChip>

  app_pause();

  bfin_start_transfer();

  for(i=0; i<bfinLdrSize; i++) {
8000586a:	6a 08       	ld.w	r8,r5[0x0]
8000586c:	58 08       	cp.w	r8,0
8000586e:	c2 40       	breq	800058b6 <bfin_load_buf+0x102>
80005870:	30 02       	mov	r2,0
80005872:	30 03       	mov	r3,0
80005874:	e0 61 30 b4 	mov	r1,12468
    bfin_transfer_byte(bfinLdrData[i]);
80005878:	62 08       	ld.w	r8,r1[0x0]
8000587a:	04 08       	add	r8,r2
8000587c:	11 80       	ld.ub	r0,r8[0x0]
//---------------------------------------------
//------ static function definition

static void bfin_transfer_byte(u8 data) {
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
      print_dbg("\r\n HWAIT asserted..."); 
8000587e:	c0 58       	rjmp	80005888 <bfin_load_buf+0xd4>
80005880:	fe cc a4 5c 	sub	r12,pc,-23460

//---------------------------------------------
//------ static function definition

static void bfin_transfer_byte(u8 data) {
    while (gpio_get_pin_value(BFIN_HWAIT_PIN) > 0) { 
80005884:	fe b0 ea 9a 	rcall	80002db8 <print_dbg>
80005888:	30 5c       	mov	r12,5
8000588a:	fe b0 e6 2d 	rcall	800024e4 <gpio_get_pin_value>
      print_dbg("\r\n HWAIT asserted..."); 
    }
    spi_write(BFIN_SPI, data);
8000588e:	18 94       	mov	r4,r12
80005890:	cf 81       	brne	80005880 <bfin_load_buf+0xcc>
80005892:	00 9b       	mov	r11,r0
80005894:	fe 7c 24 00 	mov	r12,-56320

  app_pause();

  bfin_start_transfer();

  for(i=0; i<bfinLdrSize; i++) {
80005898:	fe b0 e8 87 	rcall	800029a6 <spi_write>
8000589c:	6a 08       	ld.w	r8,r5[0x0]
8000589e:	30 1a       	mov	r10,1
800058a0:	30 0b       	mov	r11,0
800058a2:	10 96       	mov	r6,r8
800058a4:	14 02       	add	r2,r10
800058a6:	e6 0b 00 43 	adc	r3,r3,r11
800058aa:	08 97       	mov	r7,r4
800058ac:	04 36       	cp.w	r6,r2
800058ae:	e6 07 13 00 	cpc	r7,r3
  delay_ms(1);
  spi_selectChip(BFIN_SPI, BFIN_SPI_NPCS);
}

void bfin_end_transfer(void) {
  spi_unselectChip(BFIN_SPI, BFIN_SPI_NPCS);
800058b2:	fe 9b ff e3 	brhi	80005878 <bfin_load_buf+0xc4>
800058b6:	30 0b       	mov	r11,0
800058b8:	fe 7c 24 00 	mov	r12,-56320
  print_dbg("\r\n done loading; waiting... ");
800058bc:	fe b0 e8 08 	rcall	800028cc <spi_unselectChip>
800058c0:	fe cc a4 84 	sub	r12,pc,-23420
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800058c4:	fe b0 ea 7a 	rcall	80002db8 <print_dbg>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800058c8:	e1 b7 00 42 	mfsr	r7,0x108
800058cc:	e0 6a 14 80 	mov	r10,5248
800058d0:	ea 1a 03 ef 	orh	r10,0x3ef
800058d4:	30 0b       	mov	r11,0
800058d6:	36 49       	mov	r9,100
800058d8:	f4 09 06 48 	mulu.d	r8,r10,r9
800058dc:	f6 0a 10 64 	mul	r10,r11,100
800058e0:	f4 09 00 09 	add	r9,r10,r9
800058e4:	30 0b       	mov	r11,0
800058e6:	e0 6a 03 e7 	mov	r10,999
800058ea:	f0 0a 00 0a 	add	r10,r8,r10
800058ee:	f2 0b 00 4b 	adc	r11,r9,r11
800058f2:	e0 68 03 e8 	mov	r8,1000
800058f6:	30 09       	mov	r9,0
800058f8:	e0 a0 23 da 	rcall	8000a0ac <__avr32_udiv64>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800058fc:	ee 0a 00 0a 	add	r10,r7,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005900:	e1 b8 00 42 	mfsr	r8,0x108
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80005904:	14 37       	cp.w	r7,r10
80005906:	e0 88 00 0d 	brls	80005920 <bfin_load_buf+0x16c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000590a:	10 37       	cp.w	r7,r8
8000590c:	fe 98 ff fa 	brls	80005900 <bfin_load_buf+0x14c>
    bfin_transfer_byte(bfinLdrData[i]);
  }

  bfin_end_transfer();
  
  app_resume();
80005910:	10 3a       	cp.w	r10,r8
80005912:	cf 72       	brcc	80005900 <bfin_load_buf+0x14c>
80005914:	c1 ae       	rcall	80005548 <app_resume>
80005916:	d8 32       	popm	r0-r7,pc
80005918:	12 38       	cp.w	r8,r9
8000591a:	fe 9b ff 72 	brhi	800057fe <bfin_load_buf+0x4a>
8000591e:	c6 eb       	rjmp	800057fa <bfin_load_buf+0x46>
80005920:	10 37       	cp.w	r7,r8
80005922:	fe 98 ff f7 	brls	80005910 <bfin_load_buf+0x15c>
80005926:	c1 1e       	rcall	80005548 <app_resume>
// load bfin executable from the RAM buffer
void bfin_load_buf(void) {
  u64 i; /// byte index in .ldr

  if(bfinLdrSize > BFIN_LDR_MAX_BYTES) {
    print_dbg("\r\n bfin load error: size : "); print_dbg_hex(bfinLdrSize);
80005928:	d8 32       	popm	r0-r7,pc
8000592a:	fe cc a5 22 	sub	r12,pc,-23262
8000592e:	fe b0 ea 45 	rcall	80002db8 <print_dbg>
80005932:	6a 0c       	ld.w	r12,r5[0x0]
    return;
80005934:	fe b0 ea 14 	rcall	80002d5c <print_dbg_hex>
80005938:	d8 32       	popm	r0-r7,pc
8000593a:	d7 03       	nop

8000593c <ctl_perform_all_changes>:
  clear_param_dirty(idx);
}


// attempt to execute all pending param changes
extern void ctl_perform_all_changes(void) {
8000593c:	eb cd 40 fc 	pushm	r2-r7,lr
  u32 idx, i;
  // execute in FIFO order
  for(i=0; i<evCount; i++) {
80005940:	e0 64 07 7c 	mov	r4,1916
80005944:	68 08       	ld.w	r8,r4[0x0]
80005946:	58 08       	cp.w	r8,0
80005948:	c1 30       	breq	8000596e <ctl_perform_all_changes+0x32>
8000594a:	30 06       	mov	r6,0
8000594c:	e0 67 07 80 	mov	r7,1920
    idx = ctlBuf[i].idx;
80005950:	e0 62 08 80 	mov	r2,2176
    bfin_set_param(idx, ctlBuf[i].val.fix);
80005954:	0c 93       	mov	r3,r6
80005956:	0f 85       	ld.ub	r5,r7[0x0]
80005958:	6e 1b       	ld.w	r11,r7[0x4]
  paramsDirty[idx] = 1;

}
// clear dirty flag
static void clear_param_dirty(u32 idx) {
  paramsDirty[idx] = 0;
8000595a:	0a 9c       	mov	r12,r5
8000595c:	cb 0e       	rcall	800056bc <bfin_set_param>

// attempt to execute all pending param changes
extern void ctl_perform_all_changes(void) {
  u32 idx, i;
  // execute in FIFO order
  for(i=0; i<evCount; i++) {
8000595e:	e4 05 0b 03 	st.b	r2[r5],r3
80005962:	2f f6       	sub	r6,-1
80005964:	2f 87       	sub	r7,-8
80005966:	68 08       	ld.w	r8,r4[0x0]
80005968:	0c 38       	cp.w	r8,r6
    idx = ctlBuf[i].idx;
    bfin_set_param(idx, ctlBuf[i].val.fix);
    clear_param_dirty(idx);
  }
  evCount = 0;
8000596a:	fe 9b ff f6 	brhi	80005956 <ctl_perform_all_changes+0x1a>
}
8000596e:	30 08       	mov	r8,0
80005970:	89 08       	st.w	r4[0x0],r8
80005972:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005976:	d7 03       	nop

80005978 <init_events>:
// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
80005978:	e0 6a 09 80 	mov	r10,2432
8000597c:	30 08       	mov	r8,0
  getIdx = 0;
8000597e:	95 08       	st.w	r10[0x0],r8

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
80005980:	e0 6a 09 84 	mov	r10,2436
void init_events( void ) {
  int k;
  
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;
80005984:	10 99       	mov	r9,r8

// The system event queue is a circular array of event records.
static event_t sysEvents[ MAX_EVENTS ];

// initializes (or re-initializes)  the system event queue.
void init_events( void ) {
80005986:	95 08       	st.w	r10[0x0],r8
80005988:	e0 68 09 88 	mov	r8,2440
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
8000598c:	f0 ca fe 00 	sub	r10,r8,-512
  // set queue (circular list) to empty
  putIdx = 0;
  getIdx = 0;

  // zero out the event records
  for ( k = 0; k < MAX_EVENTS; k++ ) {
80005990:	91 09       	st.w	r8[0x0],r9
80005992:	91 19       	st.w	r8[0x4],r9
    sysEvents[ k ].eventType = 0;
    sysEvents[ k ].eventData = 0;
  }
}
80005994:	2f 88       	sub	r8,-8
80005996:	14 38       	cp.w	r8,r10
80005998:	cf c1       	brne	80005990 <init_events+0x18>
8000599a:	5e fc       	retal	r12

8000599c <post_event>:
8000599c:	d4 01       	pushm	lr
8000599e:	d3 43       	ssrf	0x14
800059a0:	e0 69 09 80 	mov	r9,2432
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // increment write idx, posbily wrapping
  saveIndex = putIdx;
  INCR_EVENT_INDEX( putIdx );
800059a4:	72 0a       	ld.w	r10,r9[0x0]
800059a6:	f4 c8 ff ff 	sub	r8,r10,-1
800059aa:	93 08       	st.w	r9[0x0],r8
800059ac:	e0 48 00 40 	cp.w	r8,64
800059b0:	f9 b8 00 00 	moveq	r8,0
800059b4:	f3 f8 0a 00 	st.weq	r9[0x0],r8
  if ( putIdx != getIdx  ) {
800059b8:	e0 6b 09 84 	mov	r11,2436
800059bc:	76 0b       	ld.w	r11,r11[0x0]
    sysEvents[ putIdx ].eventType = e->eventType;
800059be:	10 3b       	cp.w	r11,r8
800059c0:	c0 d0       	breq	800059da <post_event+0x3e>
800059c2:	78 0a       	ld.w	r10,r12[0x0]
800059c4:	e0 69 09 88 	mov	r9,2440
    sysEvents[ putIdx ].eventData = e->eventData;
800059c8:	f2 08 09 3a 	st.w	r9[r8<<0x3],r10
800059cc:	f2 08 00 38 	add	r8,r9,r8<<0x3
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
    print_dbg("\r\n event queue full!");
  } 

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
800059d0:	78 19       	ld.w	r9,r12[0x4]
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
800059d2:	30 1c       	mov	r12,1
    sysEvents[ putIdx ].eventType = e->eventType;
    sysEvents[ putIdx ].eventData = e->eventData;
    status = true;
  } else {
    // idx wrapped, so queue is full, restore idx
    putIdx = saveIndex;
800059d4:	91 19       	st.w	r8[0x4],r9
    print_dbg("\r\n event queue full!");
800059d6:	d5 43       	csrf	0x14
800059d8:	d8 02       	popm	pc
800059da:	93 0a       	st.w	r9[0x0],r10
800059dc:	fe cc a5 3c 	sub	r12,pc,-23236
  //  if (fReenableInterrupts) {
  //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }

  return status;
}
800059e0:	fe b0 e9 ec 	rcall	80002db8 <print_dbg>
800059e4:	30 0c       	mov	r12,0
800059e6:	d5 43       	csrf	0x14
800059e8:	d8 02       	popm	pc
800059ea:	d7 03       	nop

800059ec <get_next_event>:
800059ec:	18 99       	mov	r9,r12
800059ee:	d3 43       	ssrf	0x14
800059f0:	e0 68 09 80 	mov	r8,2432
800059f4:	e0 6a 09 84 	mov	r10,2436
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
800059f8:	70 0b       	ld.w	r11,r8[0x0]
800059fa:	74 08       	ld.w	r8,r10[0x0]
    INCR_EVENT_INDEX( getIdx );
800059fc:	16 38       	cp.w	r8,r11
800059fe:	c1 50       	breq	80005a28 <get_next_event+0x3c>
80005a00:	2f f8       	sub	r8,-1
80005a02:	95 08       	st.w	r10[0x0],r8
80005a04:	e0 48 00 40 	cp.w	r8,64
80005a08:	f9 b8 00 00 	moveq	r8,0
    e->eventType = sysEvents[ getIdx ].eventType;
80005a0c:	f5 f8 0a 00 	st.weq	r10[0x0],r8
    e->eventData = sysEvents[ getIdx ].eventData;
80005a10:	e0 6a 09 88 	mov	r10,2440
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // if pointers are equal, the queue is empty... don't allow idx's to wrap!
  if ( getIdx != putIdx ) {
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
80005a14:	f4 08 00 3b 	add	r11,r10,r8<<0x3
    e->eventData = sysEvents[ getIdx ].eventData;
80005a18:	f4 08 03 38 	ld.w	r8,r10[r8<<0x3]
80005a1c:	99 08       	st.w	r12[0x0],r8
    e->eventType  = 0xff;
    e->eventData = 0;
    status = false;
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80005a1e:	76 18       	ld.w	r8,r11[0x4]
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
80005a20:	99 18       	st.w	r12[0x4],r8
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
    e->eventData = 0;
80005a22:	30 1c       	mov	r12,1
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
80005a24:	d5 43       	csrf	0x14
80005a26:	5e fc       	retal	r12
    e->eventData = 0;
80005a28:	30 0c       	mov	r12,0
    INCR_EVENT_INDEX( getIdx );
    e->eventType = sysEvents[ getIdx ].eventType;
    e->eventData = sysEvents[ getIdx ].eventData;
    status = true;
  } else {
    e->eventType  = 0xff;
80005a2a:	e0 68 00 ff 	mov	r8,255
  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
  //  if (fReenableInterrupts) {
    //    Enable_interrupt_level( TIMER_INT_LEVEL );
  //  }
  return status;
}
80005a2e:	93 1c       	st.w	r9[0x4],r12
80005a30:	93 08       	st.w	r9[0x0],r8
80005a32:	d5 43       	csrf	0x14
80005a34:	5e fc       	retal	r12
80005a36:	d7 03       	nop

80005a38 <process_enc>:
    enc[i].thresh = ENC_THRESH_DEFAULT;
  }
}

// apply pin mapping to deteremine movement
void process_enc( const U8 idx) {
80005a38:	eb cd 40 f8 	pushm	r3-r7,lr
  U8 pos;
  
  pos = gpio_get_pin_value(enc[idx].pin[0]) + (gpio_get_pin_value(enc[idx].pin[1]) << 1);
80005a3c:	e0 65 2c 78 	mov	r5,11384
80005a40:	f8 0c 00 14 	add	r4,r12,r12<<0x1
80005a44:	ea 04 00 26 	add	r6,r5,r4<<0x2
80005a48:	0c 97       	mov	r7,r6
80005a4a:	0f 3c       	ld.ub	r12,r7++
80005a4c:	fe b0 e5 4c 	rcall	800024e4 <gpio_get_pin_value>
80005a50:	18 93       	mov	r3,r12
80005a52:	0f 8c       	ld.ub	r12,r7[0x0]
80005a54:	fe b0 e5 48 	rcall	800024e4 <gpio_get_pin_value>
80005a58:	0d a8       	ld.ub	r8,r6[0x2]
80005a5a:	e6 0c 00 13 	add	r3,r3,r12<<0x1
  
  if (pos != enc[idx].pos) {
80005a5e:	5c 53       	castu.b	r3
80005a60:	e6 08 18 00 	cp.b	r8,r3
    enc[idx].val -= enc_map[enc[idx].pos][pos];
80005a64:	c0 e0       	breq	80005a80 <process_enc+0x48>
80005a66:	2f f4       	sub	r4,-1
80005a68:	e6 08 00 28 	add	r8,r3,r8<<0x2
80005a6c:	ea 04 04 29 	ld.sh	r9,r5[r4<<0x2]
80005a70:	fe ca a5 bb 	sub	r10,pc,-23109
80005a74:	f4 08 06 08 	ld.sb	r8,r10[r8]
80005a78:	10 19       	sub	r9,r8
    enc[idx].pos = pos;
80005a7a:	ea 04 0a 29 	st.h	r5[r4<<0x2],r9
80005a7e:	ac a3       	st.b	r6[0x2],r3
80005a80:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

80005a84 <init_encoders>:
80005a84:	d4 21       	pushm	r4-r7,lr
80005a86:	32 29       	mov	r9,34
80005a88:	e0 68 2c 78 	mov	r8,11384
// initialize encoder positions
void init_encoders(void) {
  U8 i;
  // constant data
  enc[0].pin[0] = ENC0_S0_PIN;
  enc[0].pin[1] = ENC0_S1_PIN;
80005a8c:	b0 89       	st.b	r8[0x0],r9
80005a8e:	32 39       	mov	r9,35
  enc[0].event = kEventEncoder0;
80005a90:	b0 99       	st.b	r8[0x1],r9
80005a92:	30 d9       	mov	r9,13
  enc[1].pin[0] = ENC1_S0_PIN;
80005a94:	91 29       	st.w	r8[0x8],r9
80005a96:	32 49       	mov	r9,36
80005a98:	f1 69 00 0c 	st.b	r8[12],r9
  enc[1].pin[1] = ENC1_S1_PIN;
80005a9c:	32 59       	mov	r9,37
80005a9e:	f1 69 00 0d 	st.b	r8[13],r9
  enc[1].event = kEventEncoder1;
80005aa2:	30 e9       	mov	r9,14
  enc[2].pin[0] = ENC2_S0_PIN;
80005aa4:	91 59       	st.w	r8[0x14],r9
80005aa6:	32 69       	mov	r9,38
80005aa8:	f1 69 00 18 	st.b	r8[24],r9
  enc[2].pin[1] = ENC2_S1_PIN;
80005aac:	32 79       	mov	r9,39
80005aae:	f1 69 00 19 	st.b	r8[25],r9
  enc[2].event = kEventEncoder2;
80005ab2:	30 f9       	mov	r9,15
  enc[3].pin[0] = ENC3_S0_PIN;
80005ab4:	91 89       	st.w	r8[0x20],r9
80005ab6:	32 89       	mov	r9,40
80005ab8:	f1 69 00 24 	st.b	r8[36],r9
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
80005abc:	32 99       	mov	r9,41
  enc[1].event = kEventEncoder1;
  enc[2].pin[0] = ENC2_S0_PIN;
  enc[2].pin[1] = ENC2_S1_PIN;
  enc[2].event = kEventEncoder2;
  enc[3].pin[0] = ENC3_S0_PIN;
  enc[3].pin[1] = ENC3_S1_PIN;
80005abe:	10 97       	mov	r7,r8
80005ac0:	f1 69 00 25 	st.b	r8[37],r9

//------------------------------
//----- external functions

// initialize encoder positions
void init_encoders(void) {
80005ac4:	f0 c4 ff d0 	sub	r4,r8,-48
80005ac8:	31 09       	mov	r9,16
  enc[2].pin[0] = ENC2_S0_PIN;
  enc[2].pin[1] = ENC2_S1_PIN;
  enc[2].event = kEventEncoder2;
  enc[3].pin[0] = ENC3_S0_PIN;
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
80005aca:	32 2c       	mov	r12,34
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
    enc[i].thresh = ENC_THRESH_DEFAULT;
80005acc:	91 b9       	st.w	r8[0x2c],r9
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
    enc[i].pos = gpio_get_pin_value(enc[i].pin[0]) + (gpio_get_pin_value(enc[i].pin[1]) << 1);
80005ace:	30 05       	mov	r5,0
80005ad0:	fe b0 e5 0a 	rcall	800024e4 <gpio_get_pin_value>
80005ad4:	18 96       	mov	r6,r12
80005ad6:	0f 9c       	ld.ub	r12,r7[0x1]
80005ad8:	fe b0 e5 06 	rcall	800024e4 <gpio_get_pin_value>
80005adc:	ae 35       	st.h	r7[0x6],r5
80005ade:	ec 0c 00 1c 	add	r12,r6,r12<<0x1
    enc[i].thresh = ENC_THRESH_DEFAULT;
80005ae2:	ae ac       	st.b	r7[0x2],r12
  enc[3].pin[0] = ENC3_S0_PIN;
  enc[3].pin[1] = ENC3_S1_PIN;
  enc[3].event = kEventEncoder3;
  
  // realtime initial pin values
  for(i=0; i<NUM_ENC; i++) {
80005ae4:	2f 47       	sub	r7,-12
80005ae6:	08 37       	cp.w	r7,r4
80005ae8:	c0 30       	breq	80005aee <init_encoders+0x6a>
80005aea:	0f 8c       	ld.ub	r12,r7[0x0]
80005aec:	cf 2b       	rjmp	80005ad0 <init_encoders+0x4c>
80005aee:	d8 22       	popm	r4-r7,pc

80005af0 <fat_init>:


//=========
// extern

int fat_init(void) {
80005af0:	d4 21       	pushm	r4-r7,lr
  u8 ret = 0;
  // Initialise File IO Library
  print_dbg("\r\n beginning FAT library init.");
80005af2:	fe cc a6 2a 	sub	r12,pc,-22998
80005af6:	fe b0 e9 61 	rcall	80002db8 <print_dbg>
  fl_init();
80005afa:	e0 a0 15 3b 	rcall	80008570 <fl_init>
  print_dbg("\r\n finished FAT library init.");
80005afe:	fe cc a6 16 	sub	r12,pc,-23018

  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
80005b02:	fe b0 e9 5b 	rcall	80002db8 <print_dbg>
80005b06:	fe cb fe ea 	sub	r11,pc,-278
80005b0a:	fe cc fe 8a 	sub	r12,pc,-374
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
    //    return 1;
    ret = 1;
  } else {
    print_dbg("\r\n attached media access functions to fat_io_lib");
80005b0e:	e0 a0 1a 5b 	rcall	80008fc4 <fl_attach_media>
80005b12:	c7 91       	brne	80005c04 <fat_init+0x114>
static u8 file_read_write_test(void) {
  void* fp;
  u8 ret;
  u8 i;

  app_pause();
80005b14:	18 97       	mov	r7,r12
80005b16:	fe cc a5 d2 	sub	r12,pc,-23086

  //  delay_ms(10);

  fp = fl_fopen("/aleph_test.txt", "w");
80005b1a:	fe b0 e9 4f 	rcall	80002db8 <print_dbg>
80005b1e:	fe b0 fd 19 	rcall	80005550 <app_pause>
  print_dbg("\r\n test sdcard write, fp: ");
80005b22:	fe cb a5 aa 	sub	r11,pc,-23126
80005b26:	fe cc a5 aa 	sub	r12,pc,-23126
  print_dbg_hex((u32)fp);
80005b2a:	e0 a0 19 0f 	rcall	80008d48 <fl_fopen>
  fl_fputs(test_string_write, fp);
80005b2e:	18 96       	mov	r6,r12
80005b30:	fe cc a5 a4 	sub	r12,pc,-23132
80005b34:	fe b0 e9 42 	rcall	80002db8 <print_dbg>
  fl_fclose(fp);
80005b38:	0c 9c       	mov	r12,r6
80005b3a:	fe b0 e9 11 	rcall	80002d5c <print_dbg_hex>

  print_dbg("\r\n waiting after write...");
80005b3e:	0c 9b       	mov	r11,r6
80005b40:	fe cc a4 70 	sub	r12,pc,-23440
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80005b44:	e0 a0 17 9c 	rcall	80008a7c <fl_fputs>
80005b48:	0c 9c       	mov	r12,r6
80005b4a:	e0 a0 18 33 	rcall	80008bb0 <fl_fclose>
80005b4e:	fe cc a5 a6 	sub	r12,pc,-23130
80005b52:	fe b0 e9 33 	rcall	80002db8 <print_dbg>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80005b56:	e0 68 03 e8 	mov	r8,1000
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80005b5a:	30 09       	mov	r9,0
80005b5c:	e0 6a 0d e7 	mov	r10,3559
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80005b60:	ea 1a ae f4 	orh	r10,0xaef4
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80005b64:	30 7b       	mov	r11,7
80005b66:	e0 a0 22 a3 	rcall	8000a0ac <__avr32_udiv64>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80005b6a:	e1 b8 00 42 	mfsr	r8,0x108
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80005b6e:	f0 0a 00 0a 	add	r10,r8,r10
  delay_ms(500);

  fp = fl_fopen("/aleph_test.txt", "r");
80005b72:	e1 b9 00 42 	mfsr	r9,0x108
80005b76:	14 38       	cp.w	r8,r10
80005b78:	e0 88 00 42 	brls	80005bfc <fat_init+0x10c>
  print_dbg("\r\n test sdcard read, fp: ");
80005b7c:	12 38       	cp.w	r8,r9
80005b7e:	fe 98 ff fa 	brls	80005b72 <fat_init+0x82>
  print_dbg_hex((u32)fp);
80005b82:	12 3a       	cp.w	r10,r9
80005b84:	cf 72       	brcc	80005b72 <fat_init+0x82>


//=========
// extern

int fat_init(void) {
80005b86:	fe cb 96 b6 	sub	r11,pc,-26954
  print_dbg("\r\n waiting after write...");
  delay_ms(500);

  fp = fl_fopen("/aleph_test.txt", "r");
  print_dbg("\r\n test sdcard read, fp: ");
  print_dbg_hex((u32)fp);
80005b8a:	fe cc a6 0e 	sub	r12,pc,-23026
  for(i=0; i<TESTN; i++) {
    test_string_read[i] = fl_fgetc(fp);
80005b8e:	e0 a0 18 dd 	rcall	80008d48 <fl_fopen>
80005b92:	18 96       	mov	r6,r12
80005b94:	fe cc a5 54 	sub	r12,pc,-23212
  delay_ms(500);

  fp = fl_fopen("/aleph_test.txt", "r");
  print_dbg("\r\n test sdcard read, fp: ");
  print_dbg_hex((u32)fp);
  for(i=0; i<TESTN; i++) {
80005b98:	fe b0 e9 10 	rcall	80002db8 <print_dbg>
    test_string_read[i] = fl_fgetc(fp);
  }
  //  fl_fread(test_string_read, 1, 11, fp);
  print_dbg(" , read: ");
80005b9c:	e0 65 0b 88 	mov	r5,2952
  print_dbg(test_string_read);
80005ba0:	0c 9c       	mov	r12,r6
80005ba2:	ea c4 ff f6 	sub	r4,r5,-10

  if(strncmp(test_string_write, test_string_read, TESTN)) {
80005ba6:	fe b0 e8 db 	rcall	80002d5c <print_dbg_hex>
80005baa:	0c 9c       	mov	r12,r6
80005bac:	e0 a0 17 f2 	rcall	80008b90 <fl_fgetc>
80005bb0:	0a cc       	st.b	r5++,r12
    ret = 1;
    print_dbg("\r\n ERROR: sdcard write / read mismatch");
  } else {
    ret = 0;
    print_dbg("\r\n OK: sdcard write / read match");
80005bb2:	08 35       	cp.w	r5,r4
80005bb4:	cf b1       	brne	80005baa <fat_init+0xba>
80005bb6:	fe cc a5 f2 	sub	r12,pc,-23054
  }

  fl_fclose(fp);
80005bba:	fe b0 e8 ff 	rcall	80002db8 <print_dbg>
80005bbe:	e0 6c 0b 88 	mov	r12,2952

  app_resume();
80005bc2:	fe b0 e8 fb 	rcall	80002db8 <print_dbg>

  print_dbg("\r\n finished sdcard write/read test.");
80005bc6:	30 aa       	mov	r10,10
80005bc8:	e0 6b 0b 88 	mov	r11,2952
80005bcc:	fe cc a4 fc 	sub	r12,pc,-23300
  }

  ret |= file_read_write_test();
  return ret;

}
80005bd0:	e0 a0 26 a3 	rcall	8000a916 <strncmp>
80005bd4:	c1 e1       	brne	80005c10 <fat_init+0x120>
80005bd6:	18 95       	mov	r5,r12
80005bd8:	fe cc a5 e0 	sub	r12,pc,-23072
  fl_init();
  print_dbg("\r\n finished FAT library init.");

  // Attach media access functions to library
  if ( fl_attach_media((fn_diskio_read)media_read, (fn_diskio_write)media_write) != FAT_INIT_OK ) {
    print_dbg("\r\n failed to attach media access functions to fat_io_lib \r\n");
80005bdc:	fe b0 e8 ee 	rcall	80002db8 <print_dbg>
80005be0:	0c 9c       	mov	r12,r6
80005be2:	e0 a0 17 e7 	rcall	80008bb0 <fl_fclose>
  print_dbg(" , read: ");
  print_dbg(test_string_read);

  if(strncmp(test_string_write, test_string_read, TESTN)) {
    ret = 1;
    print_dbg("\r\n ERROR: sdcard write / read mismatch");
80005be6:	fe b0 fc b1 	rcall	80005548 <app_resume>
80005bea:	fe cc a5 ce 	sub	r12,pc,-23090
80005bee:	fe b0 e8 e5 	rcall	80002db8 <print_dbg>
80005bf2:	eb e7 10 07 	or	r7,r5,r7
80005bf6:	0e 9c       	mov	r12,r7
80005bf8:	5c 5c       	castu.b	r12
80005bfa:	d8 22       	popm	r4-r7,pc
80005bfc:	12 38       	cp.w	r8,r9
80005bfe:	fe 9b ff c4 	brhi	80005b86 <fat_init+0x96>
80005c02:	cc 0b       	rjmp	80005b82 <fat_init+0x92>
80005c04:	fe cc a6 fc 	sub	r12,pc,-22788
80005c08:	fe b0 e8 d8 	rcall	80002db8 <print_dbg>
80005c0c:	30 17       	mov	r7,1
80005c0e:	c8 8b       	rjmp	80005b1e <fat_init+0x2e>
80005c10:	fe cc a6 40 	sub	r12,pc,-22976
80005c14:	30 15       	mov	r5,1
80005c16:	fe b0 e8 d1 	rcall	80002db8 <print_dbg>
80005c1a:	ce 3b       	rjmp	80005be0 <fat_init+0xf0>

80005c1c <media_write>:
80005c1c:	eb cd 40 f8 	pushm	r3-r7,lr
80005c20:	16 97       	mov	r7,r11
80005c22:	14 94       	mov	r4,r10
80005c24:	18 93       	mov	r3,r12
80005c26:	fe b0 e9 b7 	rcall	80002f94 <sd_mmc_spi_write_open>
80005c2a:	18 96       	mov	r6,r12
80005c2c:	c1 f0       	breq	80005c6a <media_write+0x4e>
80005c2e:	58 04       	cp.w	r4,0
80005c30:	c1 90       	breq	80005c62 <media_write+0x46>
80005c32:	30 06       	mov	r6,0
80005c34:	c0 48       	rjmp	80005c3c <media_write+0x20>
80005c36:	0c 34       	cp.w	r4,r6
80005c38:	e0 88 00 15 	brls	80005c62 <media_write+0x46>
80005c3c:	ec 03 00 05 	add	r5,r6,r3
80005c40:	0e 9c       	mov	r12,r7
80005c42:	2f f6       	sub	r6,-1
80005c44:	ee c7 fe 00 	sub	r7,r7,-512
80005c48:	fe b0 ea 4a 	rcall	800030dc <sd_mmc_spi_write_sector_from_ram>
80005c4c:	cf 51       	brne	80005c36 <media_write+0x1a>
80005c4e:	fe cc a5 ca 	sub	r12,pc,-23094
80005c52:	fe b0 e8 b3 	rcall	80002db8 <print_dbg>
80005c56:	0a 9c       	mov	r12,r5
80005c58:	fe b0 e8 82 	rcall	80002d5c <print_dbg_hex>
80005c5c:	0c 34       	cp.w	r4,r6
80005c5e:	fe 9b ff ef 	brhi	80005c3c <media_write+0x20>
80005c62:	fe b0 e9 3b 	rcall	80002ed8 <sd_mmc_spi_write_close>
80005c66:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
  // for the moment use slower blocking write.

  status = sd_mmc_spi_write_open(sector);

  if(status == false) {
    print_dbg("\r\n error opening sd_mmc_spi, sector: ");
80005c6a:	fe cc a6 0e 	sub	r12,pc,-23026
    print_dbg_hex(sector);
80005c6e:	fe b0 e8 a5 	rcall	80002db8 <print_dbg>
80005c72:	06 9c       	mov	r12,r3
80005c74:	fe b0 e8 74 	rcall	80002d5c <print_dbg_hex>
    return 0;
80005c78:	0c 9c       	mov	r12,r6
80005c7a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005c7e:	d7 03       	nop

80005c80 <media_read>:
80005c80:	d4 31       	pushm	r0-r7,lr
80005c82:	18 94       	mov	r4,r12
80005c84:	16 97       	mov	r7,r11
80005c86:	14 91       	mov	r1,r10
80005c88:	58 0a       	cp.w	r10,0
80005c8a:	c5 40       	breq	80005d32 <media_read+0xb2>
80005c8c:	30 03       	mov	r3,0
80005c8e:	e0 66 2e b4 	mov	r6,11956
80005c92:	e0 65 2c ac 	mov	r5,11436
80005c96:	30 10       	mov	r0,1
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_RX,
80005c98:	06 92       	mov	r2,r3
80005c9a:	e0 6a 02 00 	mov	r10,512
80005c9e:	e0 6b 2e b4 	mov	r11,11956
		       &pdcaRxBuf,
		       FS_BUF_SIZE);
    
    pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_TX,
80005ca2:	30 0c       	mov	r12,0
80005ca4:	fe b0 e5 64 	rcall	8000276c <pdca_load_channel>
80005ca8:	30 1c       	mov	r12,1
80005caa:	e0 6a 02 00 	mov	r10,512
		       (void *)&pdcaTxBuf,
		       FS_BUF_SIZE); //send dummy to activate the clock
    
    fsEndTransfer = false;
    
    if(sd_mmc_spi_read_open_PDCA (sector)) {
80005cae:	e0 6b 2c b4 	mov	r11,11444
80005cb2:	fe b0 e5 5d 	rcall	8000276c <pdca_load_channel>
80005cb6:	08 9c       	mov	r12,r4

      spi_write(SD_MMC_SPI,0xFF); // dummy byte synchronizes transfer
80005cb8:	aa 82       	st.b	r5[0x0],r2
80005cba:	fe b0 ea 91 	rcall	800031dc <sd_mmc_spi_read_open_PDCA>
80005cbe:	c2 f0       	breq	80005d1c <media_read+0x9c>
80005cc0:	e0 6b 00 ff 	mov	r11,255

      pdca_enable_interrupt_transfer_complete(AVR32_PDCA_CHANNEL_SPI_RX);
80005cc4:	fe 7c 28 00 	mov	r12,-55296
80005cc8:	fe b0 e6 6f 	rcall	800029a6 <spi_write>
      pdcaRxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_RX);
80005ccc:	30 0c       	mov	r12,0
80005cce:	fe b0 e5 16 	rcall	800026fa <pdca_enable_interrupt_transfer_complete>
80005cd2:	30 0c       	mov	r12,0
      pdcaTxChan =(volatile avr32_pdca_channel_t*) pdca_get_handler(AVR32_PDCA_CHANNEL_SPI_TX);
80005cd4:	fe b0 e4 fa 	rcall	800026c8 <pdca_get_handler>
80005cd8:	e0 63 2c a8 	mov	r3,11432
80005cdc:	87 0c       	st.w	r3[0x0],r12
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
80005cde:	30 1c       	mov	r12,1
80005ce0:	fe b0 e4 f4 	rcall	800026c8 <pdca_get_handler>
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
80005ce4:	e0 68 2c b0 	mov	r8,11440
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
80005ce8:	91 0c       	st.w	r8[0x0],r12
80005cea:	66 09       	ld.w	r9,r3[0x0]
80005cec:	93 50       	st.w	r9[0x14],r0
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
80005cee:	70 08       	ld.w	r8,r8[0x0]
80005cf0:	91 50       	st.w	r8[0x14],r0
80005cf2:	0b 88       	ld.ub	r8,r5[0x0]
80005cf4:	58 08       	cp.w	r8,0
      pdcaRxChan->cr = AVR32_PDCA_TEN_MASK; // Enable RX PDCA transfer first
      pdcaTxChan->cr = AVR32_PDCA_TEN_MASK; // and TX PDCA transfer
      // wait for signal from ISR
      while(!fsEndTransfer) { ;; }
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
80005cf6:	cf e0       	breq	80005cf2 <media_read+0x72>
80005cf8:	30 08       	mov	r8,0
80005cfa:	ec 08 07 09 	ld.ub	r9,r6[r8]
80005cfe:	ee 08 0b 09 	st.b	r7[r8],r9
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
80005d02:	2f f8       	sub	r8,-1
80005d04:	e0 48 02 00 	cp.w	r8,512
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
      print_dbg_ulong(sector);
    }
    sector ++;
80005d08:	cf 91       	brne	80005cfa <media_read+0x7a>
    buffer += FS_BUF_SIZE;
80005d0a:	e0 63 02 01 	mov	r3,513
80005d0e:	06 31       	cp.w	r1,r3
      // copy FIXME: could optimize away
      for(i=0; i<FS_BUF_SIZE; i++) {
	buffer[i] = pdcaRxBuf[i];
      }
    } else {
      print_dbg("\r\n error opening PDCA at sector "); 
80005d10:	e0 88 00 11 	brls	80005d32 <media_read+0xb2>
80005d14:	2f f4       	sub	r4,-1
      print_dbg_ulong(sector);
80005d16:	ee c7 fe 00 	sub	r7,r7,-512
80005d1a:	cc 0b       	rjmp	80005c9a <media_read+0x1a>
80005d1c:	fe cc a6 70 	sub	r12,pc,-22928
//---- low level i/o
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count);
int media_read(unsigned long sector, unsigned char *buffer, unsigned long sector_count) {
  unsigned long i;

  for (i=0;i<sector_count;i++) {
80005d20:	fe b0 e8 4c 	rcall	80002db8 <print_dbg>
    }
    sector ++;
    buffer += FS_BUF_SIZE;
  }
  return 1;
}
80005d24:	2f f3       	sub	r3,-1
80005d26:	08 9c       	mov	r12,r4
80005d28:	fe b0 e8 42 	rcall	80002dac <print_dbg_ulong>
80005d2c:	06 31       	cp.w	r1,r3
80005d2e:	fe 9b ff f3 	brhi	80005d14 <media_read+0x94>
80005d32:	da 3a       	popm	r0-r7,pc,r12=1

80005d34 <flash_write_firstrun>:
extern u8 flash_read_firstrun(void) {
  return (flash_nvram_data.firstRun == FIRSTRUN_MAGIC);
}

// write firstrun status
extern void flash_write_firstrun(void) {
80005d34:	d4 01       	pushm	lr
  flashc_memset32((void*)&(flash_nvram_data.firstRun), FIRSTRUN_MAGIC, 4, true);
80005d36:	30 19       	mov	r9,1
80005d38:	30 4a       	mov	r10,4
80005d3a:	e0 6b 32 10 	mov	r11,12816
80005d3e:	ea 1b 76 54 	orh	r11,0x7654
80005d42:	48 3c       	lddpc	r12,80005d4c <flash_write_firstrun+0x18>
80005d44:	fe b0 e3 7c 	rcall	8000243c <flashc_memset32>
}
80005d48:	d8 02       	popm	pc
80005d4a:	d7 03       	nop
80005d4c:	80 04       	ld.sh	r4,r0[0x0]
	...

80005d50 <init_flash>:
80005d50:	d4 01       	pushm	lr
80005d52:	fe cc a6 56 	sub	r12,pc,-22954

// intiailize (alloc mem, check/set firstrun bytes)
u8 init_flash() {
  u32 i;

  print_dbg("\r\n init flash... ");
80005d56:	fe b0 e8 31 	rcall	80002db8 <print_dbg>

  // allocate bfin loader buf
  bfinLdrData = alloc_mem(BFIN_LDR_MAX_BYTES);
80005d5a:	e0 7c 00 00 	mov	r12,65536
80005d5e:	e0 a0 03 1f 	rcall	8000639c <alloc_mem>
80005d62:	e0 6a 30 b4 	mov	r10,12468
  for(i=0; i<BFIN_LDR_MAX_BYTES; i++) { bfinLdrData[i] = 0; }
80005d66:	30 08       	mov	r8,0
80005d68:	95 0c       	st.w	r10[0x0],r12
80005d6a:	10 99       	mov	r9,r8
80005d6c:	c0 28       	rjmp	80005d70 <init_flash+0x20>
80005d6e:	74 0c       	ld.w	r12,r10[0x0]
80005d70:	10 0c       	add	r12,r8
80005d72:	b8 89       	st.b	r12[0x0],r9
80005d74:	2f f8       	sub	r8,-1
80005d76:	e0 58 00 00 	cp.w	r8,65536

  if(flash_nvram_data.firstRun != FIRSTRUN_MAGIC) {
80005d7a:	cf a1       	brne	80005d6e <init_flash+0x1e>
80005d7c:	48 ac       	lddpc	r12,80005da4 <init_flash+0x54>
80005d7e:	e0 69 32 10 	mov	r9,12816
80005d82:	ea 19 76 54 	orh	r9,0x7654
80005d86:	78 08       	ld.w	r8,r12[0x0]
    // set size=0 so we won't attempt unitialized bfin load on next start
    bfinLdrSize = 0;
80005d88:	12 38       	cp.w	r8,r9
80005d8a:	c0 c0       	breq	80005da2 <init_flash+0x52>
    flashc_memset32((void*)&(flash_nvram_data.ldrSize), 0x00000000, 4, true);
80005d8c:	30 08       	mov	r8,0
  bfinLdrData = alloc_mem(BFIN_LDR_MAX_BYTES);
  for(i=0; i<BFIN_LDR_MAX_BYTES; i++) { bfinLdrData[i] = 0; }

  if(flash_nvram_data.firstRun != FIRSTRUN_MAGIC) {
    // set size=0 so we won't attempt unitialized bfin load on next start
    bfinLdrSize = 0;
80005d8e:	e0 69 0b 94 	mov	r9,2964
    flashc_memset32((void*)&(flash_nvram_data.ldrSize), 0x00000000, 4, true);
80005d92:	10 9b       	mov	r11,r8
80005d94:	93 08       	st.w	r9[0x0],r8
80005d96:	30 4a       	mov	r10,4
80005d98:	30 19       	mov	r9,1
80005d9a:	2f cc       	sub	r12,-4

  // allocate bfin loader buf
  bfinLdrData = alloc_mem(BFIN_LDR_MAX_BYTES);
  for(i=0; i<BFIN_LDR_MAX_BYTES; i++) { bfinLdrData[i] = 0; }

  if(flash_nvram_data.firstRun != FIRSTRUN_MAGIC) {
80005d9c:	fe b0 e3 50 	rcall	8000243c <flashc_memset32>
80005da0:	da 0a       	popm	pc,r12=1
80005da2:	d8 0a       	popm	pc,r12=0
80005da4:	80 04       	ld.sh	r4,r0[0x0]
	...

80005da8 <font_glyph>:

// render single glyph to a flat buffer (1byte = 1px)
// given pointer to buffer, pixel offset, row length,
// foreground and background colors
// return columns used
extern u8* font_glyph(char ch, u8* buf, u8 w, u8 a, u8 b) {
80005da8:	d4 31       	pushm	r0-r7,lr
  u8 i=0;
  u8 j;
  const glyph_t* gl = &(font_data[ch - FONT_ASCII_OFFSET]);
80005daa:	fe c6 a6 9c 	sub	r6,pc,-22884
80005dae:	f8 ce 00 20 	sub	lr,r12,32
80005db2:	ec 0e 00 36 	add	r6,r6,lr<<0x3
  // columns to draw
  u8 cols = FONT_CHARW - gl->first - gl->last;
80005db6:	0d 87       	ld.ub	r7,r6[0x0]
80005db8:	0d 9c       	ld.ub	r12,r6[0x1]
80005dba:	ee 00 11 00 	rsub	r0,r7,0
80005dbe:	18 10       	sub	r0,r12
80005dc0:	5c 50       	castu.b	r0
80005dc2:	e0 c2 ff fa 	sub	r2,r0,-6
  // bytes per column
  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  buf = buf + (y*w + x);
  //  print_dbg("\r\n");
  while(i < cols) {
80005dc6:	5c 52       	castu.b	r2
80005dc8:	c2 70       	breq	80005e16 <font_glyph+0x6e>
80005dca:	16 93       	mov	r3,r11

// render single glyph to a flat buffer (1byte = 1px)
// given pointer to buffer, pixel offset, row length,
// foreground and background colors
// return columns used
extern u8* font_glyph(char ch, u8* buf, u8 w, u8 a, u8 b) {
80005dcc:	30 04       	mov	r4,0
  // bytes per column
  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  buf = buf + (y*w + x);
  //  print_dbg("\r\n");
  while(i < cols) {
80005dce:	30 11       	mov	r1,1
80005dd0:	06 9e       	mov	lr,r3
80005dd2:	30 0c       	mov	r12,0
80005dd4:	ec 04 00 05 	add	r5,r6,r4
80005dd8:	c0 28       	rjmp	80005ddc <font_glyph+0x34>
    for(j=0; j<FONT_CHARH; j++) {
      *buf = gl->data[i + gl->first] & (1 << j) ? a : b;
80005dda:	0d 87       	ld.ub	r7,r6[0x0]
80005ddc:	ea 07 00 07 	add	r7,r5,r7
80005de0:	0f a7       	ld.ub	r7,r7[0x2]
80005de2:	ee 0c 08 47 	asr	r7,r7,r12
80005de6:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
80005dea:	f2 07 17 10 	movne	r7,r9
80005dee:	f0 07 17 00 	moveq	r7,r8
      //      if(*buf) { print_dbg("#"); } else { print_dbg("_"); }
      // point at next row
      buf += w;
80005df2:	bc 87       	st.b	lr[0x0],r7
80005df4:	2f fc       	sub	r12,-1
  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  buf = buf + (y*w + x);
  //  print_dbg("\r\n");
  while(i < cols) {
    for(j=0; j<FONT_CHARH; j++) {
80005df6:	14 0e       	add	lr,r10
80005df8:	58 8c       	cp.w	r12,8

// render single glyph to a flat buffer (1byte = 1px)
// given pointer to buffer, pixel offset, row length,
// foreground and background colors
// return columns used
extern u8* font_glyph(char ch, u8* buf, u8 w, u8 a, u8 b) {
80005dfa:	cf 01       	brne	80005dda <font_glyph+0x32>
80005dfc:	02 03       	add	r3,r1
  // bytes per column
  u32 colOffset = FONT_CHARH * w - 1;
  // offset pointer
  //  buf = buf + (y*w + x);
  //  print_dbg("\r\n");
  while(i < cols) {
80005dfe:	2f f4       	sub	r4,-1
80005e00:	e8 02 18 00 	cp.b	r2,r4
80005e04:	e0 88 00 04 	brls	80005e0c <font_glyph+0x64>
80005e08:	0d 87       	ld.ub	r7,r6[0x0]
80005e0a:	ce 3b       	rjmp	80005dd0 <font_glyph+0x28>
80005e0c:	e0 c8 ff fb 	sub	r8,r0,-5
80005e10:	5c 58       	castu.b	r8
80005e12:	2f f8       	sub	r8,-1
    //    buf++;
    // increment column count
    i++;
  }
  return buf;
}
80005e14:	10 0b       	add	r11,r8
80005e16:	16 9c       	mov	r12,r11
80005e18:	d8 32       	popm	r0-r7,pc
80005e1a:	d7 03       	nop

80005e1c <init_usb_host>:
  gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
}


// initialize USB host stack
void init_usb_host (void) {
80005e1c:	d4 01       	pushm	lr
  //  pm_configure_usb_clock();
  uhc_start();
80005e1e:	fe b0 f7 39 	rcall	80004c90 <uhc_start>
}
80005e22:	d8 02       	popm	pc

80005e24 <init_bfin_resources>:
80005e24:	eb cd 40 80 	pushm	r7,lr
  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
}

// intialize resources for bf533 communication: SPI, GPIO
void init_bfin_resources(void) {
80005e28:	20 4d       	sub	sp,16
    //    .trans_delay  = 0,
    .trans_delay = 20,
    .stay_act     = 1,
    .spi_mode     = 1,
    .modfdis      = 1
  };
80005e2a:	fe c8 a3 e2 	sub	r8,pc,-23582
80005e2e:	f0 ea 00 08 	ld.d	r10,r8[8]
80005e32:	fa eb 00 08 	st.d	sp[8],r10
80005e36:	f0 e8 00 00 	ld.d	r8,r8[0]
80005e3a:	1a 97       	mov	r7,sp
80005e3c:	fa e9 00 00 	st.d	sp[0],r8

  // assign pins to SPI.
  gpio_enable_module(BFIN_SPI_GPIO_MAP,
80005e40:	30 4b       	mov	r11,4
80005e42:	fe cc a4 1a 	sub	r12,pc,-23526
		     sizeof(BFIN_SPI_GPIO_MAP) / sizeof(BFIN_SPI_GPIO_MAP[0]));

  // intialize as master
  spi_initMaster(BFIN_SPI, &spiOptions);
80005e46:	fe b0 e3 31 	rcall	800024a8 <gpio_enable_module>
80005e4a:	1a 9b       	mov	r11,sp
80005e4c:	fe 7c 24 00 	mov	r12,-56320

  // set selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(BFIN_SPI, 0, 0, 0);
80005e50:	fe b0 e4 e2 	rcall	80002814 <spi_initMaster>
80005e54:	30 09       	mov	r9,0
80005e56:	fe 7c 24 00 	mov	r12,-56320
80005e5a:	12 9a       	mov	r10,r9
80005e5c:	12 9b       	mov	r11,r9

  // enable SPI.
  spi_enable(BFIN_SPI);
80005e5e:	fe b0 e4 fa 	rcall	80002852 <spi_selectionMode>
80005e62:	fe 7c 24 00 	mov	r12,-56320

  // intialize the chip register
  spi_setupChipReg(BFIN_SPI, &spiOptions, FPBA_HZ);
80005e66:	fe b0 e5 9d 	rcall	800029a0 <spi_enable>
80005e6a:	1a 9b       	mov	r11,sp
80005e6c:	e0 6a 14 80 	mov	r10,5248
80005e70:	ea 1a 03 ef 	orh	r10,0x3ef
80005e74:	fe 7c 24 00 	mov	r12,-56320
  // enable pulldown on bfin HWAIT line
  //// shit! not implemented... 
  // gpio_enable_pin_pull_down(BFIN_HWAIT_PIN);
  
  // enable pullup on bfin RESET line
  gpio_enable_pin_pull_up(BFIN_RESET_PIN);
80005e78:	fe b0 e5 3e 	rcall	800028f4 <spi_setupChipReg>
80005e7c:	30 6c       	mov	r12,6
}
80005e7e:	fe b0 e3 29 	rcall	800024d0 <gpio_enable_pin_pull_up>
80005e82:	2f cd       	sub	sp,-16
80005e84:	e3 cd 80 80 	ldm	sp++,r7,pc

80005e88 <init_local_pdca>:
80005e88:	eb cd 40 b0 	pushm	r4-r5,r7,lr
80005e8c:	20 cd       	sub	sp,48
80005e8e:	fe ca a4 26 	sub	r10,pc,-23514
80005e92:	f4 e4 00 10 	ld.d	r4,r10[16]
80005e96:	fa c7 ff e8 	sub	r7,sp,-24
80005e9a:	fe c9 a4 8a 	sub	r9,pc,-23414
80005e9e:	ee e5 00 10 	st.d	r7[16],r4
80005ea2:	f2 e4 00 10 	ld.d	r4,r9[16]
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_RX,        // select peripheral ID - SPI1 RX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80005ea6:	fa e5 00 10 	st.d	sp[16],r4
80005eaa:	f4 e4 00 00 	ld.d	r4,r10[0]
80005eae:	ee e5 00 00 	st.d	r7[0],r4
80005eb2:	f4 e4 00 08 	ld.d	r4,r10[8]
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80005eb6:	ee e5 00 08 	st.d	r7[8],r4

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80005eba:	f2 e4 00 00 	ld.d	r4,r9[0]
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80005ebe:	1a 9b       	mov	r11,sp

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80005ec0:	fa e5 00 00 	st.d	sp[0],r4
    .size = FS_BUF_SIZE,                      // transfer size
    .r_addr = NULL,                           // next memory address after 1st transfer complete
    .r_size = 0,                              // next transfer counter not used here
    .pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - SPI1 TX
    .transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
  };
80005ec4:	30 1c       	mov	r12,1
80005ec6:	f2 e4 00 08 	ld.d	r4,r9[8]

  // Init PDCA transmission channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80005eca:	fa e5 00 08 	st.d	sp[8],r4

  // Init PDCA Reception channel
  pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
80005ece:	fe b0 e4 67 	rcall	8000279c <pdca_init_channel>
80005ed2:	0e 9b       	mov	r11,r7
80005ed4:	30 0c       	mov	r12,0
}
80005ed6:	fe b0 e4 63 	rcall	8000279c <pdca_init_channel>
80005eda:	2f 4d       	sub	sp,-48
80005edc:	e3 cd 80 b0 	ldm	sp++,r4-r5,r7,pc

80005ee0 <init_spi1>:
80005ee0:	d4 21       	pushm	r4-r7,lr
80005ee2:	20 4d       	sub	sp,16
80005ee4:	fe c8 a4 8c 	sub	r8,pc,-23412
    .trans_delay = 0,
    .spck_delay = 0,
    .stay_act = 1,
    .spi_mode = 3,
    .modfdis = 1
  };
80005ee8:	f0 ea 00 08 	ld.d	r10,r8[8]
80005eec:	fa eb 00 08 	st.d	sp[8],r10
80005ef0:	f0 e8 00 00 	ld.d	r8,r8[0]
80005ef4:	1a 97       	mov	r7,sp
80005ef6:	fa e9 00 00 	st.d	sp[0],r8

  // Assign GPIO to SPI.
  gpio_enable_module(OLED_SPI_GPIO_MAP,
80005efa:	30 6b       	mov	r11,6
80005efc:	fe cc a4 5c 	sub	r12,pc,-23460
		     sizeof(OLED_SPI_GPIO_MAP) / sizeof(OLED_SPI_GPIO_MAP[0]));
  // Initialize as master.
  spi_initMaster(OLED_SPI, &spiOptions);
80005f00:	fe b0 e2 d4 	rcall	800024a8 <gpio_enable_module>
80005f04:	1a 9b       	mov	r11,sp
80005f06:	fe 7c 28 00 	mov	r12,-55296
  // Set SPI selection mode: variable_ps, pcs_decode, delay.
  spi_selectionMode(OLED_SPI, 0, 0, 0);
80005f0a:	fe b0 e4 85 	rcall	80002814 <spi_initMaster>
80005f0e:	30 09       	mov	r9,0
80005f10:	fe 7c 28 00 	mov	r12,-55296
80005f14:	12 9a       	mov	r10,r9
80005f16:	12 9b       	mov	r11,r9
  // Enable SPI module.
  spi_enable(OLED_SPI);
80005f18:	fe b0 e4 9d 	rcall	80002852 <spi_selectionMode>
80005f1c:	fe 7c 28 00 	mov	r12,-55296

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );
80005f20:	fe b0 e5 40 	rcall	800029a0 <spi_enable>
80005f24:	1a 9b       	mov	r11,sp
80005f26:	e0 6a 14 80 	mov	r10,5248
80005f2a:	ea 1a 03 ef 	orh	r10,0x3ef
80005f2e:	fe 7c 28 00 	mov	r12,-55296

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
80005f32:	fe b0 e4 e1 	rcall	800028f4 <spi_setupChipReg>
80005f36:	e0 68 2d 00 	mov	r8,11520
80005f3a:	ea 18 01 31 	orh	r8,0x131
  spiOptions.bits         = 16;
80005f3e:	50 18       	stdsp	sp[0x4],r8
80005f40:	31 08       	mov	r8,16
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
80005f42:	fb 68 00 08 	st.b	sp[8],r8

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
80005f46:	30 58       	mov	r8,5
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80005f48:	30 06       	mov	r6,0
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
80005f4a:	30 15       	mov	r5,1
80005f4c:	1a 9b       	mov	r11,sp
  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
  spiOptions.spck_delay   = 0;
80005f4e:	fb 68 00 0a 	st.b	sp[10],r8
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
80005f52:	fb 66 00 09 	st.b	sp[9],r6
  spiOptions.modfdis      = 0;
80005f56:	fb 66 00 0b 	st.b	sp[11],r6

  // setup chip register for OLED
  spi_setupChipReg( OLED_SPI, &spiOptions, FPBA_HZ );

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
80005f5a:	fb 66 00 0d 	st.b	sp[13],r6
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80005f5e:	ba 85       	st.b	sp[0x0],r5
80005f60:	30 24       	mov	r4,2
80005f62:	e0 6a 14 80 	mov	r10,5248

  // add ADC chip register
  spiOptions.reg          = ADC_SPI_NPCS;
  spiOptions.baudrate     = 20000000;
  spiOptions.bits         = 16;
  spiOptions.spi_mode     = 2;
80005f66:	ea 1a 03 ef 	orh	r10,0x3ef
  spiOptions.spck_delay   = 0;
  spiOptions.trans_delay  = 5;
  spiOptions.stay_act     = 0;
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );
80005f6a:	fb 64 00 0c 	st.b	sp[12],r4
80005f6e:	fe 7c 28 00 	mov	r12,-55296

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
80005f72:	fe b0 e4 c1 	rcall	800028f4 <spi_setupChipReg>
80005f76:	e0 68 1b 00 	mov	r8,6912
  spiOptions.modfdis      = 0;

  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
80005f7a:	ea 18 00 b7 	orh	r8,0xb7
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
  spiOptions.spck_delay  = 0;
  spiOptions.trans_delay = 0;
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
80005f7e:	ba 84       	st.b	sp[0x0],r4
  spiOptions.modfdis     = 1;
80005f80:	fb 66 00 0c 	st.b	sp[12],r6

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
80005f84:	fb 65 00 0d 	st.b	sp[13],r5
  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80005f88:	20 4d       	sub	sp,16
  spiOptions.spck_delay  = 0;
80005f8a:	50 58       	stdsp	sp[0x14],r8
80005f8c:	30 88       	mov	r8,8
  spiOptions.trans_delay = 0;
80005f8e:	fb 66 00 19 	st.b	sp[25],r6
  spiOptions.stay_act    = 1;
80005f92:	fb 66 00 1a 	st.b	sp[26],r6
  spi_setupChipReg( ADC_SPI, &spiOptions, FPBA_HZ );

  // add SD/MMC chip register
  spiOptions.reg         = SD_MMC_SPI_NPCS;
  spiOptions.baudrate    = SD_MMC_SPI_MASTER_SPEED; // Defined in conf_sd_mmc_spi.h;
  spiOptions.bits        = SD_MMC_SPI_BITS; // Defined in conf_sd_mmc_spi.h;
80005f96:	fb 65 00 1b 	st.b	sp[27],r5
  spiOptions.stay_act    = 1;
  spiOptions.spi_mode    = 0;
  spiOptions.modfdis     = 1;

  // Initialize SD/MMC driver with SPI clock (PBA).
  sd_mmc_spi_init(spiOptions, FPBA_HZ);
80005f9a:	fb 68 00 18 	st.b	sp[24],r8
80005f9e:	ee e8 00 08 	ld.d	r8,r7[8]
80005fa2:	fa e9 00 08 	st.d	sp[8],r8
80005fa6:	ee e8 00 00 	ld.d	r8,r7[0]
80005faa:	e0 6c 14 80 	mov	r12,5248
80005fae:	ea 1c 03 ef 	orh	r12,0x3ef
80005fb2:	fa e9 00 00 	st.d	sp[0],r8
80005fb6:	fe b0 eb 73 	rcall	8000369c <sd_mmc_spi_init>
}
80005fba:	2f cd       	sub	sp,-16
80005fbc:	2f cd       	sub	sp,-16
80005fbe:	d8 22       	popm	r4-r7,pc

80005fc0 <init_ftdi_usart>:
80005fc0:	d4 01       	pushm	lr
80005fc2:	30 2b       	mov	r11,2
80005fc4:	fe cc a5 34 	sub	r12,pc,-23244
80005fc8:	fe b0 e2 70 	rcall	800024a8 <gpio_enable_module>
80005fcc:	e0 6a 14 80 	mov	r10,5248
80005fd0:	ea 1a 03 ef 	orh	r10,0x3ef
80005fd4:	fe cb a5 50 	sub	r11,pc,-23216
80005fd8:	fe 7c 14 00 	mov	r12,-60416
  gpio_enable_module(FTDI_USART_GPIO_MAP,
                     sizeof(FTDI_USART_GPIO_MAP) / sizeof(FTDI_USART_GPIO_MAP[0]));

  // Initialize in RS232 mode.
  usart_init_rs232(FTDI_USART, &FTDI_USART_OPTIONS, FPBA_HZ);
}
80005fdc:	fe b0 e6 44 	rcall	80002c64 <usart_init_rs232>
80005fe0:	d8 02       	popm	pc
80005fe2:	d7 03       	nop

80005fe4 <init_tc>:
80005fe4:	eb cd 40 80 	pushm	r7,lr
80005fe8:	fe cb a5 e0 	sub	r11,pc,-23072
80005fec:	18 97       	mov	r7,r12
80005fee:	fe b0 e4 fb 	rcall	800029e4 <tc_init_waveform>

  // set timer compare trigger.
  // we want it to overflow and generate an interrupt every 1 ms
  // so (1 / fPBA / 128) * RC = 0.001
  // so RC = fPBA / 128 / 1000
  tc_write_rc(tc, APP_TC_CHANNEL, (FPBA_HZ / 128 / 1000));
80005ff2:	e0 6a 02 03 	mov	r10,515
80005ff6:	30 0b       	mov	r11,0
80005ff8:	0e 9c       	mov	r12,r7
80005ffa:	fe b0 e5 56 	rcall	80002aa6 <tc_write_rc>
  // configure the timer interrupt
  tc_configure_interrupts(tc, APP_TC_CHANNEL, &tc_interrupt);
80005ffe:	30 0b       	mov	r11,0
80006000:	fe ca a5 80 	sub	r10,pc,-23168
80006004:	0e 9c       	mov	r12,r7
  // Start the timer/counter.
  tc_start(tc, APP_TC_CHANNEL);
80006006:	fe b0 e5 6c 	rcall	80002ade <tc_configure_interrupts>
8000600a:	0e 9c       	mov	r12,r7
8000600c:	30 0b       	mov	r11,0
}
8000600e:	fe b0 e5 3a 	rcall	80002a82 <tc_start>
80006012:	e3 cd 80 80 	ldm	sp++,r7,pc
80006016:	d7 03       	nop

80006018 <init_gpio>:
80006018:	d4 01       	pushm	lr
8000601a:	32 2c       	mov	r12,34
8000601c:	fe b0 e2 5a 	rcall	800024d0 <gpio_enable_pin_pull_up>
80006020:	32 3c       	mov	r12,35
80006022:	fe b0 e2 57 	rcall	800024d0 <gpio_enable_pin_pull_up>
80006026:	32 4c       	mov	r12,36
80006028:	fe b0 e2 54 	rcall	800024d0 <gpio_enable_pin_pull_up>
void init_gpio(void) {
  
  gpio_enable_pin_pull_up(ENC0_S0_PIN);
  gpio_enable_pin_pull_up(ENC0_S1_PIN);
  gpio_enable_pin_pull_up(ENC1_S0_PIN);
  gpio_enable_pin_pull_up(ENC1_S1_PIN);
8000602c:	32 5c       	mov	r12,37
8000602e:	fe b0 e2 51 	rcall	800024d0 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S0_PIN);
80006032:	32 6c       	mov	r12,38
80006034:	fe b0 e2 4e 	rcall	800024d0 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC2_S1_PIN);
80006038:	32 7c       	mov	r12,39
8000603a:	fe b0 e2 4b 	rcall	800024d0 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S0_PIN);
8000603e:	32 8c       	mov	r12,40
80006040:	fe b0 e2 48 	rcall	800024d0 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(ENC3_S1_PIN);
80006044:	32 9c       	mov	r12,41
80006046:	fe b0 e2 45 	rcall	800024d0 <gpio_enable_pin_pull_up>
  gpio_enable_pin_pull_up(SW2_PIN);
  gpio_enable_pin_pull_up(SW3_PIN);
  gpio_enable_pin_pull_up(SW_MODE_PIN);
#endif

  gpio_enable_pin_pull_up(SW_POWER_PIN);
8000604a:	33 0c       	mov	r12,48
8000604c:	fe b0 e2 42 	rcall	800024d0 <gpio_enable_pin_pull_up>
  /// trying this...
  /* gpio_enable_pin_glitch_filter(SW0_PIN); */
  /* gpio_enable_pin_glitch_filter(SW1_PIN); */
  /* gpio_enable_pin_glitch_filter(SW2_PIN); */
  /* gpio_enable_pin_glitch_filter(SW3_PIN); */
  gpio_enable_pin_glitch_filter(SW_MODE_PIN); 
80006050:	31 8c       	mov	r12,24
80006052:	fe b0 e2 6e 	rcall	8000252e <gpio_enable_pin_glitch_filter>
}
80006056:	d8 02       	popm	pc

80006058 <register_interrupts>:

  //-----------------------------
  //---- external function definitions

  // register interrupts
  void register_interrupts(void) {
80006058:	d4 01       	pushm	lr
    // enable interrupts on GPIO inputs

    // BFIN_HWAIT
    // gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_PIN_CHANGE);
    gpio_enable_pin_interrupt( BFIN_HWAIT_PIN, GPIO_RISING_EDGE);
8000605a:	30 1b       	mov	r11,1
8000605c:	30 5c       	mov	r12,5
8000605e:	fe b0 e2 72 	rcall	80002542 <gpio_enable_pin_interrupt>

    // encoders
    gpio_enable_pin_interrupt( ENC0_S0_PIN,	GPIO_PIN_CHANGE);
80006062:	30 0b       	mov	r11,0
80006064:	32 2c       	mov	r12,34
80006066:	fe b0 e2 6e 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC0_S1_PIN,	GPIO_PIN_CHANGE);
8000606a:	30 0b       	mov	r11,0
8000606c:	32 3c       	mov	r12,35
8000606e:	fe b0 e2 6a 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S0_PIN,	GPIO_PIN_CHANGE);
80006072:	30 0b       	mov	r11,0
80006074:	32 4c       	mov	r12,36
80006076:	fe b0 e2 66 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC1_S1_PIN,	GPIO_PIN_CHANGE);
8000607a:	30 0b       	mov	r11,0
8000607c:	32 5c       	mov	r12,37
8000607e:	fe b0 e2 62 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S0_PIN,	GPIO_PIN_CHANGE);
80006082:	30 0b       	mov	r11,0
80006084:	32 6c       	mov	r12,38
80006086:	fe b0 e2 5e 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC2_S1_PIN,	GPIO_PIN_CHANGE);
8000608a:	30 0b       	mov	r11,0
8000608c:	32 7c       	mov	r12,39
8000608e:	fe b0 e2 5a 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S0_PIN,	GPIO_PIN_CHANGE);
80006092:	30 0b       	mov	r11,0
80006094:	32 8c       	mov	r12,40
80006096:	fe b0 e2 56 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( ENC3_S1_PIN,	GPIO_PIN_CHANGE);
8000609a:	30 0b       	mov	r11,0
8000609c:	32 9c       	mov	r12,41
8000609e:	fe b0 e2 52 	rcall	80002542 <gpio_enable_pin_interrupt>

    // switches
    gpio_enable_pin_interrupt( SW0_PIN,	        GPIO_PIN_CHANGE);
800060a2:	30 0b       	mov	r11,0
800060a4:	31 9c       	mov	r12,25
800060a6:	fe b0 e2 4e 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW1_PIN,	        GPIO_PIN_CHANGE);
800060aa:	30 0b       	mov	r11,0
800060ac:	31 ac       	mov	r12,26
800060ae:	fe b0 e2 4a 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW2_PIN,	        GPIO_PIN_CHANGE);
800060b2:	30 0b       	mov	r11,0
800060b4:	31 bc       	mov	r12,27
800060b6:	fe b0 e2 46 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( SW3_PIN,	        GPIO_PIN_CHANGE);
800060ba:	30 0b       	mov	r11,0
800060bc:	31 cc       	mov	r12,28
800060be:	fe b0 e2 42 	rcall	80002542 <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( FS0_PIN,	GPIO_PIN_CHANGE);
800060c2:	30 0b       	mov	r11,0
800060c4:	33 ec       	mov	r12,62
800060c6:	fe b0 e2 3e 	rcall	80002542 <gpio_enable_pin_interrupt>
    gpio_enable_pin_interrupt( FS1_PIN,	GPIO_PIN_CHANGE);
800060ca:	30 0b       	mov	r11,0
800060cc:	33 fc       	mov	r12,63
800060ce:	fe b0 e2 3a 	rcall	80002542 <gpio_enable_pin_interrupt>

    gpio_enable_pin_interrupt( SW_MODE_PIN,	GPIO_PIN_CHANGE);
800060d2:	30 0b       	mov	r11,0
800060d4:	31 8c       	mov	r12,24
800060d6:	fe b0 e2 36 	rcall	80002542 <gpio_enable_pin_interrupt>
    //  gpio_enable_pin_interrupt( SW_POWER_PIN,	GPIO_PIN_CHANGE);
 
    // PA24 - PA31
    INTC_register_interrupt( &irq_port0_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PA24 / 8), UI_IRQ_PRIORITY);
800060da:	30 2a       	mov	r10,2
800060dc:	34 3b       	mov	r11,67
800060de:	fe cc fe a2 	sub	r12,pc,-350
800060e2:	fe b0 e2 6d 	rcall	800025bc <INTC_register_interrupt>

    // PB00 - PB07
    INTC_register_interrupt( &irq_port1_line0, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB00 / 8), UI_IRQ_PRIORITY );
800060e6:	30 2a       	mov	r10,2
800060e8:	34 4b       	mov	r11,68
800060ea:	fe cc fe 0a 	sub	r12,pc,-502

    // PB08 - PB15
    INTC_register_interrupt( &irq_port1_line1, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB08 / 8), UI_IRQ_PRIORITY);
800060ee:	fe b0 e2 67 	rcall	800025bc <INTC_register_interrupt>
800060f2:	30 2a       	mov	r10,2
800060f4:	34 5b       	mov	r11,69
800060f6:	fe cc fe 46 	sub	r12,pc,-442

    // PB16 - PB23
    //  INTC_register_interrupt( &irq_port1_line2, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB16 / 8), UI_IRQ_PRIORITY);

    // PB24 - PB31
    INTC_register_interrupt( &irq_port1_line3, AVR32_GPIO_IRQ_0 + (AVR32_PIN_PB24 / 8), UI_IRQ_PRIORITY);
800060fa:	fe b0 e2 61 	rcall	800025bc <INTC_register_interrupt>
800060fe:	30 2a       	mov	r10,2
80006100:	34 7b       	mov	r11,71


    // register IRQ for PDCA transfer
    INTC_register_interrupt(&irq_pdca, AVR32_PDCA_IRQ_0, SYS_IRQ_PRIORITY);
80006102:	fe cc fe f6 	sub	r12,pc,-266
80006106:	fe b0 e2 5b 	rcall	800025bc <INTC_register_interrupt>
8000610a:	30 1a       	mov	r10,1

    // register TC interrupt
    INTC_register_interrupt(&irq_tc, APP_TC_IRQ, APP_TC_IRQ_PRIORITY);
8000610c:	36 0b       	mov	r11,96
8000610e:	fe cc ff 62 	sub	r12,pc,-158
80006112:	fe b0 e2 55 	rcall	800025bc <INTC_register_interrupt>
80006116:	30 3a       	mov	r10,3
  }
80006118:	e0 6b 01 c0 	mov	r11,448
8000611c:	fe cc ff f4 	sub	r12,pc,-12
80006120:	fe b0 e2 4e 	rcall	800025bc <INTC_register_interrupt>
80006124:	d8 02       	popm	pc
80006126:	d7 03       	nop

80006128 <irq_tc>:
80006128:	eb cd 40 c0 	pushm	r6-r7,lr
8000612c:	e0 68 0b 9c 	mov	r8,2972
80006130:	30 1a       	mov	r10,1
80006132:	f0 e6 00 00 	ld.d	r6,r8[0]
80006136:	30 0b       	mov	r11,0
80006138:	ec 0a 00 0a 	add	r10,r6,r10
}

// timer irq
__attribute__((__interrupt__))
static void irq_tc(void) {
  tcTicks++;
8000613c:	ee 0b 00 4b 	adc	r11,r7,r11
80006140:	f0 eb 00 00 	st.d	r8[0],r10
  // overflow control
  if(tcTicks > tcMax) { 
80006144:	e0 66 ff ff 	mov	r6,65535
80006148:	ea 16 7f ff 	orh	r6,0x7fff
8000614c:	f0 ea 00 00 	ld.d	r10,r8[0]
80006150:	30 07       	mov	r7,0
80006152:	0c 3a       	cp.w	r10,r6
80006154:	ee 0b 13 00 	cpc	r11,r7
80006158:	e0 88 00 20 	brls	80006198 <irq_tc+0x70>
    tcTicks = 0;
8000615c:	30 0a       	mov	r10,0
8000615e:	30 0b       	mov	r11,0
80006160:	f0 eb 00 00 	st.d	r8[0],r10
    tcOverflow = 1;
80006164:	30 19       	mov	r9,1
80006166:	e0 68 0b 99 	mov	r8,2969
  } else {
    tcOverflow = 0;
  }
  process_timers();
8000616a:	b0 89       	st.b	r8[0x0],r9
  if(tog) {
8000616c:	e0 a0 07 0a 	rcall	80006f80 <process_timers>
80006170:	e0 68 0b 98 	mov	r8,2968
80006174:	30 09       	mov	r9,0
80006176:	11 8a       	ld.ub	r10,r8[0x0]
    tog = 0;
    gpio_clr_gpio_pin(LED_MODE_PIN);
  } else {
    tog = 1;
80006178:	f2 0a 18 00 	cp.b	r10,r9
8000617c:	c1 31       	brne	800061a2 <irq_tc+0x7a>
    gpio_set_gpio_pin(LED_MODE_PIN);
8000617e:	30 19       	mov	r9,1
80006180:	31 7c       	mov	r12,23
  }

  // clear interrupt flag by reading timer SR
  tc_read_sr(APP_TC, APP_TC_CHANNEL);
80006182:	b0 89       	st.b	r8[0x0],r9
80006184:	fe b0 e1 bb 	rcall	800024fa <gpio_set_gpio_pin>
80006188:	30 0b       	mov	r11,0
8000618a:	fe 7c 38 00 	mov	r12,-51200
}
8000618e:	fe b0 e4 83 	rcall	80002a94 <tc_read_sr>
  // overflow control
  if(tcTicks > tcMax) { 
    tcTicks = 0;
    tcOverflow = 1;
  } else {
    tcOverflow = 0;
80006192:	e3 cd 40 c0 	ldm	sp++,r6-r7,lr
80006196:	d6 03       	rete
80006198:	30 09       	mov	r9,0
  }
  process_timers();
  if(tog) {
    tog = 0;
8000619a:	e0 68 0b 99 	mov	r8,2969
    gpio_clr_gpio_pin(LED_MODE_PIN);
8000619e:	b0 89       	st.b	r8[0x0],r9
800061a0:	ce 6b       	rjmp	8000616c <irq_tc+0x44>
800061a2:	b0 89       	st.b	r8[0x0],r9
800061a4:	31 7c       	mov	r12,23
800061a6:	fe b0 e1 b7 	rcall	80002514 <gpio_clr_gpio_pin>
800061aa:	ce fb       	rjmp	80006188 <irq_tc+0x60>

800061ac <irq_pdca>:
800061ac:	d4 01       	pushm	lr
800061ae:	d3 03       	ssrf	0x10
800061b0:	30 0c       	mov	r12,0
800061b2:	fe b0 e2 c8 	rcall	80002742 <pdca_disable_interrupt_transfer_complete>
800061b6:	fe b0 e6 93 	rcall	80002edc <sd_mmc_spi_read_close_PDCA>
800061ba:	e0 68 03 e8 	mov	r8,1000
800061be:	30 09       	mov	r9,0
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800061c0:	e0 6a d0 e7 	mov	r10,53479
800061c4:	ea 1a 27 56 	orh	r10,0x2756
800061c8:	30 0b       	mov	r11,0
800061ca:	e0 a0 1f 71 	rcall	8000a0ac <__avr32_udiv64>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800061ce:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800061d2:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800061d6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800061da:	14 38       	cp.w	r8,r10
800061dc:	e0 88 00 14 	brls	80006204 <irq_pdca+0x58>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800061e0:	12 38       	cp.w	r8,r9
800061e2:	fe 98 ff fa 	brls	800061d6 <irq_pdca+0x2a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800061e6:	12 3a       	cp.w	r10,r9
800061e8:	cf 72       	brcc	800061d6 <irq_pdca+0x2a>
  //.... example has a 5000 clock gimpy delay here.
  // using delay_us instead
  delay_ms(10);
  //  delay_ms(2);
  // Disable unnecessary channel
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
800061ea:	30 1c       	mov	r12,1
800061ec:	fe b0 e2 78 	rcall	800026dc <pdca_disable>
  pdca_disable(AVR32_PDCA_CHANNEL_SPI_RX);
800061f0:	30 0c       	mov	r12,0
800061f2:	fe b0 e2 75 	rcall	800026dc <pdca_disable>
  // Enable all interrupts.
  cpu_irq_enable();
800061f6:	d5 03       	csrf	0x10
  //  Enable_global_interrupt();
  //  print_dbg("\r\n handled PDCA interrupt. \r\n");
  fsEndTransfer = true;
800061f8:	30 19       	mov	r9,1
800061fa:	e0 68 2c ac 	mov	r8,11436
}
800061fe:	b0 89       	st.b	r8[0x0],r9
80006200:	d4 02       	popm	lr
80006202:	d6 03       	rete
80006204:	12 38       	cp.w	r8,r9
80006206:	fe 9b ff f2 	brhi	800061ea <irq_pdca+0x3e>
8000620a:	ce eb       	rjmp	800061e6 <irq_pdca+0x3a>

8000620c <irq_port1_line3>:
8000620c:	d4 01       	pushm	lr
8000620e:	33 ec       	mov	r12,62
80006210:	fe b0 e1 be 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006214:	c0 d1       	brne	8000622e <irq_port1_line3+0x22>
80006216:	33 fc       	mov	r12,63
80006218:	fe b0 e1 ba 	rcall	8000258c <gpio_get_pin_interrupt_flag>
8000621c:	c0 70       	breq	8000622a <irq_port1_line3+0x1e>
8000621e:	33 fc       	mov	r12,63
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
    process_sw(6);
  }
  if(gpio_get_pin_interrupt_flag(FS1_PIN)) {
    gpio_clear_pin_interrupt_flag(FS1_PIN);
80006220:	fe b0 e1 c2 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(7);
80006224:	30 7c       	mov	r12,7
80006226:	e0 a0 06 97 	rcall	80006f54 <process_sw>
  }
}
8000622a:	d4 02       	popm	lr
8000622c:	d6 03       	rete
// interrupt handler for PB24-PB31
__attribute__((__interrupt__))
static void irq_port1_line3(void) {
  //  print_dbg("\r\n irq_port1_line3");
  if(gpio_get_pin_interrupt_flag(FS0_PIN)) {
    gpio_clear_pin_interrupt_flag(FS0_PIN);
8000622e:	33 ec       	mov	r12,62
80006230:	fe b0 e1 ba 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(6);
80006234:	30 6c       	mov	r12,6
80006236:	e0 a0 06 8f 	rcall	80006f54 <process_sw>
8000623a:	ce eb       	rjmp	80006216 <irq_port1_line3+0xa>

8000623c <irq_port0_line3>:
8000623c:	d4 01       	pushm	lr
8000623e:	31 9c       	mov	r12,25
80006240:	fe b0 e1 a6 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006244:	c2 e1       	brne	800062a0 <irq_port0_line3+0x64>
80006246:	31 ac       	mov	r12,26
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
80006248:	fe b0 e1 a2 	rcall	8000258c <gpio_get_pin_interrupt_flag>
8000624c:	c2 31       	brne	80006292 <irq_port0_line3+0x56>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
8000624e:	31 bc       	mov	r12,27
80006250:	fe b0 e1 9e 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006254:	c1 81       	brne	80006284 <irq_port0_line3+0x48>
    gpio_clear_pin_interrupt_flag(SW2_PIN);
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
80006256:	31 cc       	mov	r12,28
80006258:	fe b0 e1 9a 	rcall	8000258c <gpio_get_pin_interrupt_flag>
8000625c:	c0 d1       	brne	80006276 <irq_port0_line3+0x3a>
    gpio_clear_pin_interrupt_flag(SW3_PIN);
    process_sw(3);
  }
  // SW_MODE
  if(gpio_get_pin_interrupt_flag(SW_MODE_PIN)) {
8000625e:	31 8c       	mov	r12,24
80006260:	fe b0 e1 96 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006264:	c0 70       	breq	80006272 <irq_port0_line3+0x36>
    gpio_clear_pin_interrupt_flag(SW_MODE_PIN);
80006266:	31 8c       	mov	r12,24
80006268:	fe b0 e1 9e 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(4);
8000626c:	30 4c       	mov	r12,4
8000626e:	e0 a0 06 73 	rcall	80006f54 <process_sw>
  }
}
80006272:	d4 02       	popm	lr
80006274:	d6 03       	rete
    process_sw(2);
  }
 
  // SW_F3
  if(gpio_get_pin_interrupt_flag(SW3_PIN)) {
    gpio_clear_pin_interrupt_flag(SW3_PIN);
80006276:	31 cc       	mov	r12,28
80006278:	fe b0 e1 96 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(3);
8000627c:	30 3c       	mov	r12,3
8000627e:	e0 a0 06 6b 	rcall	80006f54 <process_sw>
80006282:	ce eb       	rjmp	8000625e <irq_port0_line3+0x22>
    gpio_clear_pin_interrupt_flag(SW1_PIN);
    process_sw(1);
  }
  // SW_F2
  if(gpio_get_pin_interrupt_flag(SW2_PIN)) {
    gpio_clear_pin_interrupt_flag(SW2_PIN);
80006284:	31 bc       	mov	r12,27
80006286:	fe b0 e1 8f 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(2);
8000628a:	30 2c       	mov	r12,2
8000628c:	e0 a0 06 64 	rcall	80006f54 <process_sw>
80006290:	ce 3b       	rjmp	80006256 <irq_port0_line3+0x1a>
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
  }
  // SW_F1
  if(gpio_get_pin_interrupt_flag(SW1_PIN)) {
    gpio_clear_pin_interrupt_flag(SW1_PIN);
80006292:	31 ac       	mov	r12,26
80006294:	fe b0 e1 88 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    process_sw(1);
80006298:	30 1c       	mov	r12,1
8000629a:	e0 a0 06 5d 	rcall	80006f54 <process_sw>
8000629e:	cd 8b       	rjmp	8000624e <irq_port0_line3+0x12>
__attribute__((__interrupt__))
static void irq_port0_line3(void) {
  //  print_dbg("\r\n interrupt on port0_line3");
  //SW_F0
  if(gpio_get_pin_interrupt_flag(SW0_PIN)) {
    gpio_clear_pin_interrupt_flag(SW0_PIN);
800062a0:	31 9c       	mov	r12,25
800062a2:	fe b0 e1 81 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
    /// process_sw() will post an event, which calls cpu_irq_disable().
    /// apparently, this also clears the GPIO interrupt flags (!?)
    /// so clear the flag first to avoid triggering an infinite series of interrupts.
    /// this might be problematic if we were expecting faster interrupts from switches,
    /// but hardware pre-filtering should preclude this.
    process_sw(0);
800062a6:	30 0c       	mov	r12,0
800062a8:	e0 a0 06 56 	rcall	80006f54 <process_sw>
800062ac:	cc db       	rjmp	80006246 <irq_port0_line3+0xa>
800062ae:	d7 03       	nop

800062b0 <irq_port1_line1>:
800062b0:	d4 01       	pushm	lr
800062b2:	32 8c       	mov	r12,40
800062b4:	fe b0 e1 6c 	rcall	8000258c <gpio_get_pin_interrupt_flag>
800062b8:	c0 d1       	brne	800062d2 <irq_port1_line1+0x22>
800062ba:	32 9c       	mov	r12,41
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
  }  
  // ENC3_1
  if(gpio_get_pin_interrupt_flag(ENC3_S1_PIN)) {
800062bc:	fe b0 e1 68 	rcall	8000258c <gpio_get_pin_interrupt_flag>
800062c0:	c0 70       	breq	800062ce <irq_port1_line1+0x1e>
    process_enc(3);
800062c2:	30 3c       	mov	r12,3
800062c4:	fe b0 fb ba 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S1_PIN);
800062c8:	32 9c       	mov	r12,41
800062ca:	fe b0 e1 6d 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
  }

}
800062ce:	d4 02       	popm	lr
800062d0:	d6 03       	rete
__attribute__((__interrupt__))
static void irq_port1_line1(void) {
  //    print_dbg("\r\b\interrupt on PB08-PB15.");
  // ENC3_0
  if(gpio_get_pin_interrupt_flag(ENC3_S0_PIN)) {
    process_enc(3);
800062d2:	30 3c       	mov	r12,3
800062d4:	fe b0 fb b2 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC3_S0_PIN);
800062d8:	32 8c       	mov	r12,40
800062da:	fe b0 e1 65 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
800062de:	ce eb       	rjmp	800062ba <irq_port1_line1+0xa>

800062e0 <irq_port1_line0>:
800062e0:	d4 01       	pushm	lr
800062e2:	32 2c       	mov	r12,34
800062e4:	fe b0 e1 54 	rcall	8000258c <gpio_get_pin_interrupt_flag>
800062e8:	c3 91       	brne	8000635a <irq_port1_line0+0x7a>
800062ea:	32 3c       	mov	r12,35
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
800062ec:	fe b0 e1 50 	rcall	8000258c <gpio_get_pin_interrupt_flag>
800062f0:	c2 e1       	brne	8000634c <irq_port1_line0+0x6c>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
800062f2:	32 4c       	mov	r12,36
800062f4:	fe b0 e1 4c 	rcall	8000258c <gpio_get_pin_interrupt_flag>
800062f8:	c2 31       	brne	8000633e <irq_port1_line0+0x5e>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
800062fa:	32 5c       	mov	r12,37
800062fc:	fe b0 e1 48 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006300:	c1 81       	brne	80006330 <irq_port1_line0+0x50>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
80006302:	32 6c       	mov	r12,38
80006304:	fe b0 e1 44 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006308:	c0 d1       	brne	80006322 <irq_port1_line0+0x42>
    process_enc(2);
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
  }  
  // ENC2_1
  if(gpio_get_pin_interrupt_flag(ENC2_S1_PIN)) {
8000630a:	32 7c       	mov	r12,39
8000630c:	fe b0 e1 40 	rcall	8000258c <gpio_get_pin_interrupt_flag>
80006310:	c0 70       	breq	8000631e <irq_port1_line0+0x3e>
    process_enc(2);
80006312:	30 2c       	mov	r12,2
80006314:	fe b0 fb 92 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S1_PIN);
80006318:	32 7c       	mov	r12,39
8000631a:	fe b0 e1 45 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
  }
}
8000631e:	d4 02       	popm	lr
80006320:	d6 03       	rete
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
  }
  // ENC2_0
  if(gpio_get_pin_interrupt_flag(ENC2_S0_PIN)) {
    process_enc(2);
80006322:	30 2c       	mov	r12,2
80006324:	fe b0 fb 8a 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC2_S0_PIN);
80006328:	32 6c       	mov	r12,38
8000632a:	fe b0 e1 3d 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
8000632e:	ce eb       	rjmp	8000630a <irq_port1_line0+0x2a>
    process_enc(1);
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
  }  
  // ENC1_1
  if(gpio_get_pin_interrupt_flag(ENC1_S1_PIN)) {
    process_enc(1);
80006330:	30 1c       	mov	r12,1
80006332:	fe b0 fb 83 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S1_PIN);
80006336:	32 5c       	mov	r12,37
80006338:	fe b0 e1 36 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
8000633c:	ce 3b       	rjmp	80006302 <irq_port1_line0+0x22>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
  }
  // ENC1_0
  if(gpio_get_pin_interrupt_flag(ENC1_S0_PIN)) {
    process_enc(1);
8000633e:	30 1c       	mov	r12,1
80006340:	fe b0 fb 7c 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC1_S0_PIN);
80006344:	32 4c       	mov	r12,36
80006346:	fe b0 e1 2f 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
8000634a:	cd 8b       	rjmp	800062fa <irq_port1_line0+0x1a>
    process_enc(0);
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
  }  
  // ENC0_1
  if(gpio_get_pin_interrupt_flag(ENC0_S1_PIN)) {
    process_enc(0);
8000634c:	30 0c       	mov	r12,0
8000634e:	fe b0 fb 75 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S1_PIN);
80006352:	32 3c       	mov	r12,35
80006354:	fe b0 e1 28 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
80006358:	cc db       	rjmp	800062f2 <irq_port1_line0+0x12>
__attribute__((__interrupt__))
static void irq_port1_line0(void) {
  // print_dbg("\r\b\interrupt on PB00-PB07.");
  // ENC0_0
  if(gpio_get_pin_interrupt_flag(ENC0_S0_PIN)) {
    process_enc(0);
8000635a:	30 0c       	mov	r12,0
8000635c:	fe b0 fb 6e 	rcall	80005a38 <process_enc>
    gpio_clear_pin_interrupt_flag(ENC0_S0_PIN);
80006360:	32 2c       	mov	r12,34
80006362:	fe b0 e1 21 	rcall	800025a4 <gpio_clear_pin_interrupt_flag>
80006366:	cc 2b       	rjmp	800062ea <irq_port1_line0+0xa>

80006368 <init_mem>:
// bytes in sram hardware
static u32 heapSize;


// setup heap-ish
void init_mem(void) {
80006368:	d4 01       	pushm	lr
  heapSize = SRAM_SIZE;
8000636a:	30 1c       	mov	r12,1
8000636c:	fe b0 de 4e 	rcall	80002008 <smc_get_cs_size>
  pHeapStart = (heap_t)SRAM;
80006370:	fc 18 d0 00 	movh	r8,0xd000
static u32 heapSize;


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
80006374:	30 19       	mov	r9,1
80006376:	f2 0c 09 49 	lsl	r9,r9,r12
8000637a:	e0 6b 0b ac 	mov	r11,2988
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
8000637e:	f2 08 00 0a 	add	r10,r9,r8


// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
80006382:	97 09       	st.w	r11[0x0],r9
80006384:	e0 69 0b a4 	mov	r9,2980
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
  heapOffset = 0;
80006388:	93 08       	st.w	r9[0x0],r8

// setup heap-ish
void init_mem(void) {
  heapSize = SRAM_SIZE;
  pHeapStart = (heap_t)SRAM;
  pHeapEnd = (heap_t)((u32)pHeapStart + heapSize);
8000638a:	e0 68 0b b0 	mov	r8,2992
  heapOffset = 0;
8000638e:	30 09       	mov	r9,0
}
80006390:	91 0a       	st.w	r8[0x0],r10
80006392:	e0 68 0b a8 	mov	r8,2984
80006396:	91 09       	st.w	r8[0x0],r9
80006398:	d8 02       	popm	pc
8000639a:	d7 03       	nop

8000639c <alloc_mem>:
8000639c:	eb cd 40 c0 	pushm	r6-r7,lr
800063a0:	18 96       	mov	r6,r12
800063a2:	fe cc a8 d2 	sub	r12,pc,-22318
800063a6:	fe b0 e5 09 	rcall	80002db8 <print_dbg>

// allocate and return pointer
heap_t alloc_mem(u32 bytes) {
  print_dbg("\r\n allocating memory, bytes: 0x");
  print_dbg_hex(bytes);
800063aa:	0c 9c       	mov	r12,r6
800063ac:	fe b0 e4 d8 	rcall	80002d5c <print_dbg_hex>

  print_dbg("\r\n location: 0x");
800063b0:	fe cc a8 c0 	sub	r12,pc,-22336
  print_dbg_hex(heapOffset);
800063b4:	fe b0 e5 02 	rcall	80002db8 <print_dbg>
800063b8:	e0 67 0b a8 	mov	r7,2984

  u32 tmp = heapOffset + bytes;
800063bc:	6e 0c       	ld.w	r12,r7[0x0]
800063be:	fe b0 e4 cf 	rcall	80002d5c <print_dbg_hex>
  u8 mtmp = tmp % 4;
800063c2:	6e 08       	ld.w	r8,r7[0x0]
  heap_t ret;
  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
800063c4:	10 06       	add	r6,r8
800063c6:	f1 d6 c0 02 	bfextu	r8,r6,0x0,0x2
800063ca:	f7 b6 01 fc 	subne	r6,-4
  }
  if (tmp < heapSize) {
800063ce:	ed d8 e1 16 	subne	r6,r6,r8
800063d2:	e0 68 0b ac 	mov	r8,2988
    heapOffset = tmp;
800063d6:	70 08       	ld.w	r8,r8[0x0]
    ret = pHeapStart + heapOffset;
800063d8:	10 36       	cp.w	r6,r8
800063da:	c0 82       	brcc	800063ea <alloc_mem+0x4e>
  } else {
    ret = (heap_t)ALLOC_FAIL;
  }
  return ret;
}
800063dc:	e0 68 0b a4 	mov	r8,2980
  heap_t ret;
  // align to 4 bytes
  if ( mtmp != 0) {
    tmp += ( 4 - mtmp );
  }
  if (tmp < heapSize) {
800063e0:	8f 06       	st.w	r7[0x0],r6
800063e2:	70 0c       	ld.w	r12,r8[0x0]
800063e4:	0c 0c       	add	r12,r6
800063e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063ea:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1
800063ee:	d7 03       	nop

800063f0 <sram_test>:
800063f0:	eb cd 40 f8 	pushm	r3-r7,lr
800063f4:	30 1c       	mov	r12,1
800063f6:	fe b0 de 09 	rcall	80002008 <smc_get_cs_size>
800063fa:	30 17       	mov	r7,1
800063fc:	ee 0c 09 47 	lsl	r7,r7,r12
  unsigned long sram_size, progress_inc, i, j, tmp, noErrors = 0;
  volatile unsigned long *sram = SRAM;
  
  sram_size = SRAM_SIZE >> 2;
  //  sram_size = numBytes >> 2; // count of 32-bit words
  print_dbg("\r\n SRAM size (words): ");
80006400:	fe cc a9 00 	sub	r12,pc,-22272
80006404:	a3 47       	asr	r7,0x2
80006406:	fe b0 e4 d9 	rcall	80002db8 <print_dbg>
  print_dbg_ulong(sram_size);
8000640a:	0e 9c       	mov	r12,r7
8000640c:	fe b0 e4 d0 	rcall	80002dac <print_dbg_ulong>
  print_dbg("\r\n");
80006410:	fe cc a8 f8 	sub	r12,pc,-22280
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006414:	fe b0 e4 d2 	rcall	80002db8 <print_dbg>
80006418:	e0 68 03 e8 	mov	r8,1000
8000641c:	30 09       	mov	r9,0
8000641e:	e0 6a 18 67 	mov	r10,6247
80006422:	ea 1a 03 ef 	orh	r10,0x3ef
80006426:	30 0b       	mov	r11,0
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006428:	e0 a0 1e 42 	rcall	8000a0ac <__avr32_udiv64>
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000642c:	e1 b8 00 42 	mfsr	r8,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006430:	f0 0a 00 0a 	add	r10,r8,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006434:	e1 b9 00 42 	mfsr	r9,0x108
80006438:	14 38       	cp.w	r8,r10
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000643a:	e0 88 00 41 	brls	800064bc <sram_test+0xcc>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000643e:	10 39       	cp.w	r9,r8
80006440:	cf a2       	brcc	80006434 <sram_test+0x44>
80006442:	14 39       	cp.w	r9,r10
  delay_ms(1);
  
  progress_inc = (sram_size + 50) / 100; // words per progress report

  // Fill the SRAM with the test pattern.
  for (i = 0, j = 0; i < sram_size; i++) {
80006444:	fe 98 ff f8 	brls	80006434 <sram_test+0x44>
80006448:	58 07       	cp.w	r7,0
8000644a:	c3 c0       	breq	800064c2 <sram_test+0xd2>
8000644c:	fc 19 d0 00 	movh	r9,0xd000
80006450:	30 08       	mov	r8,0
80006452:	12 a8       	st.w	r9++,r8
80006454:	2f f8       	sub	r8,-1
80006456:	10 37       	cp.w	r7,r8
    }
    sram[i] = i;
    //    print_dbg("\r\n write: 0x");
    //    print_dbg_hex(i);
  }
  print_dbg("\rSRAM filled with test pattern       \r\n");
80006458:	fe 9b ff fd 	brhi	80006452 <sram_test+0x62>
8000645c:	fe cc a9 40 	sub	r12,pc,-22208
80006460:	30 03       	mov	r3,0
80006462:	fe b0 e4 ab 	rcall	80002db8 <print_dbg>
    //    if (i == j * progress_inc) {
    //      print_dbg("\rRecovering test pattern from SRAM: ");
    //      print_dbg_ulong(j++);
    //      print_dbg_char('%');
    //    }
    tmp = sram[i];
80006466:	fc 15 d0 00 	movh	r5,0xd000
    print_dbg(" \r\n word index/value: 0x");
8000646a:	06 96       	mov	r6,r3
8000646c:	6a 04       	ld.w	r4,r5[0x0]
    print_dbg_hex(i); 
8000646e:	fe cc a9 2a 	sub	r12,pc,-22230
80006472:	fe b0 e4 a3 	rcall	80002db8 <print_dbg>
    print_dbg(" ; read: 0x");
80006476:	0c 9c       	mov	r12,r6
80006478:	fe b0 e4 72 	rcall	80002d5c <print_dbg_hex>
    print_dbg_hex(tmp);
8000647c:	fe cc a9 1c 	sub	r12,pc,-22244
80006480:	fe b0 e4 9c 	rcall	80002db8 <print_dbg>
    if (tmp != i) {
80006484:	2f c5       	sub	r5,-4
      print_dbg(" ERROR");
      noErrors++;
80006486:	08 9c       	mov	r12,r4
    print_dbg(" \r\n word index/value: 0x");
    print_dbg_hex(i); 
    print_dbg(" ; read: 0x");
    print_dbg_hex(tmp);
    if (tmp != i) {
      print_dbg(" ERROR");
80006488:	fe b0 e4 6a 	rcall	80002d5c <print_dbg_hex>
8000648c:	0c 34       	cp.w	r4,r6
    //    print_dbg_hex(i);
  }
  print_dbg("\rSRAM filled with test pattern       \r\n");

  // Recover the test pattern from the SRAM and verify it.
  for (i = 0, j = 0; i < sram_size; i++) {
8000648e:	c0 60       	breq	8000649a <sram_test+0xaa>
80006490:	2f f3       	sub	r3,-1
80006492:	fe cc a9 26 	sub	r12,pc,-22234
    if (tmp != i) {
      print_dbg(" ERROR");
      noErrors++;
    }
  }
  print_dbg("\rSRAM tested: ");
80006496:	fe b0 e4 91 	rcall	80002db8 <print_dbg>
8000649a:	2f f6       	sub	r6,-1
  print_dbg_ulong(noErrors);
8000649c:	0c 37       	cp.w	r7,r6
8000649e:	fe 9b ff e7 	brhi	8000646c <sram_test+0x7c>
  print_dbg(" corrupted word(s)       \r\n");
800064a2:	fe cc a9 2e 	sub	r12,pc,-22226
800064a6:	fe b0 e4 89 	rcall	80002db8 <print_dbg>
}
800064aa:	06 9c       	mov	r12,r3
800064ac:	fe b0 e4 80 	rcall	80002dac <print_dbg_ulong>
800064b0:	fe cc a9 2c 	sub	r12,pc,-22228
    }
    sram[i] = i;
    //    print_dbg("\r\n write: 0x");
    //    print_dbg_hex(i);
  }
  print_dbg("\rSRAM filled with test pattern       \r\n");
800064b4:	fe b0 e4 82 	rcall	80002db8 <print_dbg>
800064b8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800064bc:	10 39       	cp.w	r9,r8
800064be:	cc 53       	brcs	80006448 <sram_test+0x58>
800064c0:	cc 1b       	rjmp	80006442 <sram_test+0x52>
800064c2:	0e 93       	mov	r3,r7
800064c4:	fe cc a9 a8 	sub	r12,pc,-22104
800064c8:	fe b0 e4 78 	rcall	80002db8 <print_dbg>
800064cc:	ce bb       	rjmp	800064a2 <sram_test+0xb2>
800064ce:	d7 03       	nop

800064d0 <init_monome>:

//================================================
//----- extern function definitions

// init
void init_monome(void) {
800064d0:	e0 68 30 c4 	mov	r8,12484
800064d4:	30 0a       	mov	r10,0
800064d6:	f0 c9 ff 00 	sub	r9,r8,-256
  u32 i;
  for(i=0; i<MONOME_MAX_LED_BYTES; i++) {
800064da:	10 ca       	st.b	r8++,r10
800064dc:	12 38       	cp.w	r8,r9
    monomeLedBuffer[i] = 0;
  }
  //  print_dbg("\r\n finished monome class init");
}
800064de:	cf e1       	brne	800064da <init_monome+0xa>
800064e0:	5e fc       	retal	r12
800064e2:	d7 03       	nop

800064e4 <monome_grid_key_parse_event_data>:

  ev.eventType = kEventMonomeGridKey;
  post_event(&ev);
}

void monome_grid_key_parse_event_data(u32 data, u8* x, u8* y, u8* val) {
800064e4:	20 1d       	sub	sp,4
  u8* bdata = (u8*)(&data);
  *x = bdata[0];
800064e6:	f8 08 16 18 	lsr	r8,r12,0x18
800064ea:	b6 88       	st.b	r11[0x0],r8
  *y = bdata[1];
800064ec:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
800064f0:	b4 88       	st.b	r10[0x0],r8
  *val = bdata[2];
800064f2:	f9 dc c1 08 	bfextu	r12,r12,0x8,0x8
800064f6:	b2 8c       	st.b	r9[0x0],r12
}
800064f8:	2f fd       	sub	sp,-4
800064fa:	5e fc       	retal	r12

800064fc <monome_calc_quadrant_flag>:
  // TODO
}

// set quadrant refresh flag from pos
void monome_calc_quadrant_flag(u8 x, u8 y) {
  if(x > 7) {
800064fc:	30 78       	mov	r8,7
800064fe:	f0 0c 18 00 	cp.b	r12,r8
80006502:	e0 88 00 0c 	brls	8000651a <monome_calc_quadrant_flag+0x1e>
    if (y > 7) {      
80006506:	f0 0b 18 00 	cp.b	r11,r8
8000650a:	e0 88 00 12 	brls	8000652e <monome_calc_quadrant_flag+0x32>
      monomeFrameDirty |= 0b1000;
8000650e:	e0 69 0b c2 	mov	r9,3010
80006512:	13 88       	ld.ub	r8,r9[0x0]
80006514:	a3 b8       	sbr	r8,0x3
80006516:	b2 88       	st.b	r9[0x0],r8
    }
    else {
      monomeFrameDirty |= 0b0010;
    }
  } else {
    if (y > 7) {
80006518:	5e fc       	retal	r12
8000651a:	f0 0b 18 00 	cp.b	r11,r8
8000651e:	e0 8b 00 0e 	brhi	8000653a <monome_calc_quadrant_flag+0x3e>
      monomeFrameDirty |= 0b0100;
    }
    else {
      monomeFrameDirty |= 0b0001;
80006522:	e0 69 0b c2 	mov	r9,3010
80006526:	13 88       	ld.ub	r8,r9[0x0]
80006528:	a1 a8       	sbr	r8,0x0
  if(x > 7) {
    if (y > 7) {      
      monomeFrameDirty |= 0b1000;
    }
    else {
      monomeFrameDirty |= 0b0010;
8000652a:	b2 88       	st.b	r9[0x0],r8
8000652c:	5e fc       	retal	r12
8000652e:	e0 69 0b c2 	mov	r9,3010
80006532:	13 88       	ld.ub	r8,r9[0x0]
    }
  } else {
    if (y > 7) {
      monomeFrameDirty |= 0b0100;
80006534:	a1 b8       	sbr	r8,0x1
80006536:	b2 88       	st.b	r9[0x0],r8
80006538:	5e fc       	retal	r12
8000653a:	e0 69 0b c2 	mov	r9,3010
8000653e:	13 88       	ld.ub	r8,r9[0x0]
80006540:	a3 a8       	sbr	r8,0x2
80006542:	b2 88       	st.b	r9[0x0],r8
80006544:	5e fc       	retal	r12
80006546:	d7 03       	nop

80006548 <read_serial_40h>:
/// parse serial input from device
/// should be called when read is complete
/// (e.g. from usb transfer callback )

static void read_serial_40h(void) {
}
80006548:	5e fc       	retal	r12

8000654a <grid_map_40h>:
}


static void grid_map_40h(u8 x, u8 y, const u8* data) {
  // TODO : (use 8 row commands and ignore x/y)
}
8000654a:	5e fc       	retal	r12

8000654c <ring_map_mext>:
/*   // TODO */
/* } */

static void ring_map_mext(u8 n, u8* data) {
  // TODO
}
8000654c:	5e fc       	retal	r12
8000654e:	d7 03       	nop

80006550 <read_serial_dummy>:
  u8 tilt;  // has tilt (??)  
} monomeDesc;


//// dummy functions
static void read_serial_dummy(void) {
80006550:	d4 01       	pushm	lr
  print_dbg("\r\n monome dummy handler");
80006552:	fe cc a9 8e 	sub	r12,pc,-22130
80006556:	fe b0 e4 31 	rcall	80002db8 <print_dbg>
  //  return; 
}
8000655a:	d8 02       	popm	pc

8000655c <monome_grid_refresh>:
8000655c:	eb cd 40 80 	pushm	r7,lr
80006560:	e0 67 0b c2 	mov	r7,3010
}

// check dirty flags and refresh leds
void monome_grid_refresh(void) {
  // may need to wait after each quad until tx transfer is complete
  u8 busy = ftdi_tx_busy();
80006564:	e0 a0 0a 7a 	rcall	80007a58 <ftdi_tx_busy>
80006568:	0f 88       	ld.ub	r8,r7[0x0]

  // check quad 0
  if( monomeFrameDirty & 0b0001 ) {
8000656a:	18 99       	mov	r9,r12
8000656c:	ed b8 00 00 	bld	r8,0x0
    (*monome_grid_map)(0, 0, monomeLedBuffer);
    monomeFrameDirty &= 0b1110;
    busy = 1;
  }
  // check quad 1
  if( monomeFrameDirty & 0b0010 ) {
80006570:	c5 10       	breq	80006612 <monome_grid_refresh+0xb6>
80006572:	ed b8 00 01 	bld	r8,0x1
    if ( mdesc.cols > 8 ) {
80006576:	c1 c1       	brne	800065ae <monome_grid_refresh+0x52>
80006578:	31 0a       	mov	r10,16
8000657a:	f5 3b 00 08 	ld.ub	r11,r10[8]
8000657e:	30 8a       	mov	r10,8
80006580:	f4 0b 18 00 	cp.b	r11,r10
80006584:	e0 88 00 15 	brls	800065ae <monome_grid_refresh+0x52>
      while( busy ) { busy = ftdi_tx_busy(); }
80006588:	58 09       	cp.w	r9,0
8000658a:	c0 40       	breq	80006592 <monome_grid_refresh+0x36>
8000658c:	e0 a0 0a 66 	rcall	80007a58 <ftdi_tx_busy>
      (*monome_grid_map)(8, 0, monomeLedBuffer + 8);
80006590:	cf e1       	brne	8000658c <monome_grid_refresh+0x30>
80006592:	e0 68 30 bc 	mov	r8,12476
80006596:	e0 6a 30 c4 	mov	r10,12484
8000659a:	70 08       	ld.w	r8,r8[0x0]
8000659c:	2f 8a       	sub	r10,-8
      monomeFrameDirty &= 0b1101;
8000659e:	30 0b       	mov	r11,0
800065a0:	30 8c       	mov	r12,8
800065a2:	5d 18       	icall	r8
800065a4:	0f 88       	ld.ub	r8,r7[0x0]
800065a6:	30 19       	mov	r9,1
      busy = 1;
    }
  }
  // check quad 2
  if( monomeFrameDirty &  0b0100 ) { 
800065a8:	e2 18 00 0d 	andl	r8,0xd,COH
800065ac:	ae 88       	st.b	r7[0x0],r8
    if( mdesc.rows > 8 ) {
800065ae:	ed b8 00 02 	bld	r8,0x2
800065b2:	c1 c1       	brne	800065ea <monome_grid_refresh+0x8e>
800065b4:	31 0a       	mov	r10,16
800065b6:	f5 3b 00 09 	ld.ub	r11,r10[9]
800065ba:	30 8a       	mov	r10,8
800065bc:	f4 0b 18 00 	cp.b	r11,r10
      while( busy ) { busy = ftdi_tx_busy(); }
800065c0:	e0 88 00 15 	brls	800065ea <monome_grid_refresh+0x8e>
800065c4:	58 09       	cp.w	r9,0
800065c6:	c0 40       	breq	800065ce <monome_grid_refresh+0x72>
      (*monome_grid_map)(0, 8, monomeLedBuffer + 128);
800065c8:	e0 a0 0a 48 	rcall	80007a58 <ftdi_tx_busy>
800065cc:	cf e1       	brne	800065c8 <monome_grid_refresh+0x6c>
800065ce:	e0 68 30 bc 	mov	r8,12476
800065d2:	e0 6a 30 c4 	mov	r10,12484
      monomeFrameDirty &= 0b1011;
800065d6:	70 08       	ld.w	r8,r8[0x0]
800065d8:	28 0a       	sub	r10,-128
800065da:	30 8b       	mov	r11,8
800065dc:	30 0c       	mov	r12,0
800065de:	5d 18       	icall	r8
      busy = 1;
    }
  }
  // check quad 3
  if( monomeFrameDirty & 0b1000 ) {
800065e0:	0f 88       	ld.ub	r8,r7[0x0]
800065e2:	30 19       	mov	r9,1
800065e4:	e2 18 00 0b 	andl	r8,0xb,COH
    if( (mdesc.rows > 8) && (mdesc.cols > 8) )  {
800065e8:	ae 88       	st.b	r7[0x0],r8
800065ea:	ed b8 00 03 	bld	r8,0x3
800065ee:	c0 91       	brne	80006600 <monome_grid_refresh+0xa4>
800065f0:	31 0a       	mov	r10,16
800065f2:	30 88       	mov	r8,8
800065f4:	f5 3b 00 09 	ld.ub	r11,r10[9]
      (*monome_grid_map)(8, 8, monomeLedBuffer + 136);
      monomeFrameDirty &= 0b0111;
      busy = 1;
    }
  }
  while( busy ) { busy = ftdi_tx_busy(); }
800065f8:	f0 0b 18 00 	cp.b	r11,r8
800065fc:	e0 8b 00 1b 	brhi	80006632 <monome_grid_refresh+0xd6>
80006600:	58 09       	cp.w	r9,0
80006602:	c0 40       	breq	8000660a <monome_grid_refresh+0xae>
  // may need to wait after each quad until tx transfer is complete
  u8 busy = ftdi_tx_busy();

  // check quad 0
  if( monomeFrameDirty & 0b0001 ) {
    while( busy ) { busy = ftdi_tx_busy(); }
80006604:	e0 a0 0a 2a 	rcall	80007a58 <ftdi_tx_busy>
80006608:	cf e1       	brne	80006604 <monome_grid_refresh+0xa8>
8000660a:	e3 cd 80 80 	ldm	sp++,r7,pc
    (*monome_grid_map)(0, 0, monomeLedBuffer);
8000660e:	e0 a0 0a 25 	rcall	80007a58 <ftdi_tx_busy>
80006612:	58 0c       	cp.w	r12,0
80006614:	cf d1       	brne	8000660e <monome_grid_refresh+0xb2>
80006616:	30 0b       	mov	r11,0
    monomeFrameDirty &= 0b1110;
80006618:	e0 68 30 bc 	mov	r8,12476
8000661c:	e0 6a 30 c4 	mov	r10,12484
80006620:	70 08       	ld.w	r8,r8[0x0]
80006622:	16 9c       	mov	r12,r11
      busy = 1;
    }
  }
  // check quad 3
  if( monomeFrameDirty & 0b1000 ) {
    if( (mdesc.rows > 8) && (mdesc.cols > 8) )  {
80006624:	5d 18       	icall	r8
80006626:	0f 88       	ld.ub	r8,r7[0x0]
80006628:	30 19       	mov	r9,1
8000662a:	e2 18 00 0e 	andl	r8,0xe,COH
8000662e:	ae 88       	st.b	r7[0x0],r8
      while( busy ) { busy = ftdi_tx_busy(); }
80006630:	ca 1b       	rjmp	80006572 <monome_grid_refresh+0x16>
80006632:	f5 3a 00 08 	ld.ub	r10,r10[8]
80006636:	f0 0a 18 00 	cp.b	r10,r8
      (*monome_grid_map)(8, 8, monomeLedBuffer + 136);
8000663a:	fe 98 ff e3 	brls	80006600 <monome_grid_refresh+0xa4>
8000663e:	58 09       	cp.w	r9,0
80006640:	c0 40       	breq	80006648 <monome_grid_refresh+0xec>
80006642:	e0 a0 0a 0b 	rcall	80007a58 <ftdi_tx_busy>
80006646:	cf e1       	brne	80006642 <monome_grid_refresh+0xe6>
80006648:	30 8b       	mov	r11,8
      monomeFrameDirty &= 0b0111;
8000664a:	e0 68 30 bc 	mov	r8,12476
8000664e:	e0 6a 30 c4 	mov	r10,12484
80006652:	70 08       	ld.w	r8,r8[0x0]
80006654:	f4 ca ff 78 	sub	r10,r10,-136
80006658:	16 9c       	mov	r12,r11
8000665a:	5d 18       	icall	r8
8000665c:	0f 88       	ld.ub	r8,r7[0x0]
8000665e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80006662:	ae 88       	st.b	r7[0x0],r8
80006664:	cd 0b       	rjmp	80006604 <monome_grid_refresh+0xa8>
80006666:	d7 03       	nop

80006668 <grid_map_mext>:

// update a whole frame
// . note that our input data is one byte per led!!
// this will hopefully help optimize operator routines,
// which cannot be called less often than refresh/tx, and are therefore prioritized.
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
80006668:	eb cd 40 c0 	pushm	r6-r7,lr
  //  static u8 tx[11] = { 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
8000666c:	e0 68 0b cc 	mov	r8,3020
  txBuf[1] = x;
80006670:	31 49       	mov	r9,20
  txBuf[2] = y;
80006672:	b0 9c       	st.b	r8[0x1],r12
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
  //  static u8 tx[11] = { 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  static u8* ptx;
  static u8 i, j;

  txBuf[0] = 0x14;
80006674:	b0 ab       	st.b	r8[0x2],r11
  txBuf[1] = x;
  txBuf[2] = y;
80006676:	b0 89       	st.b	r8[0x0],r9
80006678:	f0 ce ff fd 	sub	lr,r8,-3

// update a whole frame
// . note that our input data is one byte per led!!
// this will hopefully help optimize operator routines,
// which cannot be called less often than refresh/tx, and are therefore prioritized.
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
8000667c:	f0 c6 ff f5 	sub	r6,r8,-11
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
80006680:	30 07       	mov	r7,0
80006682:	30 09       	mov	r9,0
80006684:	bc 87       	st.b	lr[0x0],r7
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80006686:	12 9b       	mov	r11,r9
80006688:	f4 09 07 0c 	ld.ub	r12,r10[r9]
8000668c:	ee 0c 18 00 	cp.b	r12,r7
80006690:	5f 1c       	srne	r12
80006692:	f8 09 09 4c 	lsl	r12,r12,r9
80006696:	f9 eb 10 0b 	or	r11,r12,r11
8000669a:	5c 5b       	castu.b	r11
8000669c:	bc 8b       	st.b	lr[0x0],r11
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
8000669e:	2f f9       	sub	r9,-1
800066a0:	58 89       	cp.w	r9,8
800066a2:	cf 31       	brne	80006688 <grid_map_mext+0x20>
  txBuf[2] = y;
  
  ptx = txBuf + 3;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
800066a4:	2f fe       	sub	lr,-1
800066a6:	0c 3e       	cp.w	lr,r6

// update a whole frame
// . note that our input data is one byte per led!!
// this will hopefully help optimize operator routines,
// which cannot be called less often than refresh/tx, and are therefore prioritized.
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
800066a8:	c0 30       	breq	800066ae <grid_map_mext+0x46>
800066aa:	2f 0a       	sub	r10,-16
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 3);
800066ac:	ce bb       	rjmp	80006682 <grid_map_mext+0x1a>

// update a whole frame
// . note that our input data is one byte per led!!
// this will hopefully help optimize operator routines,
// which cannot be called less often than refresh/tx, and are therefore prioritized.
static void grid_map_mext( u8 x, u8 y, const u8* data ) {
800066ae:	10 9c       	mov	r12,r8
800066b0:	e0 6a 0b c8 	mov	r10,3016
800066b4:	2f 58       	sub	r8,-11
800066b6:	b4 89       	st.b	r10[0x0],r9
800066b8:	e0 6a 0b bc 	mov	r10,3004
800066bc:	95 08       	st.w	r10[0x0],r8
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 3);
800066be:	e0 68 0b c1 	mov	r8,3009
}
800066c2:	30 bb       	mov	r11,11
800066c4:	b0 89       	st.b	r8[0x0],r9
800066c6:	e0 a0 0a 23 	rcall	80007b0c <ftdi_write>
800066ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800066ce:	d7 03       	nop

800066d0 <grid_map_series>:
800066d0:	d4 21       	pushm	r4-r7,lr
800066d2:	30 88       	mov	r8,8
800066d4:	f0 0c 18 00 	cp.b	r12,r8
800066d8:	5f b9       	srhi	r9
800066da:	e0 6c 0b cc 	mov	r12,3020
  static u8 * ptx;
  static u8 i, j;
  // command (upper nibble)
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );
800066de:	f0 0b 18 00 	cp.b	r11,r8
800066e2:	e0 8b 00 35 	brhi	8000674c <grid_map_series+0x7c>
800066e6:	ea 19 ff ff 	orh	r9,0xffff
800066ea:	e8 19 ff 80 	orl	r9,0xff80
800066ee:	e0 66 0b c4 	mov	r6,3012

  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
800066f2:	18 c9       	st.b	r12++,r9
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );

  // pointer to tx data
  ptx = txBuf + 1;
800066f4:	e0 64 0c 15 	mov	r4,3093
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
800066f8:	30 08       	mov	r8,0
800066fa:	8d 0c       	st.w	r6[0x0],r12
800066fc:	a8 88       	st.b	r4[0x0],r8
    *ptx = 0;
800066fe:	6c 05       	ld.w	r5,r6[0x0]
80006700:	30 07       	mov	r7,0
80006702:	0a 9c       	mov	r12,r5
80006704:	0e 9e       	mov	lr,r7
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
      // binary value of data byte to bitfield of tx byte
      *ptx |= ((*data > 0) << j);
80006706:	30 08       	mov	r8,0
80006708:	b8 8e       	st.b	r12[0x0],lr
8000670a:	10 99       	mov	r9,r8
8000670c:	f4 08 07 0b 	ld.ub	r11,r10[r8]
80006710:	fc 0b 18 00 	cp.b	r11,lr
80006714:	5f 1b       	srne	r11
80006716:	f6 08 09 4b 	lsl	r11,r11,r8
8000671a:	f7 e9 10 09 	or	r9,r11,r9
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
    *ptx = 0;
    for(j=0; j<MONOME_QUAD_LEDS; j++) {
8000671e:	5c 59       	castu.b	r9
80006720:	b8 89       	st.b	r12[0x0],r9
80006722:	2f f8       	sub	r8,-1
80006724:	58 88       	cp.w	r8,8

  // pointer to tx data
  ptx = txBuf + 1;
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80006726:	cf 31       	brne	8000670c <grid_map_series+0x3c>
80006728:	2f f7       	sub	r7,-1

static void grid_map_40h(u8 x, u8 y, const u8* data) {
  // TODO : (use 8 row commands and ignore x/y)
}

static void grid_map_series(u8 x, u8 y, const u8* data) {
8000672a:	2f fc       	sub	r12,-1
8000672c:	58 87       	cp.w	r7,8
8000672e:	c0 30       	breq	80006734 <grid_map_series+0x64>
80006730:	2f 0a       	sub	r10,-16
80006732:	ce ab       	rjmp	80006706 <grid_map_series+0x36>
80006734:	e0 68 0c 1c 	mov	r8,3100
      data++;
    }
    data += MONOME_QUAD_LEDS; // skip the rest of the row to get back in target quad
    ptx++;
  }
  ftdi_write(txBuf, MONOME_QUAD_LEDS + 1);  
80006738:	2f 85       	sub	r5,-8
8000673a:	a8 87       	st.b	r4[0x0],r7
8000673c:	8d 05       	st.w	r6[0x0],r5
8000673e:	b0 87       	st.b	r8[0x0],r7
}
80006740:	30 9b       	mov	r11,9
  static u8 * ptx;
  static u8 i, j;
  // command (upper nibble)
  txBuf[0] = 0x80;
  // quadrant index (lower nibble, 0-3)
  txBuf[0] |= ( (x > 8) | ((y > 8) << 1) );
80006742:	e0 6c 0b cc 	mov	r12,3020
80006746:	e0 a0 09 e3 	rcall	80007b0c <ftdi_write>
8000674a:	d8 22       	popm	r4-r7,pc
8000674c:	18 98       	mov	r8,r12

  // pointer to tx data
  ptx = txBuf + 1;
8000674e:	ea 19 ff ff 	orh	r9,0xffff
80006752:	e8 19 ff 82 	orl	r9,0xff82
  
  // copy and convert
  for(i=0; i<MONOME_QUAD_LEDS; i++) {
80006756:	10 c9       	st.b	r8++,r9
80006758:	e0 66 0b c4 	mov	r6,3012
8000675c:	e0 64 0c 15 	mov	r4,3093
80006760:	8d 08       	st.w	r6[0x0],r8
80006762:	30 08       	mov	r8,0
80006764:	a8 88       	st.b	r4[0x0],r8
80006766:	cc cb       	rjmp	800066fe <grid_map_series+0x2e>

80006768 <read_serial_series>:
80006768:	d4 31       	pushm	r0-r7,lr
8000676a:	e0 a0 09 6b 	rcall	80007a40 <ftdi_rx_buf>
8000676e:	18 97       	mov	r7,r12
  /// the chip needs some time to elapse before events from here are handled?
  /// (triggering LED refresh?)
  // but in that case why is it an rx error and not tx?
  /// arg

  print_dbg(  "\r\n read_serial_series ... ");
80006770:	fe cc ab 94 	sub	r12,pc,-21612
80006774:	fe b0 e3 22 	rcall	80002db8 <print_dbg>
  rxBytes = ftdi_rx_bytes();
80006778:	e0 a0 09 68 	rcall	80007a48 <ftdi_rx_bytes>
8000677c:	e0 65 0c 14 	mov	r5,3092
  print_dbg(" ... byte count: ");
80006780:	aa 8c       	st.b	r5[0x0],r12
80006782:	fe cc ab 8a 	sub	r12,pc,-21622
  print_dbg_ulong(rxBytes);
80006786:	fe b0 e3 19 	rcall	80002db8 <print_dbg>
  print_dbg(" ; data : [ 0x");
8000678a:	0b 8c       	ld.ub	r12,r5[0x0]
8000678c:	fe b0 e3 10 	rcall	80002dac <print_dbg_ulong>
  print_dbg_hex(prx[0]);
80006790:	fe cc ab 84 	sub	r12,pc,-21628
80006794:	fe b0 e3 12 	rcall	80002db8 <print_dbg>
  print_dbg(" , 0x");
80006798:	0f 8c       	ld.ub	r12,r7[0x0]
8000679a:	fe b0 e2 e1 	rcall	80002d5c <print_dbg_hex>
  print_dbg_hex(prx[1]);
8000679e:	fe cc ab 82 	sub	r12,pc,-21630
  print_dbg(" ]");
800067a2:	fe b0 e3 0b 	rcall	80002db8 <print_dbg>
800067a6:	0f 9c       	ld.ub	r12,r7[0x1]
  i = 0;
  while(i < rxBytes) {
800067a8:	fe b0 e2 da 	rcall	80002d5c <print_dbg_hex>
800067ac:	fe cc ab 88 	sub	r12,pc,-21624
800067b0:	fe b0 e3 04 	rcall	80002db8 <print_dbg>
800067b4:	0b 89       	ld.ub	r9,r5[0x0]
800067b6:	30 08       	mov	r8,0
800067b8:	f0 09 18 00 	cp.b	r9,r8
800067bc:	c2 30       	breq	80006802 <read_serial_series+0x9a>
800067be:	e0 64 0b b4 	mov	r4,2996
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800067c2:	30 06       	mov	r6,0
    /* print_dbg("; y : 0x"); */
    /* print_dbg_hex(prx[1] & 0xf); */
    /* print_dbg(" ; z : 0x"); */
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
800067c4:	e8 c0 ff fc 	sub	r0,r4,-4

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
  data[1] = y;
800067c8:	e8 c1 ff fb 	sub	r1,r4,-5
800067cc:	e8 c2 ff fa 	sub	r2,r4,-6
    /* print_dbg("; y : 0x"); */
    /* print_dbg_hex(prx[1] & 0xf); */
    /* print_dbg(" ; z : 0x"); */
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
800067d0:	31 93       	mov	r3,25
800067d2:	0f 99       	ld.ub	r9,r7[0x1]
// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
  data[1] = y;
  data[2] = val;
800067d4:	0f 88       	ld.ub	r8,r7[0x0]
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800067d6:	f5 d9 c0 04 	bfextu	r10,r9,0x0,0x4
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
				 ((prx[0] & 0xf0) == 0)
				 );
    i += 2;
    prx += 2;
800067da:	a2 8a       	st.b	r1[0x0],r10
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
800067dc:	e2 18 00 f0 	andl	r8,0xf0,COH
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
  post_event(&ev);
800067e0:	5f 08       	sreq	r8
800067e2:	a4 88       	st.b	r2[0x0],r8
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
				 ((prx[0] & 0xf0) == 0)
				 );
    i += 2;
800067e4:	89 03       	st.w	r4[0x0],r3
  print_dbg_hex(prx[0]);
  print_dbg(" , 0x");
  print_dbg_hex(prx[1]);
  print_dbg(" ]");
  i = 0;
  while(i < rxBytes) {
800067e6:	a5 89       	lsr	r9,0x4
    /* print_dbg_hex(	 ((prx[0] & 0xf0) == 0) ); */
    monome_grid_key_write_event( ((prx[1] & 0xf0) >> 4) ,
				 prx[1] & 0xf,
				 ((prx[0] & 0xf0) == 0)
				 );
    i += 2;
800067e8:	2f e7       	sub	r7,-2
  print_dbg_hex(prx[0]);
  print_dbg(" , 0x");
  print_dbg_hex(prx[1]);
  print_dbg(" ]");
  i = 0;
  while(i < rxBytes) {
800067ea:	a0 89       	st.b	r0[0x0],r9
800067ec:	e0 6c 0b b4 	mov	r12,2996
800067f0:	fe b0 f8 d6 	rcall	8000599c <post_event>
800067f4:	2f e6       	sub	r6,-2
800067f6:	0b 88       	ld.ub	r8,r5[0x0]
800067f8:	5c 56       	castu.b	r6
800067fa:	ec 08 18 00 	cp.b	r8,r6
800067fe:	fe 9b ff ea 	brhi	800067d2 <read_serial_series+0x6a>
80006802:	d8 32       	popm	r0-r7,pc

80006804 <read_serial_mext>:
80006804:	d4 31       	pushm	r0-r7,lr
80006806:	e0 64 0c 14 	mov	r4,3092
8000680a:	e0 a0 09 1f 	rcall	80007a48 <ftdi_rx_bytes>
8000680e:	a8 8c       	st.b	r4[0x0],r12
80006810:	c0 21       	brne	80006814 <read_serial_mext+0x10>
80006812:	d8 32       	popm	r0-r7,pc
80006814:	30 08       	mov	r8,0
80006816:	e0 65 0b c0 	mov	r5,3008
8000681a:	e0 67 0c 18 	mov	r7,3096
8000681e:	aa 88       	st.b	r5[0x0],r8
80006820:	e0 a0 09 10 	rcall	80007a40 <ftdi_rx_buf>
80006824:	e0 61 0b b4 	mov	r1,2996
    nbp = 0;
    prx = ftdi_rx_buf();
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
      nbp++;
      switch(com) {
80006828:	8f 0c       	st.w	r7[0x0],r12

//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
8000682a:	0e 93       	mov	r3,r7
  static u8 com;
  
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
    nbp = 0;
    prx = ftdi_rx_buf();
8000682c:	e0 62 0b c3 	mov	r2,3011
    while(nbp < rxBytes) {
80006830:	0a 90       	mov	r0,r5
80006832:	35 06       	mov	r6,80
80006834:	2f c1       	sub	r1,-4
80006836:	0b 88       	ld.ub	r8,r5[0x0]
      com = (u8)(*(prx++));    
80006838:	09 8c       	ld.ub	r12,r4[0x0]
      nbp++;
8000683a:	f0 0c 18 00 	cp.b	r12,r8
8000683e:	fe 98 ff ea 	brls	80006812 <read_serial_mext+0xe>
80006842:	6e 0b       	ld.w	r11,r7[0x0]
  rxBytes = ftdi_rx_bytes();
  if( rxBytes ) {
    nbp = 0;
    prx = ftdi_rx_buf();
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
80006844:	2f f8       	sub	r8,-1
80006846:	16 99       	mov	r9,r11
      nbp++;
      switch(com) {
80006848:	5c 58       	castu.b	r8
8000684a:	13 3a       	ld.ub	r10,r9++
8000684c:	aa 88       	st.b	r5[0x0],r8
8000684e:	a4 8a       	st.b	r2[0x0],r10
80006850:	8f 09       	st.w	r7[0x0],r9
80006852:	ec 0a 18 00 	cp.b	r10,r6
80006856:	c3 e0       	breq	800068d2 <read_serial_mext+0xce>
80006858:	e0 8b 00 20 	brhi	80006898 <read_serial_mext+0x94>
8000685c:	32 0b       	mov	r11,32
8000685e:	f6 0a 18 00 	cp.b	r10,r11
	monome_grid_key_write_event( *prx, *(prx+1), 0);
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
80006862:	c2 c0       	breq	800068ba <read_serial_mext+0xb6>
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
80006864:	32 18       	mov	r8,33
  data[1] = y;
80006866:	f0 0a 18 00 	cp.b	r10,r8
  data[2] = val;
8000686a:	cd 41       	brne	80006812 <read_serial_mext+0xe>
8000686c:	13 98       	ld.ub	r8,r9[0x1]
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
8000686e:	13 8a       	ld.ub	r10,r9[0x0]
80006870:	a2 98       	st.b	r1[0x1],r8
  post_event(&ev);
80006872:	a2 8a       	st.b	r1[0x0],r10
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
80006874:	30 18       	mov	r8,1
  post_event(&ev);
80006876:	a2 a8       	st.b	r1[0x2],r8
80006878:	e0 6b 0b b4 	mov	r11,2996
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
	prx += 2;
8000687c:	31 98       	mov	r8,25
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
8000687e:	16 9c       	mov	r12,r11
	prx += 2;
80006880:	97 08       	st.w	r11[0x0],r8
	nbp += 2;
	prx += 2;
	break;
      case 0x21: // grid key down
	monome_grid_key_write_event( *prx, *(prx+1), 1);
	nbp += 2;
80006882:	fe b0 f8 8d 	rcall	8000599c <post_event>
80006886:	01 88       	ld.ub	r8,r0[0x0]
	prx += 2;
80006888:	66 09       	ld.w	r9,r3[0x0]
	break;
8000688a:	2f e8       	sub	r8,-2
    nbp = 0;
    prx = ftdi_rx_buf();
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
      nbp++;
      switch(com) {
8000688c:	2f e9       	sub	r9,-2
8000688e:	5c 58       	castu.b	r8
80006890:	87 09       	st.w	r3[0x0],r9
80006892:	a0 88       	st.b	r0[0x0],r8
80006894:	09 8c       	ld.ub	r12,r4[0x0]
80006896:	cd 2b       	rjmp	8000683a <read_serial_mext+0x36>
80006898:	35 1b       	mov	r11,81
8000689a:	f6 0a 18 00 	cp.b	r10,r11
	monome_ring_key_write_event( *prx++, 0);
	prx++;
	break;
      case 0x52 : // ring key down
	monome_ring_key_write_event( *prx++, 1);
	nbp++;
8000689e:	c0 b0       	breq	800068b4 <read_serial_mext+0xb0>
      case 0x51 : // ring key up
	monome_ring_key_write_event( *prx++, 0);
	prx++;
	break;
      case 0x52 : // ring key down
	monome_ring_key_write_event( *prx++, 1);
800068a0:	35 2b       	mov	r11,82
	nbp++;
800068a2:	f6 0a 18 00 	cp.b	r10,r11
800068a6:	cb 61       	brne	80006812 <read_serial_mext+0xe>
	nbp += 2;
	prx += 2;
	break;
      case 0x51 : // ring key up
	monome_ring_key_write_event( *prx++, 0);
	prx++;
800068a8:	2f f9       	sub	r9,-1
800068aa:	2f f8       	sub	r8,-1
	break;
800068ac:	87 09       	st.w	r3[0x0],r9
    while(nbp < rxBytes) {
      com = (u8)(*(prx++));    
      nbp++;
      switch(com) {
      case 0x20: // grid key up
	monome_grid_key_write_event( *prx, *(prx+1), 0);
800068ae:	5c 58       	castu.b	r8
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
800068b0:	a0 88       	st.b	r0[0x0],r8
  data[1] = y;
800068b2:	cc 4b       	rjmp	8000683a <read_serial_mext+0x36>
//---- convert to/from event data

// grid key
static inline void monome_grid_key_write_event(u8 x, u8 y, u8 val) {
  u8* data = (u8*)(&(ev.eventData));
  data[0] = x;
800068b4:	2f e9       	sub	r9,-2
  data[1] = y;
  data[2] = val;
800068b6:	87 09       	st.w	r3[0x0],r9
800068b8:	cc 1b       	rjmp	8000683a <read_serial_mext+0x36>
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800068ba:	13 98       	ld.ub	r8,r9[0x1]
800068bc:	13 8a       	ld.ub	r10,r9[0x0]
  post_event(&ev);
800068be:	a2 98       	st.b	r1[0x1],r8
  /* print_dbg("; y: 0x"); */
  /* print_dbg_hex(y); */
  /* print_dbg("; z: 0x"); */
  /* print_dbg_hex(val); */

  ev.eventType = kEventMonomeGridKey;
800068c0:	a2 8a       	st.b	r1[0x0],r10
800068c2:	30 08       	mov	r8,0
	nbp += 2;
	prx += 2;
	break;
	case 0x50: // ring delta
	monome_ring_enc_write_event( *prx, *(prx+1));
	nbp += 2;
800068c4:	a2 a8       	st.b	r1[0x2],r8
	prx += 2;
800068c6:	e0 69 0b b4 	mov	r9,2996
800068ca:	31 98       	mov	r8,25
	nbp += 2;
	prx += 2;
	break;
	case 0x50: // ring delta
	monome_ring_enc_write_event( *prx, *(prx+1));
	nbp += 2;
800068cc:	12 9c       	mov	r12,r9
	prx += 2;
	break;
800068ce:	93 08       	st.w	r9[0x0],r8
800068d0:	cd 9b       	rjmp	80006882 <read_serial_mext+0x7e>
800068d2:	2f e8       	sub	r8,-2
800068d4:	2f db       	sub	r11,-3
800068d6:	5c 58       	castu.b	r8
800068d8:	87 0b       	st.w	r3[0x0],r11
800068da:	a0 88       	st.b	r0[0x0],r8
800068dc:	ca fb       	rjmp	8000683a <read_serial_mext+0x36>
800068de:	d7 03       	nop

800068e0 <setup_series>:
800068e0:	eb cd 40 c0 	pushm	r6-r7,lr
800068e4:	fe cc ac bc 	sub	r12,pc,-21316
800068e8:	fe b0 e2 68 	rcall	80002db8 <print_dbg>
800068ec:	30 88       	mov	r8,8
800068ee:	31 07       	mov	r7,16
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
800068f0:	ef 68 00 09 	st.b	r7[9],r8
// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
800068f4:	ef 68 00 08 	st.b	r7[8],r8
}

// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
800068f8:	30 08       	mov	r8,0
  mdesc.device = eDeviceGrid;
800068fa:	30 16       	mov	r6,1
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
800068fc:	8f 18       	st.w	r7[0x4],r8
}

// setup series device
static void setup_series(u8 cols, u8 rows) {
  print_dbg("\r\n setup series device");
  mdesc.protocol = eProtocolSeries;
800068fe:	fe cc ac be 	sub	r12,pc,-21314
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  mdesc.tilt = 1;
80006902:	8f 06       	st.w	r7[0x0],r6
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80006904:	ef 66 00 0b 	st.b	r7[11],r6
  print_dbg_ulong(mdesc.protocol);
80006908:	fe b0 e2 58 	rcall	80002db8 <print_dbg>
8000690c:	6e 0c       	ld.w	r12,r7[0x0]
  monome_read_serial = readSerialFuncs[mdesc.protocol];
8000690e:	fe b0 e2 4f 	rcall	80002dac <print_dbg_ulong>
80006912:	fe c9 ad 5a 	sub	r9,pc,-21158
80006916:	6e 08       	ld.w	r8,r7[0x0]
80006918:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
  monome_grid_map = gridMapFuncs[mdesc.protocol];
8000691c:	30 c9       	mov	r9,12
8000691e:	93 0a       	st.w	r9[0x0],r10
80006920:	e0 6a 30 bc 	mov	r10,12476
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
80006924:	fe c9 ad 78 	sub	r9,pc,-21128
  monome_ring_map = ringMapFuncs[mdesc.protocol];
80006928:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
8000692c:	95 09       	st.w	r10[0x0],r9
8000692e:	e0 6a 31 c4 	mov	r10,12740
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  mdesc.tilt = 1;
  set_funcs();
  monomeConnect = 1;
80006932:	95 09       	st.w	r10[0x0],r9
80006934:	fe c9 ad 94 	sub	r9,pc,-21100
  test_draw();
}
80006938:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
8000693c:	e0 68 30 c0 	mov	r8,12480
80006940:	91 09       	st.w	r8[0x0],r9
80006942:	e0 68 0b c9 	mov	r8,3017
80006946:	b0 86       	st.b	r8[0x0],r6
80006948:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000694c <check_monome_device_desc>:
8000694c:	d4 21       	pushm	r4-r7,lr
8000694e:	20 5d       	sub	sp,20
80006950:	14 94       	mov	r4,r10
80006952:	1a 96       	mov	r6,sp
80006954:	fa ca ff fa 	sub	r10,sp,-6
80006958:	1a 97       	mov	r7,sp
8000695a:	1a 98       	mov	r8,sp
8000695c:	19 89       	ld.ub	r9,r12[0x0]
8000695e:	2f ec       	sub	r12,-2
80006960:	10 c9       	st.b	r8++,r9
80006962:	14 38       	cp.w	r8,r10
80006964:	cf c1       	brne	8000695c <check_monome_device_desc+0x10>
80006966:	30 08       	mov	r8,0
80006968:	30 6a       	mov	r10,6
8000696a:	ba e8       	st.b	sp[0x6],r8
8000696c:	fe cb ad 00 	sub	r11,pc,-21248
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
  }
  buf[i] = 0;
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
80006970:	1a 9c       	mov	r12,sp
80006972:	e0 a0 1f d2 	rcall	8000a916 <strncmp>
  }
  //  print_dbg("\r\n finished monome class init");
}

// determine if FTDI string descriptors match monome device pattern
u8 check_monome_device_desc(char* mstr, char* pstr, char* sstr) {
80006976:	fa c9 ff f7 	sub	r9,sp,-9
  // manufacturer
  for(i=0; i<MONOME_MANSTR_LEN; i++) {
    buf[i] = mstr[i*2];
  }
  buf[i] = 0;
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
8000697a:	18 95       	mov	r5,r12
  /* print_dbg("\r\n manstring: "); */
  /* print_dbg(buf); */
 
  // serial number string
  for(i=0; i<MONOME_SERSTR_LEN; i++) {
    buf[i] = sstr[i*2];
8000697c:	09 88       	ld.ub	r8,r4[0x0]
8000697e:	2f e4       	sub	r4,-2
80006980:	0e c8       	st.b	r7++,r8
  matchMan = ( strncmp(buf, "monome", MONOME_MANSTR_LEN) == 0 );
  /* print_dbg("\r\n manstring: "); */
  /* print_dbg(buf); */
 
  // serial number string
  for(i=0; i<MONOME_SERSTR_LEN; i++) {
80006982:	12 37       	cp.w	r7,r9
80006984:	cf c1       	brne	8000697c <check_monome_device_desc+0x30>
    buf[i] = sstr[i*2];
  }
  buf[i] = 0;
80006986:	30 08       	mov	r8,0
80006988:	fb 68 00 09 	st.b	sp[9],r8
  /* print_dbg("\r\n serial string: "); */
  /* print_dbg(buf); */
  if(matchMan == 0) {
8000698c:	58 05       	cp.w	r5,0
8000698e:	c0 c0       	breq	800069a6 <check_monome_device_desc+0x5a>
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
80006990:	1a 9c       	mov	r12,sp
80006992:	30 4a       	mov	r10,4
80006994:	fe cb ad 20 	sub	r11,pc,-21216
80006998:	e0 a0 1f bf 	rcall	8000a916 <strncmp>
8000699c:	e0 80 00 9c 	breq	80006ad4 <check_monome_device_desc+0x188>
  } else {
    return 0;
  }
  set_funcs();
  monomeConnect = 1;
  print_dbg("\r\n connected monome device, mext protocol");
800069a0:	30 0c       	mov	r12,0
    // if we got here, serial number didn't match series or 40h patterns.
    // so this is probably an extended-protocol device.
    // we need to query for device attributes
    return setup_mext();
  }
}
800069a2:	2f bd       	sub	sp,-20
800069a4:	d8 22       	popm	r4-r7,pc
    } else {
      // not a monome
      return 0;
    }
  } else { // matched manufctrr string
    if(buf[0] != 'm') {
800069a6:	36 d8       	mov	r8,109
800069a8:	1b 89       	ld.ub	r9,sp[0x0]
800069aa:	f0 09 18 00 	cp.b	r9,r8
800069ae:	cf 91       	brne	800069a0 <check_monome_device_desc+0x54>
      // not a monome, somehow. shouldn't happen
      return 0;
    }
    if(buf[3] == 'h') {
800069b0:	36 88       	mov	r8,104
800069b2:	1b b9       	ld.ub	r9,sp[0x3]
800069b4:	f0 09 18 00 	cp.b	r9,r8
800069b8:	e0 80 00 e1 	breq	80006b7a <check_monome_device_desc+0x22e>
      // this is a 40h
      setup_40h(8, 8);
      return 1;
    }
    if( strncmp(buf, "m64-", 4) == 0 ) {
800069bc:	30 4a       	mov	r10,4
800069be:	fe cb ad 42 	sub	r11,pc,-21182
800069c2:	1a 9c       	mov	r12,sp
800069c4:	e0 a0 1f a9 	rcall	8000a916 <strncmp>
800069c8:	e0 80 00 cf 	breq	80006b66 <check_monome_device_desc+0x21a>
      // series 64
      setup_series(8, 8);
      return 1;
    }
    if( strncmp(buf, "m128-", 5) == 0 ) {
800069cc:	1a 9c       	mov	r12,sp
800069ce:	30 5a       	mov	r10,5
800069d0:	fe cb ad 4c 	sub	r11,pc,-21172
800069d4:	e0 a0 1f a1 	rcall	8000a916 <strncmp>
800069d8:	e0 80 00 cc 	breq	80006b70 <check_monome_device_desc+0x224>
static u8 setup_mext(void) {
  u8* prx;
  u8 w = 0;
  u8 busy;

  print_dbg("\r\n setup mext device");
800069dc:	fe cc ad 50 	sub	r12,pc,-21168
}

// setup extended device, return success /failure of query
static u8 setup_mext(void) {
  u8* prx;
  u8 w = 0;
800069e0:	fb 65 00 13 	st.b	sp[19],r5
  u8 busy;

  print_dbg("\r\n setup mext device");
800069e4:	fe b0 e1 ea 	rcall	80002db8 <print_dbg>

  mdesc.protocol = eProtocolMext;
800069e8:	30 28       	mov	r8,2
800069ea:	31 07       	mov	r7,16
800069ec:	8f 08       	st.w	r7[0x0],r8
800069ee:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800069f2:	30 09       	mov	r9,0
800069f4:	e0 6a d0 e7 	mov	r10,53479
800069f8:	ea 1a 27 56 	orh	r10,0x2756
800069fc:	30 0b       	mov	r11,0
800069fe:	e0 a0 1b 57 	rcall	8000a0ac <__avr32_udiv64>
80006a02:	14 96       	mov	r6,r10
80006a04:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006a08:	f0 0a 00 0a 	add	r10,r8,r10
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006a0c:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a10:	14 38       	cp.w	r8,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006a12:	e0 88 00 6b 	brls	80006ae8 <check_monome_device_desc+0x19c>
80006a16:	12 38       	cp.w	r8,r9
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006a18:	fe 98 ff fa 	brls	80006a0c <check_monome_device_desc+0xc0>
80006a1c:	12 3a       	cp.w	r10,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006a1e:	cf 72       	brcc	80006a0c <check_monome_device_desc+0xc0>
80006a20:	30 1b       	mov	r11,1

  delay_ms(10);
  ftdi_write(&w, 1);	// query
80006a22:	fa cc ff ed 	sub	r12,sp,-19
80006a26:	e0 a0 08 73 	rcall	80007b0c <ftdi_write>
80006a2a:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006a2e:	f0 06 00 0a 	add	r10,r8,r6
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006a32:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a36:	14 38       	cp.w	r8,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006a38:	e0 88 00 0c 	brls	80006a50 <check_monome_device_desc+0x104>
80006a3c:	12 38       	cp.w	r8,r9
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006a3e:	e0 88 00 04 	brls	80006a46 <check_monome_device_desc+0xfa>
80006a42:	12 3a       	cp.w	r10,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006a44:	c0 93       	brcs	80006a56 <check_monome_device_desc+0x10a>
80006a46:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a4a:	14 38       	cp.w	r8,r10
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006a4c:	fe 9b ff f8 	brhi	80006a3c <check_monome_device_desc+0xf0>
80006a50:	12 38       	cp.w	r8,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006a52:	fe 98 ff f8 	brls	80006a42 <check_monome_device_desc+0xf6>
80006a56:	e0 a0 08 45 	rcall	80007ae0 <ftdi_read>
  
  delay_ms(10);

  ftdi_read();
80006a5a:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006a5e:	f0 06 00 06 	add	r6,r8,r6
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006a62:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a66:	0c 38       	cp.w	r8,r6
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006a68:	e0 88 00 0c 	brls	80006a80 <check_monome_device_desc+0x134>
80006a6c:	12 38       	cp.w	r8,r9
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006a6e:	e0 88 00 04 	brls	80006a76 <check_monome_device_desc+0x12a>
80006a72:	12 36       	cp.w	r6,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006a74:	c0 93       	brcs	80006a86 <check_monome_device_desc+0x13a>
80006a76:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006a7a:	0c 38       	cp.w	r8,r6
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006a7c:	fe 9b ff f8 	brhi	80006a6c <check_monome_device_desc+0x120>
80006a80:	12 38       	cp.w	r8,r9
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006a82:	fe 98 ff f8 	brls	80006a72 <check_monome_device_desc+0x126>
80006a86:	fe cc ac ee 	sub	r12,pc,-21266

  delay_ms(10);
  busy = 1;

  print_dbg("\r\n setup request ftdi read; waiting...");
80006a8a:	fe b0 e1 97 	rcall	80002db8 <print_dbg>

  //  while(ftdi_rx_busy()) {;;}
  while(busy) {
    busy = ftdi_rx_busy();
80006a8e:	e0 a0 07 e1 	rcall	80007a50 <ftdi_rx_busy>
80006a92:	18 96       	mov	r6,r12
    print_dbg("\r\n waiting for transfer complete; busy flag: ");
80006a94:	fe cc ad f0 	sub	r12,pc,-21008
80006a98:	fe b0 e1 90 	rcall	80002db8 <print_dbg>
    print_dbg_ulong(busy);
80006a9c:	0c 9c       	mov	r12,r6
80006a9e:	fe b0 e1 87 	rcall	80002dac <print_dbg_ulong>
  busy = 1;

  print_dbg("\r\n setup request ftdi read; waiting...");

  //  while(ftdi_rx_busy()) {;;}
  while(busy) {
80006aa2:	58 06       	cp.w	r6,0
    busy = ftdi_rx_busy();
    print_dbg("\r\n waiting for transfer complete; busy flag: ");
    print_dbg_ulong(busy);
    
  }
  rxBytes = ftdi_rx_bytes();
80006aa4:	cf 51       	brne	80006a8e <check_monome_device_desc+0x142>
80006aa6:	e0 a0 07 d1 	rcall	80007a48 <ftdi_rx_bytes>
80006aaa:	e0 65 0c 14 	mov	r5,3092

  print_dbg(" done waiting. bytes read: ");
80006aae:	aa 8c       	st.b	r5[0x0],r12
80006ab0:	fe cc ad dc 	sub	r12,pc,-21028
  print_dbg_ulong(rxBytes);
80006ab4:	fe b0 e1 82 	rcall	80002db8 <print_dbg>

  if(rxBytes != 6 ){
80006ab8:	0b 8c       	ld.ub	r12,r5[0x0]
80006aba:	fe b0 e1 79 	rcall	80002dac <print_dbg_ulong>
80006abe:	0b 89       	ld.ub	r9,r5[0x0]
80006ac0:	30 68       	mov	r8,6
    print_dbg("\r\n got unexpected byte count in response to mext setup request; aborting");
80006ac2:	f0 09 18 00 	cp.b	r9,r8
80006ac6:	c1 50       	breq	80006af0 <check_monome_device_desc+0x1a4>
80006ac8:	fe cc ad d8 	sub	r12,pc,-21032
  /* print_dbg(buf); */
  if(matchMan == 0) {
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
80006acc:	fe b0 e1 76 	rcall	80002db8 <print_dbg>
      mdesc.device = eDeviceGrid;
80006ad0:	0c 9c       	mov	r12,r6
  /* print_dbg(buf); */
  if(matchMan == 0) {
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
80006ad2:	c6 8b       	rjmp	800069a2 <check_monome_device_desc+0x56>
      mdesc.device = eDeviceGrid;
      mdesc.cols = 8;
      mdesc.rows = 8;
80006ad4:	31 08       	mov	r8,16
80006ad6:	30 89       	mov	r9,8
    // didn't match the manufacturer string, but check the serial for DIYs
    if( strncmp(buf, "a40h", 4) == 0) {
      // this is probably an arduinome      
      mdesc.protocol = eProtocol40h;
      mdesc.device = eDeviceGrid;
      mdesc.cols = 8;
80006ad8:	91 1c       	st.w	r8[0x4],r12
80006ada:	91 0c       	st.w	r8[0x0],r12
      mdesc.rows = 8;
80006adc:	f1 69 00 09 	st.b	r8[9],r9
80006ae0:	f1 69 00 08 	st.b	r8[8],r9
80006ae4:	2f bd       	sub	sp,-20
80006ae6:	da 2a       	popm	r4-r7,pc,r12=1
  if(rxBytes != 6 ){
    print_dbg("\r\n got unexpected byte count in response to mext setup request; aborting");
    return 0;
  }
  
  prx = ftdi_rx_buf();
80006ae8:	12 38       	cp.w	r8,r9
80006aea:	fe 9b ff 9b 	brhi	80006a20 <check_monome_device_desc+0xd4>
  prx++; // 1st returned byte is 0
80006aee:	c9 7b       	rjmp	80006a1c <check_monome_device_desc+0xd0>
  if(*prx == 1) {
80006af0:	e0 a0 07 a8 	rcall	80007a40 <ftdi_rx_buf>
80006af4:	30 19       	mov	r9,1
80006af6:	2f fc       	sub	r12,-1
    else {
      return 0;
    }		
    mdesc.tilt = 1;
  }
  else if(*prx == 5) {
80006af8:	19 88       	ld.ub	r8,r12[0x0]
80006afa:	f2 08 18 00 	cp.b	r8,r9
80006afe:	c6 b0       	breq	80006bd4 <check_monome_device_desc+0x288>
80006b00:	30 59       	mov	r9,5
    mdesc.device = eDeviceArc;
80006b02:	f2 08 18 00 	cp.b	r8,r9
    mdesc.encs = *(++prx);
80006b06:	fe 91 ff 4d 	brne	800069a0 <check_monome_device_desc+0x54>
80006b0a:	30 18       	mov	r8,1
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80006b0c:	8f 18       	st.w	r7[0x4],r8
80006b0e:	19 98       	ld.ub	r8,r12[0x1]
80006b10:	ef 68 00 0a 	st.b	r7[10],r8
  print_dbg_ulong(mdesc.protocol);
80006b14:	fe cc ae d4 	sub	r12,pc,-20780
  monome_read_serial = readSerialFuncs[mdesc.protocol];
80006b18:	fe b0 e1 50 	rcall	80002db8 <print_dbg>
80006b1c:	6e 0c       	ld.w	r12,r7[0x0]
80006b1e:	fe b0 e1 47 	rcall	80002dac <print_dbg_ulong>
80006b22:	fe c9 af 6a 	sub	r9,pc,-20630
  monome_grid_map = gridMapFuncs[mdesc.protocol];
80006b26:	6e 08       	ld.w	r8,r7[0x0]
80006b28:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
80006b2c:	30 c9       	mov	r9,12
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
80006b2e:	93 0a       	st.w	r9[0x0],r10
80006b30:	e0 6a 30 bc 	mov	r10,12476
  monome_ring_map = ringMapFuncs[mdesc.protocol];
80006b34:	fe c9 af 88 	sub	r9,pc,-20600
80006b38:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
    mdesc.encs = *(++prx);
  } else {
    return 0;
  }
  set_funcs();
  monomeConnect = 1;
80006b3c:	95 09       	st.w	r10[0x0],r9
80006b3e:	e0 6a 31 c4 	mov	r10,12740
80006b42:	95 09       	st.w	r10[0x0],r9
  print_dbg("\r\n connected monome device, mext protocol");
80006b44:	fe c9 af a4 	sub	r9,pc,-20572
80006b48:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
      setup_40h(8, 8);
      return 1;
    }
    if( strncmp(buf, "m64-", 4) == 0 ) {
      // series 64
      setup_series(8, 8);
80006b4c:	e0 68 30 c0 	mov	r8,12480
80006b50:	91 09       	st.w	r8[0x0],r9
80006b52:	30 19       	mov	r9,1
80006b54:	e0 68 0b c9 	mov	r8,3017
      return 1;
    }
    if( strncmp(buf, "m128-", 5) == 0 ) {
      // series 128
      setup_series(8, 16);
80006b58:	fe cc ad ec 	sub	r12,pc,-21012
80006b5c:	b0 89       	st.b	r8[0x0],r9
80006b5e:	fe b0 e1 2d 	rcall	80002db8 <print_dbg>
      return 1;
80006b62:	30 1c       	mov	r12,1

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
80006b64:	c1 fb       	rjmp	800069a2 <check_monome_device_desc+0x56>
  monome_ring_map = ringMapFuncs[mdesc.protocol];
}

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
80006b66:	30 8b       	mov	r11,8
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80006b68:	16 9c       	mov	r12,r11
// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
80006b6a:	cb be       	rcall	800068e0 <setup_series>
80006b6c:	30 1c       	mov	r12,1

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
80006b6e:	c1 ab       	rjmp	800069a2 <check_monome_device_desc+0x56>
80006b70:	30 8c       	mov	r12,8
}

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
80006b72:	31 0b       	mov	r11,16
  monome_ring_map = ringMapFuncs[mdesc.protocol];
}

// setup 40h-protocol device
static void setup_40h(u8 cols, u8 rows) {
  mdesc.protocol = eProtocol40h;
80006b74:	cb 6e       	rcall	800068e0 <setup_series>
//=============================================
//------ static function definitions

// set function pointers
static inline void set_funcs(void) {
  print_dbg("\r\n setting monome functions, protocol idx: ");
80006b76:	30 1c       	mov	r12,1
80006b78:	c1 5b       	rjmp	800069a2 <check_monome_device_desc+0x56>
  print_dbg_ulong(mdesc.protocol);
80006b7a:	30 88       	mov	r8,8
80006b7c:	31 07       	mov	r7,16
80006b7e:	fe cc af 3e 	sub	r12,pc,-20674
  monome_read_serial = readSerialFuncs[mdesc.protocol];
80006b82:	ef 68 00 09 	st.b	r7[9],r8
80006b86:	ef 68 00 08 	st.b	r7[8],r8
80006b8a:	8f 15       	st.w	r7[0x4],r5
  monome_grid_map = gridMapFuncs[mdesc.protocol];
80006b8c:	8f 05       	st.w	r7[0x0],r5
80006b8e:	fe b0 e1 15 	rcall	80002db8 <print_dbg>
80006b92:	6e 0c       	ld.w	r12,r7[0x0]
80006b94:	fe b0 e1 0c 	rcall	80002dac <print_dbg_ulong>
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
80006b98:	fe c9 af e0 	sub	r9,pc,-20512
  monome_ring_map = ringMapFuncs[mdesc.protocol];
80006b9c:	6e 08       	ld.w	r8,r7[0x0]
80006b9e:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  set_funcs();
  monomeConnect = 1;
80006ba2:	30 c9       	mov	r9,12
  print_dbg("\r\n setting monome functions, protocol idx: ");
  print_dbg_ulong(mdesc.protocol);
  monome_read_serial = readSerialFuncs[mdesc.protocol];
  monome_grid_map = gridMapFuncs[mdesc.protocol];
  monome_grid_level_map = gridMapFuncs[mdesc.protocol];
  monome_ring_map = ringMapFuncs[mdesc.protocol];
80006ba4:	93 0a       	st.w	r9[0x0],r10
  mdesc.protocol = eProtocol40h;
  mdesc.device = eDeviceGrid;
  mdesc.cols = 8;
  mdesc.rows = 8;
  set_funcs();
  monomeConnect = 1;
80006ba6:	e0 6a 30 bc 	mov	r10,12476
80006baa:	fe c9 af fe 	sub	r9,pc,-20482
  }
  
  prx = ftdi_rx_buf();
  prx++; // 1st returned byte is 0
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
80006bae:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
    prx++;
    if(*prx == 1) {
80006bb2:	95 09       	st.w	r10[0x0],r9
80006bb4:	e0 6a 31 c4 	mov	r10,12740
80006bb8:	95 09       	st.w	r10[0x0],r9
      print_dbg("\r\n monome 64");
      mdesc.rows = 8;
      mdesc.cols = 8;
    }
    else if(*prx == 2) {
80006bba:	fe c9 b0 1a 	sub	r9,pc,-20454
80006bbe:	f2 08 03 29 	ld.w	r9,r9[r8<<0x2]
      print_dbg("\r\n monome 128");
      mdesc.rows = 8;
      mdesc.cols = 16;
    }
    else if(*prx == 4) {
80006bc2:	e0 68 30 c0 	mov	r8,12480
80006bc6:	30 1c       	mov	r12,1
80006bc8:	91 09       	st.w	r8[0x0],r9
80006bca:	30 19       	mov	r9,1
      print_dbg("\r\n monome 256");
80006bcc:	e0 68 0b c9 	mov	r8,3017
80006bd0:	b0 89       	st.b	r8[0x0],r9
      mdesc.rows = 16; 
80006bd2:	ce 8a       	rjmp	800069a2 <check_monome_device_desc+0x56>
      mdesc.cols = 16;
80006bd4:	8f 16       	st.w	r7[0x4],r6
80006bd6:	31 06       	mov	r6,16
      mdesc.rows = 8;
      mdesc.cols = 16;
    }
    else if(*prx == 4) {
      print_dbg("\r\n monome 256");
      mdesc.rows = 16; 
80006bd8:	19 98       	ld.ub	r8,r12[0x1]
80006bda:	f2 08 18 00 	cp.b	r8,r9
      mdesc.cols = 16;
    }
    else {
      return 0;
    }		
    mdesc.tilt = 1;
80006bde:	c1 70       	breq	80006c0c <check_monome_device_desc+0x2c0>
80006be0:	30 29       	mov	r9,2
80006be2:	f2 08 18 00 	cp.b	r8,r9
  prx++; // 1st returned byte is 0
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
    prx++;
    if(*prx == 1) {
      print_dbg("\r\n monome 64");
80006be6:	c1 d0       	breq	80006c20 <check_monome_device_desc+0x2d4>
80006be8:	30 49       	mov	r9,4
      mdesc.rows = 8;
80006bea:	f2 08 18 00 	cp.b	r8,r9
      mdesc.cols = 8;
80006bee:	fe 91 fe d9 	brne	800069a0 <check_monome_device_desc+0x54>
  if(*prx == 1) {
    mdesc.device = eDeviceGrid;
    prx++;
    if(*prx == 1) {
      print_dbg("\r\n monome 64");
      mdesc.rows = 8;
80006bf2:	fe cc ae 96 	sub	r12,pc,-20842
      mdesc.cols = 8;
    }
    else if(*prx == 2) {
      print_dbg("\r\n monome 128");
80006bf6:	fe b0 e0 e1 	rcall	80002db8 <print_dbg>
80006bfa:	31 08       	mov	r8,16
      mdesc.rows = 8;
80006bfc:	ed 68 00 08 	st.b	r6[8],r8
80006c00:	ed 68 00 09 	st.b	r6[9],r8
      mdesc.cols = 16;
80006c04:	30 18       	mov	r8,1
80006c06:	ef 68 00 0b 	st.b	r7[11],r8
80006c0a:	c8 5b       	rjmp	80006b14 <check_monome_device_desc+0x1c8>
80006c0c:	fe cc ae d0 	sub	r12,pc,-20784
80006c10:	fe b0 e0 d4 	rcall	80002db8 <print_dbg>
80006c14:	30 88       	mov	r8,8
80006c16:	ed 68 00 08 	st.b	r6[8],r8
80006c1a:	ed 68 00 09 	st.b	r6[9],r8
80006c1e:	cf 3b       	rjmp	80006c04 <check_monome_device_desc+0x2b8>
80006c20:	fe cc ae d4 	sub	r12,pc,-20780
80006c24:	fe b0 e0 ca 	rcall	80002db8 <print_dbg>
80006c28:	30 88       	mov	r8,8
80006c2a:	ed 68 00 09 	st.b	r6[9],r8
80006c2e:	31 08       	mov	r8,16
80006c30:	ed 68 00 08 	st.b	r6[8],r8
80006c34:	ce 8b       	rjmp	80006c04 <check_monome_device_desc+0x2b8>
80006c36:	d7 03       	nop

80006c38 <screen_clear>:
}



 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
80006c38:	eb cd 40 e0 	pushm	r5-r7,lr
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80006c3c:	30 0b       	mov	r11,0
80006c3e:	fe 7c 28 00 	mov	r12,-55296
80006c42:	fe b0 de 1d 	rcall	8000287c <spi_selectChip>
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
80006c46:	30 9c       	mov	r12,9
80006c48:	fe b0 dc 59 	rcall	800024fa <gpio_set_gpio_pin>
  for(i=0; i<GRAM_BYTES; i++) { 
80006c4c:	30 09       	mov	r9,0
80006c4e:	e0 67 0c 20 	mov	r7,3104
80006c52:	12 98       	mov	r8,r9
80006c54:	8f 09       	st.w	r7[0x0],r9
    screenBuf[i] = 0;
80006c56:	e0 65 0c 24 	mov	r5,3108
80006c5a:	12 96       	mov	r6,r9
    //    write_data(0);
    spi_write(OLED_SPI, 0);
80006c5c:	ea 08 0b 06 	st.b	r5[r8],r6
80006c60:	30 0b       	mov	r11,0
80006c62:	fe 7c 28 00 	mov	r12,-55296
 // clear OLED RAM and local screenbuffer
void screen_clear(void) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select high to write data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  for(i=0; i<GRAM_BYTES; i++) { 
80006c66:	fe b0 de a0 	rcall	800029a6 <spi_write>
80006c6a:	6e 08       	ld.w	r8,r7[0x0]
80006c6c:	2f f8       	sub	r8,-1
80006c6e:	8f 08       	st.w	r7[0x0],r8
80006c70:	e0 48 0f ff 	cp.w	r8,4095
    screenBuf[i] = 0;
    //    write_data(0);
    spi_write(OLED_SPI, 0);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80006c74:	fe 98 ff f4 	brls	80006c5c <screen_clear+0x24>
80006c78:	30 0b       	mov	r11,0
80006c7a:	fe 7c 28 00 	mov	r12,-55296
}
80006c7e:	fe b0 de 27 	rcall	800028cc <spi_unselectChip>
80006c82:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006c86:	d7 03       	nop

80006c88 <screen_startup>:
80006c88:	eb cd 40 e0 	pushm	r5-r7,lr
80006c8c:	e0 65 0c 24 	mov	r5,3108
80006c90:	37 79       	mov	r9,119
80006c92:	0a 97       	mov	r7,r5
80006c94:	ea c6 f0 00 	sub	r6,r5,-4096
80006c98:	0a 98       	mov	r8,r5
80006c9a:	10 c9       	st.b	r8++,r9
// startup screen (FIXME: just grey at the moment)
void screen_startup(void) {
  u32 i;

  // fill screenbuffer with grey background
  for(i=0; i<GRAM_BYTES; i++) {
80006c9c:	0c 38       	cp.w	r8,r6
    screenBuf[i] = 0x77;
  }

  // net art: draw glyphs to screen buf directly,
  // should be stretched out and upside down
  font_glyph('A', screenBuf + 80,      64, 0xff, 0x44);
80006c9e:	cf e1       	brne	80006c9a <screen_startup+0x12>
80006ca0:	34 48       	mov	r8,68
80006ca2:	e0 69 00 ff 	mov	r9,255
80006ca6:	34 0a       	mov	r10,64
80006ca8:	ea cb ff b0 	sub	r11,r5,-80
80006cac:	34 1c       	mov	r12,65
80006cae:	fe b0 f8 7d 	rcall	80005da8 <font_glyph>
  font_glyph('L', screenBuf + 80 + 8,  64, 0xff, 0x44);
80006cb2:	34 48       	mov	r8,68
80006cb4:	e0 69 00 ff 	mov	r9,255
80006cb8:	34 0a       	mov	r10,64
80006cba:	ea cb ff a8 	sub	r11,r5,-88
80006cbe:	34 cc       	mov	r12,76
80006cc0:	fe b0 f8 74 	rcall	80005da8 <font_glyph>
  font_glyph('E', screenBuf + 80 + 16, 64, 0xff, 0x44);
80006cc4:	34 48       	mov	r8,68
80006cc6:	e0 69 00 ff 	mov	r9,255
80006cca:	34 0a       	mov	r10,64
80006ccc:	ea cb ff a0 	sub	r11,r5,-96
80006cd0:	34 5c       	mov	r12,69
80006cd2:	fe b0 f8 6b 	rcall	80005da8 <font_glyph>
  font_glyph('P', screenBuf + 80 + 24, 64, 0xff, 0x44);
80006cd6:	34 48       	mov	r8,68
80006cd8:	e0 69 00 ff 	mov	r9,255
80006cdc:	34 0a       	mov	r10,64
80006cde:	ea cb ff 98 	sub	r11,r5,-104
80006ce2:	35 0c       	mov	r12,80
80006ce4:	fe b0 f8 62 	rcall	80005da8 <font_glyph>
  font_glyph('H', screenBuf + 80 + 32, 64, 0xff, 0x44);
80006ce8:	ea cb ff 90 	sub	r11,r5,-112
80006cec:	34 48       	mov	r8,68
80006cee:	e0 69 00 ff 	mov	r9,255
80006cf2:	34 0a       	mov	r10,64
80006cf4:	34 8c       	mov	r12,72
80006cf6:	fe b0 f8 59 	rcall	80005da8 <font_glyph>

    // send screenbuffer
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
80006cfa:	30 0b       	mov	r11,0
80006cfc:	fe 7c 28 00 	mov	r12,-55296
80006d00:	fe b0 dd be 	rcall	8000287c <spi_selectChip>
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
80006d04:	30 9c       	mov	r12,9
80006d06:	fe b0 db fa 	rcall	800024fa <gpio_set_gpio_pin>
  // send data
  for(i=0; i<GRAM_BYTES; i++) {
    spi_write(OLED_SPI, screenBuf[i]);
80006d0a:	0f 3b       	ld.ub	r11,r7++
80006d0c:	fe 7c 28 00 	mov	r12,-55296
80006d10:	fe b0 de 4b 	rcall	800029a6 <spi_write>
    // send screenbuffer
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // register select high for data
  gpio_set_gpio_pin(OLED_REGISTER_PIN);
  // send data
  for(i=0; i<GRAM_BYTES; i++) {
80006d14:	0c 37       	cp.w	r7,r6
    spi_write(OLED_SPI, screenBuf[i]);
  }
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS); 
80006d16:	cf a1       	brne	80006d0a <screen_startup+0x82>
80006d18:	30 0b       	mov	r11,0
80006d1a:	fe 7c 28 00 	mov	r12,-55296
80006d1e:	fe b0 dd d7 	rcall	800028cc <spi_unselectChip>
}
80006d22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006d26:	d7 03       	nop

80006d28 <write_command>:
80006d28:	eb cd 40 80 	pushm	r7,lr
80006d2c:	30 0b       	mov	r11,0
80006d2e:	18 97       	mov	r7,r12
80006d30:	fe 7c 28 00 	mov	r12,-55296
80006d34:	fe b0 dd a4 	rcall	8000287c <spi_selectChip>
80006d38:	30 9c       	mov	r12,9
80006d3a:	fe b0 db ed 	rcall	80002514 <gpio_clr_gpio_pin>
static void write_command(U8 c);
static void write_command(U8 c) {
  spi_selectChip(OLED_SPI, OLED_SPI_NPCS);
  // pull register select low to write a command
  gpio_clr_gpio_pin(OLED_REGISTER_PIN);
  spi_write(OLED_SPI, c);
80006d3e:	0e 9b       	mov	r11,r7
80006d40:	fe 7c 28 00 	mov	r12,-55296
80006d44:	fe b0 de 31 	rcall	800029a6 <spi_write>
  spi_unselectChip(OLED_SPI, OLED_SPI_NPCS);
80006d48:	30 0b       	mov	r11,0
80006d4a:	fe 7c 28 00 	mov	r12,-55296
80006d4e:	fe b0 dd bf 	rcall	800028cc <spi_unselectChip>
}
80006d52:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d56:	d7 03       	nop

80006d58 <init_oled>:
80006d58:	eb cd 40 e0 	pushm	r5-r7,lr
80006d5c:	d3 03       	ssrf	0x10
80006d5e:	30 7c       	mov	r12,7
80006d60:	fe b0 db cd 	rcall	800024fa <gpio_set_gpio_pin>
80006d64:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006d68:	30 09       	mov	r9,0
80006d6a:	30 07       	mov	r7,0
80006d6c:	e0 66 14 80 	mov	r6,5248
80006d70:	ea 16 03 ef 	orh	r6,0x3ef
80006d74:	e0 6a 18 67 	mov	r10,6247
80006d78:	ea 1a 03 ef 	orh	r10,0x3ef
80006d7c:	30 0b       	mov	r11,0
80006d7e:	e0 a0 19 97 	rcall	8000a0ac <__avr32_udiv64>
80006d82:	14 95       	mov	r5,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006d84:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006d88:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006d8c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006d90:	14 38       	cp.w	r8,r10
80006d92:	e0 88 00 dd 	brls	80006f4c <init_oled+0x1f4>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006d96:	12 38       	cp.w	r8,r9
80006d98:	fe 98 ff fa 	brls	80006d8c <init_oled+0x34>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006d9c:	12 3a       	cp.w	r10,r9
80006d9e:	cf 72       	brcc	80006d8c <init_oled+0x34>
  Disable_global_interrupt();
  //  delay_ms(1);
  // flip the reset pin
  gpio_set_gpio_pin(OLED_RESET_PIN);
  delay_ms(1);
  gpio_clr_gpio_pin(OLED_RESET_PIN);
80006da0:	30 7c       	mov	r12,7
80006da2:	fe b0 db b9 	rcall	80002514 <gpio_clr_gpio_pin>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006da6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006daa:	f0 05 00 05 	add	r5,r8,r5
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006dae:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006db2:	0a 38       	cp.w	r8,r5
80006db4:	e0 88 00 0c 	brls	80006dcc <init_oled+0x74>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006db8:	12 38       	cp.w	r8,r9
80006dba:	e0 88 00 04 	brls	80006dc2 <init_oled+0x6a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006dbe:	12 35       	cp.w	r5,r9
80006dc0:	c0 93       	brcs	80006dd2 <init_oled+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006dc2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006dc6:	0a 38       	cp.w	r8,r5
80006dc8:	fe 9b ff f8 	brhi	80006db8 <init_oled+0x60>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006dcc:	12 38       	cp.w	r8,r9
80006dce:	fe 98 ff f8 	brls	80006dbe <init_oled+0x66>
  delay_ms(1);
  gpio_set_gpio_pin(OLED_RESET_PIN);
80006dd2:	30 7c       	mov	r12,7
80006dd4:	fe b0 db 93 	rcall	800024fa <gpio_set_gpio_pin>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80006dd8:	ee 0c 10 0a 	mul	r12,r7,10
80006ddc:	e0 68 03 e8 	mov	r8,1000
80006de0:	30 07       	mov	r7,0
80006de2:	30 09       	mov	r9,0
80006de4:	30 ab       	mov	r11,10
80006de6:	ec 0b 06 4a 	mulu.d	r10,r6,r11
80006dea:	e0 66 03 e7 	mov	r6,999
80006dee:	f8 0b 00 0b 	add	r11,r12,r11
80006df2:	0c 0a       	add	r10,r6
80006df4:	f6 07 00 4b 	adc	r11,r11,r7
80006df8:	e0 a0 19 5a 	rcall	8000a0ac <__avr32_udiv64>
80006dfc:	14 97       	mov	r7,r10
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80006dfe:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80006e02:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006e06:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006e0a:	14 38       	cp.w	r8,r10
80006e0c:	e0 88 00 0c 	brls	80006e24 <init_oled+0xcc>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80006e10:	12 38       	cp.w	r8,r9
80006e12:	e0 88 00 04 	brls	80006e1a <init_oled+0xc2>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006e16:	12 3a       	cp.w	r10,r9
80006e18:	c0 93       	brcs	80006e2a <init_oled+0xd2>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80006e1a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80006e1e:	14 38       	cp.w	r8,r10
80006e20:	fe 9b ff f8 	brhi	80006e10 <init_oled+0xb8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80006e24:	12 38       	cp.w	r8,r9
80006e26:	fe 98 ff f8 	brls	80006e16 <init_oled+0xbe>
  delay_ms(10);

  //// initialize OLED
  write_command(0xAE);	// off
80006e2a:	e0 6c 00 ae 	mov	r12,174
80006e2e:	c7 df       	rcall	80006d28 <write_command>
80006e30:	e0 6c 00 b3 	mov	r12,179
  write_command(0xB3);	// clock rate
80006e34:	c7 af       	rcall	80006d28 <write_command>
80006e36:	e0 6c 00 91 	mov	r12,145
  write_command(0x91);
80006e3a:	c7 7f       	rcall	80006d28 <write_command>
80006e3c:	e0 6c 00 a8 	mov	r12,168
80006e40:	c7 4f       	rcall	80006d28 <write_command>
  write_command(0xA8);	// multiplex
80006e42:	33 fc       	mov	r12,63
80006e44:	c7 2f       	rcall	80006d28 <write_command>
80006e46:	e0 6c 00 86 	mov	r12,134
  write_command(0x3F);
80006e4a:	c6 ff       	rcall	80006d28 <write_command>
80006e4c:	e0 6c 00 81 	mov	r12,129
  write_command(0x86);	// full current range
80006e50:	c6 cf       	rcall	80006d28 <write_command>
80006e52:	37 fc       	mov	r12,127
80006e54:	c6 af       	rcall	80006d28 <write_command>
80006e56:	e0 6c 00 b2 	mov	r12,178
  write_command(0x81);	// contrast to full
80006e5a:	c6 7f       	rcall	80006d28 <write_command>
80006e5c:	35 1c       	mov	r12,81
80006e5e:	c6 5f       	rcall	80006d28 <write_command>
  write_command(0x7F);
80006e60:	e0 6c 00 a8 	mov	r12,168
80006e64:	c6 2f       	rcall	80006d28 <write_command>
  write_command(0xB2);	// frame freq
80006e66:	33 fc       	mov	r12,63
80006e68:	c6 0f       	rcall	80006d28 <write_command>
80006e6a:	e0 6c 00 bc 	mov	r12,188
  write_command(0x51);
80006e6e:	c5 df       	rcall	80006d28 <write_command>
80006e70:	31 0c       	mov	r12,16
80006e72:	c5 bf       	rcall	80006d28 <write_command>
  write_command(0xA8);	// multiplex
80006e74:	e0 6c 00 be 	mov	r12,190
80006e78:	c5 8f       	rcall	80006d28 <write_command>
80006e7a:	31 cc       	mov	r12,28
  write_command(0x3F);
80006e7c:	c5 6f       	rcall	80006d28 <write_command>
80006e7e:	e0 6c 00 ad 	mov	r12,173
  write_command(0xBC);	// precharge
80006e82:	c5 3f       	rcall	80006d28 <write_command>
80006e84:	30 2c       	mov	r12,2
80006e86:	c5 1f       	rcall	80006d28 <write_command>
80006e88:	e0 6c 00 a0 	mov	r12,160
  write_command(0x10);
80006e8c:	c4 ef       	rcall	80006d28 <write_command>
80006e8e:	35 0c       	mov	r12,80
  write_command(0xBE);	// voltage
80006e90:	c4 cf       	rcall	80006d28 <write_command>
80006e92:	e0 6c 00 a1 	mov	r12,161
80006e96:	c4 9f       	rcall	80006d28 <write_command>
  write_command(0x1C);
80006e98:	30 0c       	mov	r12,0
80006e9a:	c4 7f       	rcall	80006d28 <write_command>
80006e9c:	e0 6c 00 a2 	mov	r12,162
  write_command(0xAD);	// dcdc
80006ea0:	c4 4f       	rcall	80006d28 <write_command>
80006ea2:	34 cc       	mov	r12,76
80006ea4:	c4 2f       	rcall	80006d28 <write_command>
  write_command(0x02);
80006ea6:	e0 6c 00 b1 	mov	r12,177
80006eaa:	c3 ff       	rcall	80006d28 <write_command>
  write_command(0xA0);	// remap
80006eac:	35 5c       	mov	r12,85
80006eae:	c3 df       	rcall	80006d28 <write_command>
80006eb0:	e0 6c 00 b4 	mov	r12,180
  write_command(0x50);	// 0b01010000
80006eb4:	c3 af       	rcall	80006d28 <write_command>
80006eb6:	30 2c       	mov	r12,2
80006eb8:	c3 8f       	rcall	80006d28 <write_command>
			// a[6] : enable COM split odd/even
			// a[4] : enable COM re-map
  write_command(0xA1);	// start
80006eba:	e0 6c 00 b0 	mov	r12,176
80006ebe:	c3 5f       	rcall	80006d28 <write_command>
80006ec0:	32 8c       	mov	r12,40
  write_command(0x0);
80006ec2:	c3 3f       	rcall	80006d28 <write_command>
80006ec4:	e0 6c 00 bf 	mov	r12,191
  write_command(0xA2);	// offset
80006ec8:	c3 0f       	rcall	80006d28 <write_command>
80006eca:	30 fc       	mov	r12,15
80006ecc:	c2 ef       	rcall	80006d28 <write_command>
80006ece:	e0 6c 00 a4 	mov	r12,164
  write_command(0x4C);
80006ed2:	c2 bf       	rcall	80006d28 <write_command>
80006ed4:	e0 6c 00 b8 	mov	r12,184
  write_command(0xB1);	// set phase
80006ed8:	c2 8f       	rcall	80006d28 <write_command>
80006eda:	30 1c       	mov	r12,1
80006edc:	c2 6f       	rcall	80006d28 <write_command>
  write_command(0x55);
80006ede:	31 1c       	mov	r12,17
80006ee0:	c2 4f       	rcall	80006d28 <write_command>
80006ee2:	32 2c       	mov	r12,34
  write_command(0xB4);	// precharge
80006ee4:	c2 2f       	rcall	80006d28 <write_command>
80006ee6:	33 2c       	mov	r12,50
80006ee8:	c2 0f       	rcall	80006d28 <write_command>
80006eea:	34 3c       	mov	r12,67
  write_command(0x02);
80006eec:	c1 ef       	rcall	80006d28 <write_command>
80006eee:	35 4c       	mov	r12,84
80006ef0:	c1 cf       	rcall	80006d28 <write_command>
  write_command(0xB0);	// precharge
80006ef2:	36 5c       	mov	r12,101
80006ef4:	c1 af       	rcall	80006d28 <write_command>
80006ef6:	37 6c       	mov	r12,118
80006ef8:	c1 8f       	rcall	80006d28 <write_command>
  write_command(0x28);
80006efa:	31 5c       	mov	r12,21
80006efc:	c1 6f       	rcall	80006d28 <write_command>
80006efe:	30 0c       	mov	r12,0
  write_command(0xBF);	// vsl
80006f00:	c1 4f       	rcall	80006d28 <write_command>
80006f02:	33 fc       	mov	r12,63
80006f04:	c1 2f       	rcall	80006d28 <write_command>
80006f06:	37 5c       	mov	r12,117
  write_command(0x0F);
80006f08:	c1 0f       	rcall	80006d28 <write_command>
80006f0a:	30 0c       	mov	r12,0
80006f0c:	c0 ef       	rcall	80006d28 <write_command>
  write_command(0xA4);	// normal display
80006f0e:	33 fc       	mov	r12,63
80006f10:	c0 cf       	rcall	80006d28 <write_command>
80006f12:	c9 3e       	rcall	80006c38 <screen_clear>
80006f14:	e0 6c 00 af 	mov	r12,175
  write_command(0xB8);	// greyscale table
80006f18:	c0 8f       	rcall	80006d28 <write_command>
80006f1a:	e1 b8 00 42 	mfsr	r8,0x108
  write_command(0x01);
80006f1e:	f0 07 00 07 	add	r7,r8,r7
80006f22:	e1 b9 00 42 	mfsr	r9,0x108
  write_command(0x11);
80006f26:	0e 38       	cp.w	r8,r7
80006f28:	e0 88 00 0c 	brls	80006f40 <init_oled+0x1e8>
  write_command(0x22);
80006f2c:	12 38       	cp.w	r8,r9
80006f2e:	e0 88 00 04 	brls	80006f36 <init_oled+0x1de>
  write_command(0x32);
80006f32:	12 37       	cp.w	r7,r9
80006f34:	c0 93       	brcs	80006f46 <init_oled+0x1ee>
  write_command(0x43);
80006f36:	e1 b9 00 42 	mfsr	r9,0x108
80006f3a:	0e 38       	cp.w	r8,r7
  write_command(0x54);
80006f3c:	fe 9b ff f8 	brhi	80006f2c <init_oled+0x1d4>
80006f40:	12 38       	cp.w	r8,r9
  write_command(0x65);
80006f42:	fe 98 ff f8 	brls	80006f32 <init_oled+0x1da>
80006f46:	d5 03       	csrf	0x10
  write_command(0x76);	
80006f48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f4c:	12 38       	cp.w	r8,r9
		
  // set update box (to full screen)
  write_command(0x15);
80006f4e:	fe 9b ff 29 	brhi	80006da0 <init_oled+0x48>
80006f52:	c2 5b       	rjmp	80006d9c <init_oled+0x44>

80006f54 <process_sw>:
  kEventSwitch7,
};


// generate events from switch interrupts
void process_sw( const U8 swIdx )  {
80006f54:	eb cd 40 80 	pushm	r7,lr
  static event_t e;   
  e.eventType = kSwitchEvents[swIdx];
80006f58:	fe c8 b1 98 	sub	r8,pc,-20072
80006f5c:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
80006f60:	e0 67 1c 24 	mov	r7,7204
  e.eventData = gpio_get_pin_value(kSwitchPins[swIdx]);
80006f64:	8f 08       	st.w	r7[0x0],r8
80006f66:	fe c8 b1 86 	sub	r8,pc,-20090
80006f6a:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
  post_event(&e);
80006f6e:	fe b0 da bb 	rcall	800024e4 <gpio_get_pin_value>
80006f72:	8f 1c       	st.w	r7[0x4],r12
}
80006f74:	0e 9c       	mov	r12,r7
80006f76:	fe b0 f5 13 	rcall	8000599c <post_event>
80006f7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f7e:	d7 03       	nop

80006f80 <process_timers>:


// process the list of timers.
// called from tc interrupt
/// FIXME: this is overly generalized for our purpose, i think.
void process_timers( void ) {
80006f80:	eb cd 40 e0 	pushm	r5-r7,lr
80006f84:	e0 67 1c 2c 	mov	r7,7212
80006f88:	ee c5 ff d0 	sub	r5,r7,-48
	// if periodic, reload the timer
	if ( t->fperiodic ) {
	  t->timeout = t->timeoutReload;
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80006f8c:	c0 48       	rjmp	80006f94 <process_timers+0x14>
void process_timers( void ) {
  int k;
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
80006f8e:	2f c7       	sub	r7,-4
80006f90:	0a 37       	cp.w	r7,r5
    // Skip unused timer slots...
    t = timers[k];
80006f92:	c1 d0       	breq	80006fcc <process_timers+0x4c>
    if ( t == 0 ) { continue; }
80006f94:	6e 06       	ld.w	r6,r7[0x0]
80006f96:	58 06       	cp.w	r6,0

    if ( t->timeout > 0 ) {
80006f98:	cf b0       	breq	80006f8e <process_timers+0xe>
      // time remaining, decrement tick counter
      t->timeout--;
80006f9a:	6c 28       	ld.w	r8,r6[0x8]
80006f9c:	f0 c9 00 01 	sub	r9,r8,1
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    // Skip unused timer slots...
    t = timers[k];
    if ( t == 0 ) { continue; }

    if ( t->timeout > 0 ) {
80006fa0:	58 08       	cp.w	r8,0
80006fa2:	fe 9a ff f6 	brle	80006f8e <process_timers+0xe>
      // time remaining, decrement tick counter
      t->timeout--;

      // if timer expired, call the callback function
      if ( t->timeout <= 0 ) {
80006fa6:	8d 29       	st.w	r6[0x8],r9
80006fa8:	58 09       	cp.w	r9,0
	if ( t->callback != 0 ) {
80006faa:	cf 21       	brne	80006f8e <process_timers+0xe>
80006fac:	6c 48       	ld.w	r8,r6[0x10]
80006fae:	58 08       	cp.w	r8,0
	  (*t->callback)( t->tag );
80006fb0:	c0 30       	breq	80006fb6 <process_timers+0x36>
80006fb2:	6c 1c       	ld.w	r12,r6[0x4]
	}

	// if periodic, reload the timer
	if ( t->fperiodic ) {
80006fb4:	5d 18       	icall	r8
	  t->timeout = t->timeoutReload;
80006fb6:	6c 08       	ld.w	r8,r6[0x0]
80006fb8:	58 08       	cp.w	r8,0
80006fba:	ed f8 10 03 	ld.wne	r8,r6[0xc]
80006fbe:	ed f8 1a 02 	st.wne	r6[0x8],r8
	} else {
	  // delete non-periodic timerx
	  timers[k] = NULL;
80006fc2:	ef f8 0a 00 	st.weq	r7[0x0],r8
void process_timers( void ) {
  int k;
  swTimer_t* t;

  // Process the timer list 
  for ( k = 0; k < MAX_TIMERS; k++ ) {
80006fc6:	2f c7       	sub	r7,-4
80006fc8:	0a 37       	cp.w	r7,r5
	  timers[k] = NULL;
	}
      }
    }
  }
}
80006fca:	ce 51       	brne	80006f94 <process_timers+0x14>
80006fcc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006fd0 <set_timer>:
80006fd0:	eb cd 40 f8 	pushm	r3-r7,lr
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
80006fd4:	58 09       	cp.w	r9,0
80006fd6:	c2 a0       	breq	8000702a <set_timer+0x5a>
  int k;
  swTimer_t* t;

  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80006fd8:	d3 43       	ssrf	0x14
80006fda:	e0 64 1c 2c 	mov	r4,7212
    timers[ k ] = 0;
  }
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
80006fde:	08 93       	mov	r3,r4
80006fe0:	e8 c5 ff d0 	sub	r5,r4,-48
80006fe4:	08 9e       	mov	lr,r4
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
	  // tag and callback both specified and matched
	  //	  if (fReenableInterrupts)
	  //	    Enable_interrupt_level( TIMER_INT_LEVEL );
	  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006fe6:	c0 48       	rjmp	80006fee <set_timer+0x1e>

  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);

  for ( k = 0; k < MAX_TIMERS; k++ ) {
80006fe8:	2f ce       	sub	lr,-4
80006fea:	0a 3e       	cp.w	lr,r5
    t = timers[k];
80006fec:	c0 d0       	breq	80007006 <set_timer+0x36>
    if ( t == NULL ) {
80006fee:	7c 07       	ld.w	r7,lr[0x0]
80006ff0:	58 07       	cp.w	r7,0
      continue;
    }

    if ( t->tag == tag ) {
80006ff2:	cf b0       	breq	80006fe8 <set_timer+0x18>
80006ff4:	6e 16       	ld.w	r6,r7[0x4]
80006ff6:	0c 3b       	cp.w	r11,r6
      if ( callback != NULL ) {
	if ( t->callback == callback ) {
80006ff8:	cf 81       	brne	80006fe8 <set_timer+0x18>
80006ffa:	6e 47       	ld.w	r7,r7[0x10]
80006ffc:	0e 39       	cp.w	r9,r7
	  // tag and callback both specified and matched
	  //	  if (fReenableInterrupts)
	  //	    Enable_interrupt_level( TIMER_INT_LEVEL );
	  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80006ffe:	cf 51       	brne	80006fe8 <set_timer+0x18>
80007000:	d5 43       	csrf	0x14
80007002:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
  // dont add if callback appears in the list
  if ( find_timer( callback, tag ) != NULL ) {
    return false;
  }

  t->callback = callback;
80007006:	d5 43       	csrf	0x14
  t->tag = tag;
80007008:	99 49       	st.w	r12[0x10],r9
  t->timeout = ticks;
  t->fperiodic = fPeriodic;
8000700a:	99 1b       	st.w	r12[0x4],r11
  t->timeoutReload = ticks;
8000700c:	99 08       	st.w	r12[0x0],r8
    return false;
  }

  t->callback = callback;
  t->tag = tag;
  t->timeout = ticks;
8000700e:	99 3a       	st.w	r12[0xc],r10
// Add timer to pointer array. Finds first empty slot.
static bool add_timer( swTimer_t* newTimer) {
  int k;
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
80007010:	99 2a       	st.w	r12[0x8],r10
80007012:	d3 43       	ssrf	0x14
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
80007014:	30 08       	mov	r8,0
80007016:	66 09       	ld.w	r9,r3[0x0]
80007018:	58 09       	cp.w	r9,0
  //  bool fReenableInterrupts = Is_interrupt_level_enabled( TIMER_INT_LEVEL );
  //  Disable_interrupt_level( TIMER_INT_LEVEL );
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
8000701a:	c0 b0       	breq	80007030 <set_timer+0x60>
8000701c:	2f f8       	sub	r8,-1
8000701e:	2f c3       	sub	r3,-4
80007020:	58 c8       	cp.w	r8,12
      //      Enable_interrupt_level( TIMER_INT_LEVEL );
      return true;
    }
  }

  cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80007022:	cf a1       	brne	80007016 <set_timer+0x46>
80007024:	d5 43       	csrf	0x14
80007026:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
}

// Add a callback timer to the list.
bool set_timer(  swTimer_t* t, int tag, int ticks, timerCallback callback,
		 bool fPeriodic ) {
  if ( callback == NULL ) {
8000702a:	12 9c       	mov	r12,r9
8000702c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
  cpu_irq_disable_level(APP_TC_IRQ_PRIORITY);
  
  // find empty slot
  for ( k = 0; k < MAX_TIMERS; k++ ) {
    if ( timers[k] ==  NULL ) {
      timers[k] = newTimer;
80007030:	e8 08 09 2c 	st.w	r4[r8<<0x2],r12
      cpu_irq_enable_level(APP_TC_IRQ_PRIORITY);
80007034:	d5 43       	csrf	0x14
80007036:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
8000703a:	d7 03       	nop

8000703c <dac_inc>:
   }
   return ret;
}


static void dac_inc(u8 idx, s32 inc) {
8000703c:	d4 21       	pushm	r4-r7,lr
  s32 v = dacVal[idx] + inc;
8000703e:	e0 65 1c 68 	mov	r5,7272
80007042:	18 96       	mov	r6,r12
80007044:	ea 0c 03 27 	ld.w	r7,r5[r12<<0x2]
80007048:	f6 07 00 07 	add	r7,r11,r7
  if(v > 0xffff) {
8000704c:	e0 47 ff ff 	cp.w	r7,65535
80007050:	e0 8a 00 13 	brle	80007076 <dac_inc+0x3a>
80007054:	e0 67 ff ff 	mov	r7,65535
  }
  if(v < 0) {
    v = 0;
  }
  /// HACK: there are only 4 parameters, which correspond to the dac values.
  bfin_set_param(idx, v);
80007058:	0e 94       	mov	r4,r7
8000705a:	0e 9b       	mov	r11,r7
8000705c:	0c 9c       	mov	r12,r6
8000705e:	fe b0 f3 2f 	rcall	800056bc <bfin_set_param>
  print_dbg("\r\n setting dac output value: ");
80007062:	fe cc b1 b2 	sub	r12,pc,-20046
  print_dbg_hex(v);
80007066:	fe b0 de a9 	rcall	80002db8 <print_dbg>
8000706a:	08 9c       	mov	r12,r4
  dacVal[idx] = v;
8000706c:	fe b0 de 78 	rcall	80002d5c <print_dbg_hex>
}
80007070:	ea 06 09 27 	st.w	r5[r6<<0x2],r7
static void dac_inc(u8 idx, s32 inc) {
  s32 v = dacVal[idx] + inc;
  if(v > 0xffff) {
    v = 0xffff;
  }
  if(v < 0) {
80007074:	d8 22       	popm	r4-r7,pc
80007076:	58 07       	cp.w	r7,0
80007078:	cf 04       	brge	80007058 <dac_inc+0x1c>
8000707a:	30 04       	mov	r4,0
8000707c:	08 97       	mov	r7,r4
8000707e:	ce eb       	rjmp	8000705a <dac_inc+0x1e>

80007080 <main>:
80007080:	d4 31       	pushm	r0-r7,lr
80007082:	20 2d       	sub	sp,8
80007084:	fe b0 ed 66 	rcall	80004b50 <sysclk_init>
80007088:	30 4c       	mov	r12,4
8000708a:	fe b0 ed 1d 	rcall	80004ac4 <sysclk_enable_pbb_module>
8000708e:	e0 6c 14 80 	mov	r12,5248
  // setup clocks
  sysclk_init();

  // not sure why but when need to explictly enable clock for static mem ctlr
  sysclk_enable_pbb_module(SYSCLK_SMC_REGS);
  flashc_set_bus_freq(FCPU_HZ);
80007092:	ea 1c 03 ef 	orh	r12,0x3ef
80007096:	fe b0 d8 12 	rcall	800020ba <flashc_set_bus_freq>
  // need this for high-speed operation
  flashc_set_wait_state(1);
8000709a:	30 1c       	mov	r12,1
8000709c:	fe b0 d8 08 	rcall	800020ac <flashc_set_wait_state>

  /// interrupts
  //  print_dbg("\r\n  irq_initialize_vectors() ");
  irq_initialize_vectors();
800070a0:	fe b0 da d2 	rcall	80002644 <INTC_init_interrupts>
  // disable all interrupts for now
  //  print_dbg("\r\n  cpu_irq_disable() ");
  cpu_irq_disable();
800070a4:	d3 03       	ssrf	0x10

  // serial usb
  print_dbg("\r\n  init_ftdi_usart() ");
800070a6:	fe cc b1 d6 	sub	r12,pc,-20010
800070aa:	fe b0 de 87 	rcall	80002db8 <print_dbg>
  init_ftdi_usart();
800070ae:	fe b0 f7 89 	rcall	80005fc0 <init_ftdi_usart>
  // external sram
  print_dbg("\r\n  smc_init(FHSB_HZ) ");
800070b2:	fe cc b1 ca 	sub	r12,pc,-20022
800070b6:	fe b0 de 81 	rcall	80002db8 <print_dbg>
  smc_init(FHSB_HZ);
800070ba:	e0 6c 14 80 	mov	r12,5248
800070be:	ea 1c 03 ef 	orh	r12,0x3ef
800070c2:	fe b0 d7 a9 	rcall	80002014 <smc_init>

  // initialize spi1: OLED, ADC, SD/MMC
  print_dbg("\r\n  init_spi1() ");
800070c6:	fe cc b1 c6 	sub	r12,pc,-20026
800070ca:	fe b0 de 77 	rcall	80002db8 <print_dbg>
  init_spi1();
800070ce:	fe b0 f7 09 	rcall	80005ee0 <init_spi1>
  // initialize PDCA controller

  print_dbg("\r\n  init_local_pdca() ");
800070d2:	fe cc b1 be 	sub	r12,pc,-20034
800070d6:	fe b0 de 71 	rcall	80002db8 <print_dbg>
  init_local_pdca();
800070da:	fe b0 f6 d7 	rcall	80005e88 <init_local_pdca>

  // initialize blackfin resources
  print_dbg("\r\n  init_bfin_resources() ");
800070de:	fe cc b1 b2 	sub	r12,pc,-20046
800070e2:	fe b0 de 6b 	rcall	80002db8 <print_dbg>
  init_bfin_resources();
800070e6:	fe b0 f6 9f 	rcall	80005e24 <init_bfin_resources>

  // initialize application timer
  print_dbg("\r\n  init_tc(tc) ");
800070ea:	fe cc b1 a2 	sub	r12,pc,-20062
800070ee:	fe b0 de 65 	rcall	80002db8 <print_dbg>
  init_tc(tc);
800070f2:	fe 7c 38 00 	mov	r12,-51200
800070f6:	fe b0 f7 77 	rcall	80005fe4 <init_tc>

  // initialize other GPIO
  print_dbg("\r\n  init_gpio() ");
800070fa:	fe cc b1 9e 	sub	r12,pc,-20066
800070fe:	fe b0 de 5d 	rcall	80002db8 <print_dbg>
  init_gpio();
80007102:	fe b0 f7 8b 	rcall	80006018 <init_gpio>

  // register interrupts
  print_dbg("\r\n  register_interrupts() ");
80007106:	fe cc b1 96 	sub	r12,pc,-20074
8000710a:	fe b0 de 57 	rcall	80002db8 <print_dbg>
  register_interrupts();
8000710e:	fe b0 f7 a5 	rcall	80006058 <register_interrupts>

  // initialize the OLED screen
  print_dbg("\r\n  init_oled() ");
80007112:	fe cc b1 86 	sub	r12,pc,-20090
80007116:	fe b0 de 51 	rcall	80002db8 <print_dbg>
  init_oled();
8000711a:	c1 fe       	rcall	80006d58 <init_oled>
8000711c:	fe cc b1 7c 	sub	r12,pc,-20100

  // enable interrupts
  print_dbg("\r\n  cpu_irq_enable() ");
80007120:	fe b0 de 4c 	rcall	80002db8 <print_dbg>
80007124:	d5 03       	csrf	0x10
  cpu_irq_enable();
80007126:	fe b0 f6 7b 	rcall	80005e1c <init_usb_host>

  // usb host controller
  init_usb_host();
8000712a:	fe cc b1 72 	sub	r12,pc,-20110
  // initialize usb classes
  print_dbg("\r\n init_monome ");
8000712e:	fe b0 de 45 	rcall	80002db8 <print_dbg>
80007132:	fe b0 f9 cf 	rcall	800064d0 <init_monome>
  init_monome();
80007136:	fe cc b1 6e 	sub	r12,pc,-20114

  // set up avr32 hardware and peripherals
  init_avr32();

 
  print_dbg("\r\n SRAM size: 0x");
8000713a:	fe b0 de 3f 	rcall	80002db8 <print_dbg>
8000713e:	30 1c       	mov	r12,1
  print_dbg_hex(smc_get_cs_size(1));
80007140:	fe b0 d7 64 	rcall	80002008 <smc_get_cs_size>
80007144:	fe b0 de 0c 	rcall	80002d5c <print_dbg_hex>
80007148:	d3 03       	ssrf	0x10


  cpu_irq_disable();
8000714a:	fe b0 f9 53 	rcall	800063f0 <sram_test>
  /// test the SRAM
  sram_test();
8000714e:	d5 03       	csrf	0x10

  cpu_irq_enable();
80007150:	fe b0 f9 0c 	rcall	80006368 <init_mem>

  //memory manager
  init_mem();
80007154:	fe cc b1 78 	sub	r12,pc,-20104
  print_dbg("\r\n init_mem");
80007158:	fe b0 de 30 	rcall	80002db8 <print_dbg>
8000715c:	fe cc b1 74 	sub	r12,pc,-20108

  // wait for sdcard
  
    print_dbg("\r\n SD check... ");
80007160:	fe b0 de 2c 	rcall	80002db8 <print_dbg>
80007164:	fe b0 e2 8e 	rcall	80003680 <sd_mmc_spi_mem_check>
    while (!sd_mmc_spi_mem_check()) {
80007168:	cf e0       	breq	80007164 <main+0xe4>
8000716a:	fe cc b1 72 	sub	r12,pc,-20110
      waitForCard++;
    }
    print_dbg("\r\nfound SD card. ");
8000716e:	fe b0 de 25 	rcall	80002db8 <print_dbg>
80007172:	fe cc b1 66 	sub	r12,pc,-20122


    // intialize the FAT filesystem
    print_dbg("\r\n init fat");
80007176:	fe b0 de 21 	rcall	80002db8 <print_dbg>
8000717a:	fe b0 f4 bb 	rcall	80005af0 <fat_init>
    fat_init();
8000717e:	fe cc b1 66 	sub	r12,pc,-20122
    // setup control logic
    print_dbg("\r\n init ctl");
80007182:	fe b0 de 1b 	rcall	80002db8 <print_dbg>
80007186:	d3 03       	ssrf	0x10
}

// control / network / logic init
static void init_ctl(void) {
  // disable interrupts
  cpu_irq_disable();
80007188:	fe b0 f3 f8 	rcall	80005978 <init_events>

  // intialize the event queue
  init_events();
8000718c:	fe cc b1 68 	sub	r12,pc,-20120
  print_dbg("\r\n init_events");
80007190:	fe b0 de 14 	rcall	80002db8 <print_dbg>
80007194:	fe cc b1 60 	sub	r12,pc,-20128

  // intialize encoders
  print_dbg("\r\n init_encoders");
80007198:	fe b0 de 10 	rcall	80002db8 <print_dbg>
8000719c:	fe b0 f4 74 	rcall	80005a84 <init_encoders>
  init_encoders();
800071a0:	fe cc b1 58 	sub	r12,pc,-20136

  // send ADC config
  print_dbg("\r\n init_adc");
800071a4:	fe b0 de 0a 	rcall	80002db8 <print_dbg>
800071a8:	fe b0 f0 f2 	rcall	8000538c <init_adc>
  init_adc();
800071ac:	fe cc b1 58 	sub	r12,pc,-20136

  // start timers
  print_dbg("\r\n init_sys_timers");
800071b0:	fe b0 de 04 	rcall	80002db8 <print_dbg>
800071b4:	fe b0 f1 f4 	rcall	8000559c <init_sys_timers>
  init_sys_timers();
800071b8:	d5 03       	csrf	0x10
  //  init_app_timers();

  // enable interrupts
  cpu_irq_enable();
800071ba:	fe b0 f5 cb 	rcall	80005d50 <init_flash>
    /* // initialize the application */
    /* app_init(); */
    /* print_dbg("\r\n init app"); */

    // initialize flash:
    firstrun = init_flash();
800071be:	e0 66 1c 5c 	mov	r6,7260
800071c2:	ac 8c       	st.b	r6[0x0],r12
800071c4:	fe cc b1 5c 	sub	r12,pc,-20132
    print_dbg("r\n init flash, firstrun: ");
800071c8:	fe b0 dd f8 	rcall	80002db8 <print_dbg>
800071cc:	0d 8c       	ld.ub	r12,r6[0x0]
    print_dbg_ulong(firstrun);
800071ce:	fe b0 dd ef 	rcall	80002dac <print_dbg_ulong>
800071d2:	fe b0 fd 5b 	rcall	80006c88 <screen_startup>

    screen_startup();
800071d6:	e0 a0 16 f7 	rcall	80009fc4 <files_search_dsp>

    // find and load dsp from sdcard
    files_search_dsp();
800071da:	fe cc b1 56 	sub	r12,pc,-20138


    print_dbg("\r\n starting event loop.\r\n");
800071de:	fe b0 dd ed 	rcall	80002db8 <print_dbg>
800071e2:	30 08       	mov	r8,0

    // dont do startup
    startup = 0;
800071e4:	31 c7       	mov	r7,28
800071e6:	30 09       	mov	r9,0
800071e8:	ae 88       	st.b	r7[0x0],r8
800071ea:	e0 6a d0 e7 	mov	r10,53479
800071ee:	ea 1a 27 56 	orh	r10,0x2756
800071f2:	e0 68 03 e8 	mov	r8,1000
800071f6:	30 0b       	mov	r11,0
800071f8:	e0 65 1c 60 	mov	r5,7264
800071fc:	e0 a0 17 58 	rcall	8000a0ac <__avr32_udiv64>
80007200:	fe c3 b4 18 	sub	r3,pc,-19432
80007204:	14 92       	mov	r2,r10
80007206:	30 c0       	mov	r0,12
80007208:	e0 64 0b 9c 	mov	r4,2972
8000720c:	fe c1 b3 bc 	sub	r1,pc,-19524
80007210:	e0 68 1c 60 	mov	r8,7264
80007214:	10 9c       	mov	r12,r8
// app event loop
static void check_events(void) {
  static event_t e;
  //  u8 launch = 0;
  //  print_dbg("\r\n checking events...");
  if( get_next_event(&e) ) {
80007216:	50 08       	stdsp	sp[0x0],r8
80007218:	fe b0 f3 ea 	rcall	800059ec <get_next_event>
8000721c:	40 08       	lddsp	r8,sp[0x0]
8000721e:	cf 90       	breq	80007210 <main+0x190>
80007220:	0f 8a       	ld.ub	r10,r7[0x0]
80007222:	30 09       	mov	r9,0
80007224:	f2 0a 18 00 	cp.b	r10,r9
  /* print_dbg("\r\n handling event, type: "); */
  /* print_dbg_hex(e.eventType); */
  /* print_dbg("\r\n , data: "); */
  /* print_dbg_hex(e.eventData); */

    if(startup) {
80007228:	c2 20       	breq	8000726c <main+0x1ec>
8000722a:	70 08       	ld.w	r8,r8[0x0]
8000722c:	21 18       	sub	r8,17
8000722e:	58 48       	cp.w	r8,4
      if( e.eventType == kEventSwitch0
80007230:	fe 9b ff f0 	brhi	80007210 <main+0x190>
80007234:	31 c8       	mov	r8,28
80007236:	fe cc b1 96 	sub	r12,pc,-20074
  	  || e.eventType == kEventSwitch1
  	  || e.eventType == kEventSwitch2
  	  || e.eventType == kEventSwitch3
  	  || e.eventType == kEventSwitch4
  	  ) {
  	startup = 0;
8000723a:	b0 89       	st.b	r8[0x0],r9
8000723c:	fe b0 dd be 	rcall	80002db8 <print_dbg>
  	print_dbg("\r\n key pressed, launching ");
80007240:	e1 b8 00 42 	mfsr	r8,0x108
80007244:	f0 02 00 0a 	add	r10,r8,r2
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80007248:	e1 b9 00 42 	mfsr	r9,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000724c:	14 38       	cp.w	r8,r10
8000724e:	e0 88 01 76 	brls	8000753a <main+0x4ba>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007252:	12 38       	cp.w	r8,r9
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80007254:	fe 98 ff fa 	brls	80007248 <main+0x1c8>
80007258:	12 3a       	cp.w	r10,r9
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000725a:	cf 72       	brcc	80007248 <main+0x1c8>
8000725c:	0d 89       	ld.ub	r9,r6[0x0]
8000725e:	30 08       	mov	r8,0
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007260:	f0 09 18 00 	cp.b	r9,r8
  	// return 1 if app completed firstrun tasks
	//  	launch = app_launch(firstrun);
  	delay_ms(10);
  	if( firstrun) {
80007264:	cd 60       	breq	80007210 <main+0x190>
80007266:	fe b0 f5 67 	rcall	80005d34 <flash_write_firstrun>
8000726a:	cd 3b       	rjmp	80007210 <main+0x190>
8000726c:	70 08       	ld.w	r8,r8[0x0]
  	  //	  if(launch) {
  	    // successfully launched on firstrun, so write magic number to flash
  	    flash_write_firstrun();
8000726e:	59 98       	cp.w	r8,25
80007270:	fe 9b ff d0 	brhi	80007210 <main+0x190>
	    //   flash_clear_firstrun();
  	    //	  }
  	}
      }
    } else {
      switch(e.eventType) {
80007274:	e6 08 03 2f 	ld.w	pc,r3[r8<<0x2]
80007278:	fe cc b1 bc 	sub	r12,pc,-20036
8000727c:	fe b0 dd 9e 	rcall	80002db8 <print_dbg>
      case  kEventSwitch1 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch1");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch2 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch2");
80007280:	e8 e8 00 00 	ld.d	r8,r4[0]
80007284:	10 9c       	mov	r12,r8
80007286:	fe b0 dd 6b 	rcall	80002d5c <print_dbg_hex>
8000728a:	fe cc b1 4e 	sub	r12,pc,-20146
8000728e:	fe b0 dd 95 	rcall	80002db8 <print_dbg>
80007292:	fe cc ad 3a 	sub	r12,pc,-21190
      case  kEventAdc2 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc2");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventAdc3 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc3");
80007296:	fe b0 dd 91 	rcall	80002db8 <print_dbg>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
8000729a:	6a 1c       	ld.w	r12,r5[0x4]
8000729c:	fe b0 dd 60 	rcall	80002d5c <print_dbg_hex>
800072a0:	cb 8b       	rjmp	80007210 <main+0x190>
800072a2:	fe cc b1 e6 	sub	r12,pc,-19994
800072a6:	fe b0 dd 89 	rcall	80002db8 <print_dbg>
      case  kEventSwitch0 : // fn
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch0");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch1 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch1");
800072aa:	e8 e8 00 00 	ld.d	r8,r4[0]
800072ae:	10 9c       	mov	r12,r8
800072b0:	fe b0 dd 56 	rcall	80002d5c <print_dbg_hex>
800072b4:	fe cc b1 8c 	sub	r12,pc,-20084
800072b8:	ce bb       	rjmp	8000728e <main+0x20e>
800072ba:	fe cc b1 fe 	sub	r12,pc,-19970
800072be:	fe b0 dd 7d 	rcall	80002db8 <print_dbg>
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder3");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(3, scale_knob_value(e.eventData));
	break;
      case  kEventSwitch0 : // fn
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch0");
800072c2:	e8 e8 00 00 	ld.d	r8,r4[0]
800072c6:	10 9c       	mov	r12,r8
800072c8:	fe b0 dd 4a 	rcall	80002d5c <print_dbg_hex>
800072cc:	fe cc b1 b8 	sub	r12,pc,-20040
800072d0:	cd fb       	rjmp	8000728e <main+0x20e>
800072d2:	fe cc b2 16 	sub	r12,pc,-19946
800072d6:	fe b0 dd 71 	rcall	80002db8 <print_dbg>
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder2");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(2, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder3  :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder3");
800072da:	e8 e8 00 00 	ld.d	r8,r4[0]
800072de:	10 9c       	mov	r12,r8
800072e0:	fe b0 dd 3e 	rcall	80002d5c <print_dbg_hex>
800072e4:	fe cc b1 e4 	sub	r12,pc,-19996
800072e8:	fe b0 dd 68 	rcall	80002db8 <print_dbg>
800072ec:	fe cc ad 94 	sub	r12,pc,-21100
800072f0:	fe b0 dd 64 	rcall	80002db8 <print_dbg>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
800072f4:	6a 1c       	ld.w	r12,r5[0x4]
800072f6:	fe b0 dd 33 	rcall	80002d5c <print_dbg_hex>
800072fa:	6a 19       	ld.w	r9,r5[0x4]
800072fc:	12 98       	mov	r8,r9
800072fe:	5c 48       	abs	r8
80007300:	59 88       	cp.w	r8,24
	dac_inc(3, scale_knob_value(e.eventData));
80007302:	f9 b8 02 17 	movhs	r8,23
    0x05FE4435,
    0x0DD93CDC,
    0x1FFFFFFD,
  };

  s32 vabs = BIT_ABS(val);
80007306:	e2 08 03 2b 	ld.w	r11,r1[r8<<0x2]
  s32 ret = val;
   if(vabs > kNumKnobScales_1) {
8000730a:	58 09       	cp.w	r9,0
8000730c:	c0 34       	brge	80007312 <main+0x292>
     vabs = kNumKnobScales_1;
   }
   ret = knobScale[vabs];
8000730e:	5c 4b       	abs	r11
80007310:	5c 3b       	neg	r11
   if(val < 0) {
80007312:	30 3c       	mov	r12,3
80007314:	c9 4e       	rcall	8000703c <dac_inc>
     ret = BIT_NEG_ABS(ret);
80007316:	c7 db       	rjmp	80007210 <main+0x190>
80007318:	fe cc b2 5c 	sub	r12,pc,-19876
	dac_inc(2, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder3  :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder3");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(3, scale_knob_value(e.eventData));
8000731c:	fe b0 dd 4e 	rcall	80002db8 <print_dbg>
80007320:	e8 e8 00 00 	ld.d	r8,r4[0]
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder1");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(1, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder2  :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder2");
80007324:	10 9c       	mov	r12,r8
80007326:	fe b0 dd 1b 	rcall	80002d5c <print_dbg_hex>
8000732a:	fe cc b2 3e 	sub	r12,pc,-19906
8000732e:	fe b0 dd 45 	rcall	80002db8 <print_dbg>
80007332:	fe cc ad da 	sub	r12,pc,-21030
80007336:	fe b0 dd 41 	rcall	80002db8 <print_dbg>
8000733a:	6a 1c       	ld.w	r12,r5[0x4]
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
8000733c:	fe b0 dd 10 	rcall	80002d5c <print_dbg_hex>
80007340:	6a 19       	ld.w	r9,r5[0x4]
80007342:	12 98       	mov	r8,r9
80007344:	5c 48       	abs	r8
80007346:	59 88       	cp.w	r8,24
80007348:	f9 b8 02 17 	movhs	r8,23
    0x05FE4435,
    0x0DD93CDC,
    0x1FFFFFFD,
  };

  s32 vabs = BIT_ABS(val);
8000734c:	e2 08 03 2b 	ld.w	r11,r1[r8<<0x2]
  s32 ret = val;
   if(vabs > kNumKnobScales_1) {
80007350:	58 09       	cp.w	r9,0
80007352:	c0 34       	brge	80007358 <main+0x2d8>
80007354:	5c 4b       	abs	r11
     vabs = kNumKnobScales_1;
   }
   ret = knobScale[vabs];
80007356:	5c 3b       	neg	r11
80007358:	30 2c       	mov	r12,2
   if(val < 0) {
8000735a:	c7 1e       	rcall	8000703c <dac_inc>
8000735c:	c5 ab       	rjmp	80007210 <main+0x190>
     ret = BIT_NEG_ABS(ret);
8000735e:	fe cc b2 a2 	sub	r12,pc,-19806
	dac_inc(1, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder2  :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder2");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(2, scale_knob_value(e.eventData));
80007362:	fe b0 dd 2b 	rcall	80002db8 <print_dbg>
80007366:	e8 e8 00 00 	ld.d	r8,r4[0]
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder0");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(0, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder1 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder1");
8000736a:	10 9c       	mov	r12,r8
8000736c:	fe b0 dc f8 	rcall	80002d5c <print_dbg_hex>
80007370:	fe cc b2 98 	sub	r12,pc,-19816
80007374:	fe b0 dd 22 	rcall	80002db8 <print_dbg>
80007378:	fe cc ae 20 	sub	r12,pc,-20960
8000737c:	fe b0 dd 1e 	rcall	80002db8 <print_dbg>
80007380:	6a 1c       	ld.w	r12,r5[0x4]
80007382:	fe b0 dc ed 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
80007386:	6a 19       	ld.w	r9,r5[0x4]
80007388:	12 98       	mov	r8,r9
8000738a:	5c 48       	abs	r8
8000738c:	59 88       	cp.w	r8,24
8000738e:	f9 b8 02 17 	movhs	r8,23
	dac_inc(1, scale_knob_value(e.eventData));
80007392:	e2 08 03 2b 	ld.w	r11,r1[r8<<0x2]
    0x05FE4435,
    0x0DD93CDC,
    0x1FFFFFFD,
  };

  s32 vabs = BIT_ABS(val);
80007396:	58 09       	cp.w	r9,0
  s32 ret = val;
   if(vabs > kNumKnobScales_1) {
80007398:	c0 34       	brge	8000739e <main+0x31e>
8000739a:	5c 4b       	abs	r11
8000739c:	5c 3b       	neg	r11
     vabs = kNumKnobScales_1;
   }
   ret = knobScale[vabs];
8000739e:	30 1c       	mov	r12,1
800073a0:	c4 ee       	rcall	8000703c <dac_inc>
   if(val < 0) {
800073a2:	c3 7b       	rjmp	80007210 <main+0x190>
800073a4:	fe cc b2 e8 	sub	r12,pc,-19736
     ret = BIT_NEG_ABS(ret);
800073a8:	fe b0 dd 08 	rcall	80002db8 <print_dbg>
	dac_inc(0, scale_knob_value(e.eventData));
	break;
      case  kEventEncoder1 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder1");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(1, scale_knob_value(e.eventData));
800073ac:	e8 e8 00 00 	ld.d	r8,r4[0]
800073b0:	10 9c       	mov	r12,r8
      case kEventMidiConnect :
	break;
      case kEventMidiDisconnect :
	break;
      case  kEventEncoder0 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder0");
800073b2:	fe b0 dc d5 	rcall	80002d5c <print_dbg_hex>
800073b6:	fe cc b2 f2 	sub	r12,pc,-19726
800073ba:	fe b0 dc ff 	rcall	80002db8 <print_dbg>
800073be:	fe cc ae 66 	sub	r12,pc,-20890
800073c2:	fe b0 dc fb 	rcall	80002db8 <print_dbg>
800073c6:	6a 1c       	ld.w	r12,r5[0x4]
800073c8:	fe b0 dc ca 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
800073cc:	6a 19       	ld.w	r9,r5[0x4]
800073ce:	12 98       	mov	r8,r9
800073d0:	5c 48       	abs	r8
800073d2:	59 88       	cp.w	r8,24
800073d4:	f9 b8 02 17 	movhs	r8,23
800073d8:	e2 08 03 2b 	ld.w	r11,r1[r8<<0x2]
    0x05FE4435,
    0x0DD93CDC,
    0x1FFFFFFD,
  };

  s32 vabs = BIT_ABS(val);
800073dc:	58 09       	cp.w	r9,0
800073de:	c0 34       	brge	800073e4 <main+0x364>
  s32 ret = val;
   if(vabs > kNumKnobScales_1) {
800073e0:	5c 4b       	abs	r11
800073e2:	5c 3b       	neg	r11
800073e4:	30 0c       	mov	r12,0
     vabs = kNumKnobScales_1;
   }
   ret = knobScale[vabs];
800073e6:	c2 be       	rcall	8000703c <dac_inc>
800073e8:	c1 4b       	rjmp	80007210 <main+0x190>
   if(val < 0) {
800073ea:	fe cc b3 2e 	sub	r12,pc,-19666
     ret = BIT_NEG_ABS(ret);
800073ee:	fe b0 dc e5 	rcall	80002db8 <print_dbg>
      case kEventMidiDisconnect :
	break;
      case  kEventEncoder0 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventEncoder0");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	dac_inc(0, scale_knob_value(e.eventData));
800073f2:	e8 e8 00 00 	ld.d	r8,r4[0]
800073f6:	10 9c       	mov	r12,r8
800073f8:	fe b0 dc b2 	rcall	80002d5c <print_dbg_hex>
      case  kEventSwitch2 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch2");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch3 :
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch3");
800073fc:	fe cc b2 ac 	sub	r12,pc,-19796
80007400:	c4 7b       	rjmp	8000728e <main+0x20e>
80007402:	fe cc b3 46 	sub	r12,pc,-19642
80007406:	fe b0 dc d9 	rcall	80002db8 <print_dbg>
8000740a:	e8 e8 00 00 	ld.d	r8,r4[0]
8000740e:	10 9c       	mov	r12,r8
80007410:	fe b0 dc a6 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch4 : // mode
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch4");
80007414:	fe cc b2 b0 	sub	r12,pc,-19792
80007418:	c3 bb       	rjmp	8000728e <main+0x20e>
8000741a:	fe cc b3 5e 	sub	r12,pc,-19618
8000741e:	fe b0 dc cd 	rcall	80002db8 <print_dbg>
80007422:	e8 e8 00 00 	ld.d	r8,r4[0]
80007426:	10 9c       	mov	r12,r8
80007428:	fe b0 dc 9a 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch5 : // power
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch5");
8000742c:	fe cc b2 b4 	sub	r12,pc,-19788
80007430:	c2 fb       	rjmp	8000728e <main+0x20e>
80007432:	fe cc b3 76 	sub	r12,pc,-19594
80007436:	fe b0 dc c1 	rcall	80002db8 <print_dbg>
8000743a:	e8 e8 00 00 	ld.d	r8,r4[0]
8000743e:	10 9c       	mov	r12,r8
80007440:	fe b0 dc 8e 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch6 :  // foot
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch6");
80007444:	fe cc b2 b8 	sub	r12,pc,-19784
80007448:	c2 3b       	rjmp	8000728e <main+0x20e>
8000744a:	fe cc b3 8e 	sub	r12,pc,-19570
8000744e:	fe b0 dc b5 	rcall	80002db8 <print_dbg>
80007452:	e8 e8 00 00 	ld.d	r8,r4[0]
80007456:	10 9c       	mov	r12,r8
80007458:	fe b0 dc 82 	rcall	80002d5c <print_dbg_hex>
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventSwitch7 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch7");
8000745c:	fe cc b2 bc 	sub	r12,pc,-19780
80007460:	c1 7b       	rjmp	8000728e <main+0x20e>
80007462:	e0 a0 03 0f 	rcall	80007a80 <ftdi_setup>
80007466:	fe 9f fe d5 	bral	80007210 <main+0x190>
8000746a:	fe b0 f8 79 	rcall	8000655c <monome_grid_refresh>
8000746e:	fe 9f fe d1 	bral	80007210 <main+0x190>
  	break;
  	//--------------------------------------
      case kEventFtdiConnect:
  	// perform setup tasks for new ftdi device connection.
  	// won't work if called from an interrupt.
  	ftdi_setup();
80007472:	60 08       	ld.w	r8,r0[0x0]
80007474:	5d 18       	icall	r8
80007476:	fe 9f fe cd 	bral	80007210 <main+0x190>
  	// poll monome serial input and spawn relevant events
  	monome_read_serial();
  	break;
      case kEventMonomeRefresh :
  	// refresh monome device from led state buffer
  	monome_grid_refresh();
8000747a:	fe cc b3 be 	sub	r12,pc,-19522
8000747e:	fe b0 dc 9d 	rcall	80002db8 <print_dbg>
	/// draw ADC values
	
  	break;
      case kEventMonomePoll :
  	// poll monome serial input and spawn relevant events
  	monome_read_serial();
80007482:	e8 e8 00 00 	ld.d	r8,r4[0]
80007486:	10 9c       	mov	r12,r8
      case  kEventAdc3 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc3");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case kEventMonomeGridKey:
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventMonomeGridKey");
80007488:	fe b0 dc 6a 	rcall	80002d5c <print_dbg_hex>
8000748c:	fe cc b2 98 	sub	r12,pc,-19816
80007490:	fe b0 dc 94 	rcall	80002db8 <print_dbg>
80007494:	fe cc af 3c 	sub	r12,pc,-20676
80007498:	fe b0 dc 90 	rcall	80002db8 <print_dbg>
8000749c:	6a 1c       	ld.w	r12,r5[0x4]
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
8000749e:	fe b0 dc 5f 	rcall	80002d5c <print_dbg_hex>
800074a2:	fa c9 ff fb 	sub	r9,sp,-5
800074a6:	fa ca ff fa 	sub	r10,sp,-6
static void check_events(void);

static void handle_monome_grid_key(u32 data) {
  u8 x, y, z;
  /// FIXME: this stuff should really be abstracted
  monome_grid_key_parse_event_data(data, &x, &y, &z);
800074aa:	fa cb ff f9 	sub	r11,sp,-7
800074ae:	6a 1c       	ld.w	r12,r5[0x4]
800074b0:	fe b0 f8 1a 	rcall	800064e4 <monome_grid_key_parse_event_data>
800074b4:	1b e9       	ld.ub	r9,sp[0x6]
800074b6:	1b f8       	ld.ub	r8,sp[0x7]
800074b8:	12 9b       	mov	r11,r9
800074ba:	10 9c       	mov	r12,r8
  monomeLedBuffer[x | (y << 4)] = z;
800074bc:	e0 6a 30 c4 	mov	r10,12484
  monome_calc_quadrant_flag(x, y);
800074c0:	f1 e9 10 48 	or	r8,r8,r9<<0x4

static void handle_monome_grid_key(u32 data) {
  u8 x, y, z;
  /// FIXME: this stuff should really be abstracted
  monome_grid_key_parse_event_data(data, &x, &y, &z);
  monomeLedBuffer[x | (y << 4)] = z;
800074c4:	1b d9       	ld.ub	r9,sp[0x5]
800074c6:	f4 08 0b 09 	st.b	r10[r8],r9
800074ca:	fe b0 f8 19 	rcall	800064fc <monome_calc_quadrant_flag>
800074ce:	fe 9f fe a1 	bral	80007210 <main+0x190>
  monome_calc_quadrant_flag(x, y);
800074d2:	fe cc b4 16 	sub	r12,pc,-19434
800074d6:	fe b0 dc 71 	rcall	80002db8 <print_dbg>
      case  kEventAdc2 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc2");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventAdc3 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc3");
800074da:	e8 e8 00 00 	ld.d	r8,r4[0]
800074de:	10 9c       	mov	r12,r8
800074e0:	fe b0 dc 3e 	rcall	80002d5c <print_dbg_hex>
800074e4:	fe cc b3 00 	sub	r12,pc,-19712
800074e8:	fe 9f fe d3 	bral	8000728e <main+0x20e>
800074ec:	fe cc b4 30 	sub	r12,pc,-19408
      case  kEventAdc1 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc1");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventAdc2 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc2");
800074f0:	fe b0 dc 64 	rcall	80002db8 <print_dbg>
800074f4:	e8 e8 00 00 	ld.d	r8,r4[0]
800074f8:	10 9c       	mov	r12,r8
800074fa:	fe b0 dc 31 	rcall	80002d5c <print_dbg_hex>
800074fe:	fe cc b3 2a 	sub	r12,pc,-19670
80007502:	fe 9f fe c6 	bral	8000728e <main+0x20e>
      case  kEventAdc0 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc0");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventAdc1 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc1");
80007506:	fe cc b4 4a 	sub	r12,pc,-19382
8000750a:	fe b0 dc 57 	rcall	80002db8 <print_dbg>
8000750e:	e8 e8 00 00 	ld.d	r8,r4[0]
80007512:	10 9c       	mov	r12,r8
80007514:	fe b0 dc 24 	rcall	80002d5c <print_dbg_hex>
80007518:	fe cc b3 54 	sub	r12,pc,-19628
      case  kEventSwitch7 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventSwitch7");
	print_dbg(" : 0x"); print_dbg_hex((u32) e.eventData);
	break;
      case  kEventAdc0 : 
	print_dbg("\r\n ( 0x"); print_dbg_hex((u32)tcTicks); print_dbg(" )  kEventAdc0");
8000751c:	fe 9f fe b9 	bral	8000728e <main+0x20e>
80007520:	fe cc b4 64 	sub	r12,pc,-19356
80007524:	fe b0 dc 4a 	rcall	80002db8 <print_dbg>
80007528:	e8 e8 00 00 	ld.d	r8,r4[0]
8000752c:	10 9c       	mov	r12,r8
8000752e:	fe b0 dc 17 	rcall	80002d5c <print_dbg_hex>
80007532:	fe cc b3 7e 	sub	r12,pc,-19586
80007536:	fe 9f fe ac 	bral	8000728e <main+0x20e>
8000753a:	12 38       	cp.w	r8,r9
8000753c:	fe 9b fe 90 	brhi	8000725c <main+0x1dc>
80007540:	fe 9f fe 8c 	bral	80007258 <main+0x1d8>

80007544 <usb_mode_change>:
#include "usb.h"

// usb mode change callback
void usb_mode_change(bool b_host_mode) {
  // print_dbg("\r\n mode change (ignore) ");
}
80007544:	5e fc       	retal	r12

80007546 <usb_vbus_change>:
 
// usb Vbus change callback
void usb_vbus_change(bool b_vbus_present) {
  // print_dbg("\r\n usb vbus change, new status: ");
  // print_dbg_ulong(b_vbus_present);
}
80007546:	5e fc       	retal	r12

80007548 <usb_vbus_error>:

// usb vbus error callback
void usb_vbus_error(void) {
  // print_dbg("\r\n usb vbus error: ");

}
80007548:	5e fc       	retal	r12

8000754a <usb_connection>:
void usb_connection(uhc_device_t *dev, bool b_present) {
    // print_dbg("\r\n usb device connection: ");
    // print_dbg_hex(dev);
    // print_dbg(" , ");
    // print_dbg_ulong(b_present);
}
8000754a:	5e fc       	retal	r12

8000754c <usb_wakeup>:

// usb wakeup callback
void usb_wakeup(void) {
    // print_dbg("\r\n usb wakeup");
}
8000754c:	5e fc       	retal	r12

8000754e <usb_sof>:

// usb start-of-frame callback
void usb_sof(void) {
  //    // print_dbg("\r\n usb sof");
}
8000754e:	5e fc       	retal	r12

80007550 <usb_enum>:
  // print_dbg("\r\n usb enumerated: ");
  // print_dbg_hex(dev);
  // print_dbg(" , ");
  // print_dbg_hex(status);

}
80007550:	5e fc       	retal	r12
80007552:	d7 03       	nop

80007554 <uhi_hid_gamepad_uninstall>:
  //uhi_hid_gamepad_dev.report_btn_prev = 0;
  uhi_hid_gamepad_start_trans_report(dev->address);
  UHI_HID_GAMEPAD_CHANGE(dev, true);
}

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
80007554:	d4 01       	pushm	lr
  if (uhi_hid_gamepad_dev.dev != dev) {
80007556:	e0 68 1c 78 	mov	r8,7288
8000755a:	70 09       	ld.w	r9,r8[0x0]
8000755c:	18 39       	cp.w	r9,r12
8000755e:	c0 20       	breq	80007562 <uhi_hid_gamepad_uninstall+0xe>
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
80007560:	d8 02       	popm	pc
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
80007562:	30 09       	mov	r9,0

void uhi_hid_gamepad_uninstall(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
    return; // Device not enabled in this interface
  }
  uhi_hid_gamepad_dev.dev = NULL;
80007564:	70 2c       	ld.w	r12,r8[0x8]
  Assert(uhi_hid_gamepad_dev.report!=NULL);
  free(uhi_hid_gamepad_dev.report);
80007566:	91 09       	st.w	r8[0x0],r9
80007568:	e0 a0 16 ec 	rcall	8000a340 <free>
8000756c:	d8 02       	popm	pc
8000756e:	d7 03       	nop

80007570 <uhi_hid_gamepad_enable>:
80007570:	d4 01       	pushm	lr
80007572:	e0 69 1c 78 	mov	r9,7288
  //////////
  ////////////


void uhi_hid_gamepad_enable(uhc_device_t* dev) {
  if (uhi_hid_gamepad_dev.dev != dev) {
80007576:	72 08       	ld.w	r8,r9[0x0]
80007578:	18 38       	cp.w	r8,r12
8000757a:	c0 20       	breq	8000757e <uhi_hid_gamepad_enable+0xe>
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
8000757c:	d8 02       	popm	pc
8000757e:	fe ca ff e2 	sub	r10,pc,-30
80007582:	13 cb       	ld.ub	r11,r9[0x4]
80007584:	1a da       	st.w	--sp,r10
80007586:	30 0a       	mov	r10,0
80007588:	1a da       	st.w	--sp,r10
8000758a:	30 1a       	mov	r10,1
8000758c:	f1 3c 00 12 	ld.ub	r12,r8[18]
80007590:	13 d8       	ld.ub	r8,r9[0x5]
80007592:	72 29       	ld.w	r9,r9[0x8]
80007594:	fe b0 e3 22 	rcall	80003bd8 <uhd_ep_run>
80007598:	2f ed       	sub	sp,-8
8000759a:	d8 02       	popm	pc

8000759c <uhi_hid_gamepad_report_reception>:
8000759c:	eb cd 40 e0 	pushm	r5-r7,lr
800075a0:	58 0a       	cp.w	r10,0
800075a2:	5f 18       	srne	r8

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
800075a4:	58 39       	cp.w	r9,3
800075a6:	5f 89       	srls	r9
static void uhi_hid_gamepad_report_reception(
					   usb_add_t add,
					   usb_ep_t ep,
					   uhd_trans_status_t status,
					   iram_size_t nb_transfered)
{
800075a8:	18 96       	mov	r6,r12

  int i;

  UNUSED(ep);

  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
800075aa:	f3 e8 10 08 	or	r8,r9,r8
800075ae:	c0 30       	breq	800075b4 <uhi_hid_gamepad_report_reception+0x18>
800075b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
800075b4:	fe cc b3 a8 	sub	r12,pc,-19544
800075b8:	fe b0 dc 00 	rcall	80002db8 <print_dbg>
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
800075bc:	e0 67 1c 78 	mov	r7,7288
800075c0:	0f d8       	ld.ub	r8,r7[0x5]
800075c2:	58 08       	cp.w	r8,0
    print_dbg(" ");
800075c4:	c1 00       	breq	800075e4 <uhi_hid_gamepad_report_reception+0x48>
800075c6:	30 05       	mov	r5,0
800075c8:	fe cc b6 14 	sub	r12,pc,-18924
    print_dbg_hex((unsigned long int) uhi_hid_gamepad_dev.report[i]);
800075cc:	fe b0 db f6 	rcall	80002db8 <print_dbg>
800075d0:	6e 28       	ld.w	r8,r7[0x8]
800075d2:	f0 05 07 0c 	ld.ub	r12,r8[r5]
  if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
    return; // HID gamepad transfer aborted
  }

  print_dbg("\r\n gamepad_report: ");
  for (i=0; i<uhi_hid_gamepad_dev.report_size; i++) {
800075d6:	fe b0 db c3 	rcall	80002d5c <print_dbg_hex>
800075da:	2f f5       	sub	r5,-1
800075dc:	0f d8       	ld.ub	r8,r7[0x5]
 *
 * \param add   USB address to use
 */
static void uhi_hid_gamepad_start_trans_report(usb_add_t add) {
  // Start transfer on interrupt endpoint IN
  uhd_ep_run(add, uhi_hid_gamepad_dev.ep_in, true, uhi_hid_gamepad_dev.report,
800075de:	0a 38       	cp.w	r8,r5
800075e0:	fe 99 ff f4 	brgt	800075c8 <uhi_hid_gamepad_report_reception+0x2c>
800075e4:	fe c9 00 48 	sub	r9,pc,72
800075e8:	0f cb       	ld.ub	r11,r7[0x4]
800075ea:	1a d9       	st.w	--sp,r9
800075ec:	30 09       	mov	r9,0
800075ee:	0c 9c       	mov	r12,r6
800075f0:	1a d9       	st.w	--sp,r9
800075f2:	30 1a       	mov	r10,1
800075f4:	6e 29       	ld.w	r9,r7[0x8]
800075f6:	fe b0 e2 f1 	rcall	80003bd8 <uhd_ep_run>
800075fa:	2f ed       	sub	sp,-8
800075fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007600 <uhi_hid_gamepad_install>:
80007600:	d4 21       	pushm	r4-r7,lr
80007602:	e0 66 1c 78 	mov	r6,7288
80007606:	18 95       	mov	r5,r12
80007608:	6c 08       	ld.w	r8,r6[0x0]
8000760a:	58 08       	cp.w	r8,0
8000760c:	c0 30       	breq	80007612 <uhi_hid_gamepad_install+0x12>
8000760e:	30 5c       	mov	r12,5
80007610:	d8 22       	popm	r4-r7,pc
80007612:	78 67       	ld.w	r7,r12[0x18]
  usb_iface_desc_t *ptr_iface;

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
80007614:	0f a4       	ld.ub	r4,r7[0x2]
80007616:	0f b9       	ld.ub	r9,r7[0x3]
80007618:	f3 e4 10 84 	or	r4,r9,r4<<0x8
8000761c:	5c c4       	swap.bh	r4
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
8000761e:	5c 84       	casts.h	r4

  if (uhi_hid_gamepad_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
80007620:	c7 10       	breq	80007702 <uhi_hid_gamepad_install+0x102>
80007622:	10 9a       	mov	r10,r8
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
80007624:	c0 a8       	rjmp	80007638 <uhi_hid_gamepad_install+0x38>
80007626:	30 59       	mov	r9,5
80007628:	f2 08 18 00 	cp.b	r8,r9
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8000762c:	c6 10       	breq	800076ee <uhi_hid_gamepad_install+0xee>
8000762e:	0f 88       	ld.ub	r8,r7[0x0]
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80007630:	10 14       	sub	r4,r8
    default:
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
80007632:	10 07       	add	r7,r8
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  //  return UHC_ENUM_UNSUPPORTED; // No interface supported

  while(conf_desc_lgt) {
80007634:	5c 84       	casts.h	r4
    switch (ptr_iface->bDescriptorType) {
80007636:	c6 60       	breq	80007702 <uhi_hid_gamepad_install+0x102>
80007638:	0f 98       	ld.ub	r8,r7[0x1]
8000763a:	30 49       	mov	r9,4
8000763c:	f2 08 18 00 	cp.b	r8,r9
    case USB_DT_INTERFACE:

      /////////////////
      ///////////////  
      //#if 1
      print_dbg("\r\n\r\n");
80007640:	cf 31       	brne	80007626 <uhi_hid_gamepad_install+0x26>
80007642:	fe cc c5 a2 	sub	r12,pc,-14942
      print_dbg("\r\n iface_desc -> bLength : ");
80007646:	fe b0 db b9 	rcall	80002db8 <print_dbg>
8000764a:	fe cc b4 2a 	sub	r12,pc,-19414
      print_dbg_hex(ptr_iface->bLength);
8000764e:	fe b0 db b5 	rcall	80002db8 <print_dbg>
      print_dbg("\r\n iface_desc -> bDescriptorType : ");
80007652:	0f 8c       	ld.ub	r12,r7[0x0]
80007654:	fe b0 db 84 	rcall	80002d5c <print_dbg_hex>
      print_dbg_hex(ptr_iface->bDescriptorType);
80007658:	fe cc b4 1c 	sub	r12,pc,-19428
8000765c:	fe b0 db ae 	rcall	80002db8 <print_dbg>
      print_dbg("\r\n iface_desc -> bInterfaceNumber : ");
80007660:	0f 9c       	ld.ub	r12,r7[0x1]
80007662:	fe b0 db 7d 	rcall	80002d5c <print_dbg_hex>
      print_dbg_hex(ptr_iface->bInterfaceNumber);
80007666:	fe cc b4 06 	sub	r12,pc,-19450
      print_dbg("\r\n iface_desc -> bAlternateSetting : ");
8000766a:	fe b0 db a7 	rcall	80002db8 <print_dbg>
8000766e:	0f ac       	ld.ub	r12,r7[0x2]
      print_dbg_hex(ptr_iface->bAlternateSetting);
80007670:	fe b0 db 76 	rcall	80002d5c <print_dbg_hex>
80007674:	fe cc b3 ec 	sub	r12,pc,-19476
      print_dbg("\r\n iface_desc -> bNumEndpoints : ");
80007678:	fe b0 db a0 	rcall	80002db8 <print_dbg>
      print_dbg_hex(ptr_iface->bNumEndpoints);
8000767c:	0f bc       	ld.ub	r12,r7[0x3]
8000767e:	fe b0 db 6f 	rcall	80002d5c <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceClass : ");
80007682:	fe cc b3 d2 	sub	r12,pc,-19502
80007686:	fe b0 db 99 	rcall	80002db8 <print_dbg>
      print_dbg_hex(ptr_iface->bInterfaceClass);
8000768a:	0f cc       	ld.ub	r12,r7[0x4]
8000768c:	fe b0 db 68 	rcall	80002d5c <print_dbg_hex>
      print_dbg("\r\n iface_desc -> bInterfaceSubClass : ");
80007690:	fe cc b3 bc 	sub	r12,pc,-19524
      print_dbg_hex(ptr_iface->bInterfaceSubClass);
80007694:	fe b0 db 92 	rcall	80002db8 <print_dbg>
80007698:	0f dc       	ld.ub	r12,r7[0x5]
      print_dbg("\r\n iface_desc -> bInterfaceProtocol : ");
8000769a:	fe b0 db 61 	rcall	80002d5c <print_dbg_hex>
8000769e:	fe cc b3 a6 	sub	r12,pc,-19546
      print_dbg_hex(ptr_iface->bInterfaceProtocol);
800076a2:	fe b0 db 8b 	rcall	80002db8 <print_dbg>
      print_dbg("\r\n iface_desc -> iInterface : ");
800076a6:	0f ec       	ld.ub	r12,r7[0x6]
800076a8:	fe b0 db 5a 	rcall	80002d5c <print_dbg_hex>
      print_dbg_hex(ptr_iface->iInterface);
800076ac:	fe cc b3 8c 	sub	r12,pc,-19572
800076b0:	fe b0 db 84 	rcall	80002db8 <print_dbg>
      print_dbg("\r\n\r\n");
800076b4:	0f fc       	ld.ub	r12,r7[0x7]
800076b6:	fe b0 db 53 	rcall	80002d5c <print_dbg_hex>
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
800076ba:	fe cc b3 72 	sub	r12,pc,-19598
800076be:	fe b0 db 7d 	rcall	80002db8 <print_dbg>
800076c2:	ef 3c 00 08 	ld.ub	r12,r7[8]
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
800076c6:	fe b0 db 4b 	rcall	80002d5c <print_dbg_hex>
      print_dbg_hex(ptr_iface->iInterface);
      print_dbg("\r\n\r\n");
      ////////////
      /////////
      if ((ptr_iface->bInterfaceClass   == HID_CLASS)
	  && (ptr_iface->bInterfaceProtocol == HID_PROTOCOL_GENERIC) ) {
800076ca:	fe cc c6 2a 	sub	r12,pc,-14806
800076ce:	fe b0 db 75 	rcall	80002db8 <print_dbg>
800076d2:	0f d9       	ld.ub	r9,r7[0x5]
800076d4:	30 38       	mov	r8,3
      }
      break;

    case USB_DT_ENDPOINT:
      //  Allocation of the endpoint
      if (!b_iface_supported) {
800076d6:	f0 09 18 00 	cp.b	r9,r8
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
800076da:	c0 30       	breq	800076e0 <uhi_hid_gamepad_install+0xe0>
800076dc:	30 0a       	mov	r10,0
800076de:	ca 8b       	rjmp	8000762e <uhi_hid_gamepad_install+0x2e>
800076e0:	0f f9       	ld.ub	r9,r7[0x7]
800076e2:	30 08       	mov	r8,0
800076e4:	f0 09 18 00 	cp.b	r9,r8
800076e8:	cf a1       	brne	800076dc <uhi_hid_gamepad_install+0xdc>
      // Ignore descriptor
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
800076ea:	30 1a       	mov	r10,1
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
      }
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
800076ec:	ca 1b       	rjmp	8000762e <uhi_hid_gamepad_install+0x2e>
800076ee:	58 0a       	cp.w	r10,0
      uhi_hid_gamepad_dev.report_size =
800076f0:	c9 f0       	breq	8000762e <uhi_hid_gamepad_install+0x2e>
800076f2:	0e 9b       	mov	r11,r7
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
800076f4:	eb 3c 00 12 	ld.ub	r12,r5[18]
800076f8:	fe b0 e3 ee 	rcall	80003ed4 <uhd_ep_alloc>
      if (uhi_hid_gamepad_dev.report == NULL) {
	Assert(false);
	return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
      }
      uhi_hid_gamepad_dev.dev = dev;
800076fc:	c0 41       	brne	80007704 <uhi_hid_gamepad_install+0x104>
800076fe:	30 4c       	mov	r12,4
80007700:	d8 22       	popm	r4-r7,pc
      // All endpoints of all interfaces supported allocated
      return UHC_ENUM_SUCCESS;
80007702:	da 2a       	popm	r4-r7,pc,r12=1
      Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
      uhi_hid_gamepad_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
      uhi_hid_gamepad_dev.report_size =
	le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
      uhi_hid_gamepad_dev.report = malloc(uhi_hid_gamepad_dev.report_size);
      if (uhi_hid_gamepad_dev.report == NULL) {
80007704:	0f a8       	ld.ub	r8,r7[0x2]
80007706:	ac c8       	st.b	r6[0x4],r8
80007708:	0f cc       	ld.ub	r12,r7[0x4]
8000770a:	ac dc       	st.b	r6[0x5],r12
8000770c:	e0 a0 16 22 	rcall	8000a350 <malloc>
80007710:	8d 2c       	st.w	r6[0x8],r12
80007712:	c0 60       	breq	8000771e <uhi_hid_gamepad_install+0x11e>
80007714:	e0 68 1c 78 	mov	r8,7288
80007718:	30 0c       	mov	r12,0
8000771a:	91 05       	st.w	r8[0x0],r5
8000771c:	d8 22       	popm	r4-r7,pc
8000771e:	30 6c       	mov	r12,6
80007720:	d8 22       	popm	r4-r7,pc
80007722:	d7 03       	nop

80007724 <ctl_req_end>:
		uhd_trans_status_t status,
		uint16_t payload_trans) {
  // last transfer ok?
  //  print_dbg("\r\n ctl request end, status: ");
  //  print_dbg_hex((u32)status);
  ctlReadBusy = 0;
80007724:	30 09       	mov	r9,0
80007726:	e0 68 1c 8c 	mov	r8,7308
}
8000772a:	b0 89       	st.b	r8[0x0],r9
8000772c:	5e fc       	retal	r12
8000772e:	d7 03       	nop

80007730 <send_ctl_request>:

// send control request
static u8 send_ctl_request(u8 reqtype, u8 reqnum, 
			   u8* data, u16 size,
			     u16 index, u16 val, 
			     uhd_callback_setup_end_t callbackEnd) {
80007730:	eb cd 40 10 	pushm	r4,lr
80007734:	20 2d       	sub	sp,8
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
80007736:	ba 28       	st.h	sp[0x4],r8

// send control request
static u8 send_ctl_request(u8 reqtype, u8 reqnum, 
			   u8* data, u16 size,
			     u16 index, u16 val, 
			     uhd_callback_setup_end_t callbackEnd) {
80007738:	fa c4 ff f0 	sub	r4,sp,-16
8000773c:	68 18       	ld.w	r8,r4[0x4]
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
8000773e:	ba 9b       	st.b	sp[0x1],r11
 
  /* if (uhi_ftdi_dev.dev != dev) { */
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
80007740:	ba 8c       	st.b	sp[0x0],r12
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
80007742:	1a d8       	st.w	--sp,r8

// send control request
static u8 send_ctl_request(u8 reqtype, u8 reqnum, 
			   u8* data, u16 size,
			     u16 index, u16 val, 
			     uhd_callback_setup_end_t callbackEnd) {
80007744:	68 08       	ld.w	r8,r4[0x0]
  /*   return;  // No interface to enable */
  /* } */

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
80007746:	ba 38       	st.h	sp[0x6],r8
  req.wIndex = (index);
  req.wLength = (size);
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
80007748:	e0 68 1c 84 	mov	r8,7300

  req.bmRequestType = reqtype;
  req.bRequest = reqnum;
  req.wValue = (val);
  req.wIndex = (index);
  req.wLength = (size);
8000774c:	70 08       	ld.w	r8,r8[0x0]
  return uhd_setup_request(uhi_ftdi_dev.dev->address,
8000774e:	ba 59       	st.h	sp[0xa],r9
80007750:	fa cb ff fc 	sub	r11,sp,-4
80007754:	5c 79       	castu.h	r9
80007756:	f1 3c 00 12 	ld.ub	r12,r8[18]
8000775a:	30 08       	mov	r8,0
8000775c:	fe b0 e3 14 	rcall	80003d84 <uhd_setup_request>
		    &req,
		    data,
		    size,
		    NULL, //&ctl_req_run,
		    callbackEnd); //&ctl_req_end);		    
}
80007760:	2f fd       	sub	sp,-4
80007762:	2f ed       	sub	sp,-8
80007764:	e3 cd 80 10 	ldm	sp++,r4,pc

80007768 <ftdi_get_strings>:
80007768:	d4 31       	pushm	r0-r7,lr
8000776a:	e0 67 1c 8c 	mov	r7,7308
8000776e:	30 18       	mov	r8,1

  // get manufacturer string
  ctlReadBusy = 1;
  //  print_dbg("\r\n sending ctl request for manufacturer string, index : ");
  //  print_dbg_hex(uhi_ftdi_dev.dev->dev_desc.iManufacturer);
  if(!(send_ctl_request(
80007770:	ae 88       	st.b	r7[0x0],r8
80007772:	fe c5 00 4e 	sub	r5,pc,78
80007776:	e0 66 1c 84 	mov	r6,7300
8000777a:	1a d5       	st.w	--sp,r5
8000777c:	6c 09       	ld.w	r9,r6[0x0]
8000777e:	f3 39 00 0e 	ld.ub	r9,r9[14]
80007782:	e8 19 03 00 	orl	r9,0x300
  //  print_dbg_hex((u32)status);
  ctlReadBusy = 0;
}

// read eeprom
void ftdi_get_strings(char** pManufacturer, char** pProduct, char** pSerial) {
80007786:	18 92       	mov	r2,r12

  // get manufacturer string
  ctlReadBusy = 1;
  //  print_dbg("\r\n sending ctl request for manufacturer string, index : ");
  //  print_dbg_hex(uhi_ftdi_dev.dev->dev_desc.iManufacturer);
  if(!(send_ctl_request(
80007788:	1a d9       	st.w	--sp,r9
8000778a:	16 91       	mov	r1,r11
8000778c:	14 90       	mov	r0,r10
8000778e:	e0 64 31 c8 	mov	r4,12744
80007792:	e0 68 04 09 	mov	r8,1033
80007796:	34 09       	mov	r9,64
80007798:	08 9a       	mov	r10,r4
8000779a:	30 6b       	mov	r11,6
8000779c:	e0 6c 00 80 	mov	r12,128
800077a0:	cc 8f       	rcall	80007730 <send_ctl_request>
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 
800077a2:	2f ed       	sub	sp,-8
800077a4:	58 0c       	cp.w	r12,0
800077a6:	c4 10       	breq	80007828 <ftdi_get_strings+0xc0>

  // get product string
  ctlReadBusy = 1;
  //  print_dbg("\r\n sending ctl request for product string, index : ");
  //  print_dbg_ulong( uhi_ftdi_dev.dev->dev_desc.iProduct);
  if(!(send_ctl_request(
800077a8:	0f 88       	ld.ub	r8,r7[0x0]
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get product string
  ctlReadBusy = 1;
800077aa:	58 08       	cp.w	r8,0
  //  print_dbg("\r\n sending ctl request for product string, index : ");
  //  print_dbg_ulong( uhi_ftdi_dev.dev->dev_desc.iProduct);
  if(!(send_ctl_request(
800077ac:	cf e1       	brne	800077a8 <ftdi_get_strings+0x40>
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get product string
  ctlReadBusy = 1;
800077ae:	1a d5       	st.w	--sp,r5
800077b0:	30 1a       	mov	r10,1
  //  print_dbg("\r\n sending ctl request for product string, index : ");
  //  print_dbg_ulong( uhi_ftdi_dev.dev->dev_desc.iProduct);
  if(!(send_ctl_request(
800077b2:	6c 08       	ld.w	r8,r6[0x0]
800077b4:	e0 69 1c 8c 	mov	r9,7308
800077b8:	b2 8a       	st.b	r9[0x0],r10
800077ba:	f1 38 00 0f 	ld.ub	r8,r8[15]
800077be:	e8 18 03 00 	orl	r8,0x300
800077c2:	e0 63 32 48 	mov	r3,12872
800077c6:	1a d8       	st.w	--sp,r8
800077c8:	34 09       	mov	r9,64
800077ca:	e0 68 04 09 	mov	r8,1033
800077ce:	06 9a       	mov	r10,r3
800077d0:	30 6b       	mov	r11,6
800077d2:	e0 6c 00 80 	mov	r12,128
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 
800077d6:	ca df       	rcall	80007730 <send_ctl_request>
800077d8:	2f ed       	sub	sp,-8
800077da:	58 0c       	cp.w	r12,0

  // get serial string
  ctlReadBusy = 1;
  // print_dbg("\r\n sending ctl request for serial string : ");
  if(!(send_ctl_request(
800077dc:	c2 60       	breq	80007828 <ftdi_get_strings+0xc0>
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get serial string
  ctlReadBusy = 1;
800077de:	0f 88       	ld.ub	r8,r7[0x0]
  // print_dbg("\r\n sending ctl request for serial string : ");
  if(!(send_ctl_request(
800077e0:	58 08       	cp.w	r8,0
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; } 

  // get serial string
  ctlReadBusy = 1;
800077e2:	cf e1       	brne	800077de <ftdi_get_strings+0x76>
800077e4:	1a d5       	st.w	--sp,r5
  // print_dbg("\r\n sending ctl request for serial string : ");
  if(!(send_ctl_request(
800077e6:	30 1a       	mov	r10,1
800077e8:	6c 08       	ld.w	r8,r6[0x0]
800077ea:	e0 69 1c 8c 	mov	r9,7308
800077ee:	b2 8a       	st.b	r9[0x0],r10
800077f0:	f1 38 00 10 	ld.ub	r8,r8[16]
800077f4:	e8 18 03 00 	orl	r8,0x300
800077f8:	e0 66 32 08 	mov	r6,12808
800077fc:	1a d8       	st.w	--sp,r8
800077fe:	34 09       	mov	r9,64
80007800:	e0 68 04 09 	mov	r8,1033
80007804:	0c 9a       	mov	r10,r6
80007806:	30 6b       	mov	r11,6
80007808:	e0 6c 00 80 	mov	r12,128
       )) {
    print_dbg("\r\n control request for string descriptor failed");
    return;
  }
  // wait for transfer end
  while(ctlReadBusy) { ;; }
8000780c:	c9 2f       	rcall	80007730 <send_ctl_request>
8000780e:	2f ed       	sub	sp,-8
  //  print_dbg("\r\n requested all string descriptors.");
  *pManufacturer = manufacturer_string + FTDI_STRING_DESC_OFFSET;
80007810:	58 0c       	cp.w	r12,0
80007812:	c0 b0       	breq	80007828 <ftdi_get_strings+0xc0>
  *pProduct = product_string + FTDI_STRING_DESC_OFFSET;
80007814:	0f 88       	ld.ub	r8,r7[0x0]
80007816:	58 08       	cp.w	r8,0
  *pSerial = serial_string + FTDI_STRING_DESC_OFFSET;
80007818:	cf e1       	brne	80007814 <ftdi_get_strings+0xac>
8000781a:	2f e4       	sub	r4,-2
8000781c:	85 04       	st.w	r2[0x0],r4
			(USB_DT_STRING << 8) | uhi_ftdi_dev.dev->dev_desc.iSerialNumber,
			// end-transfer callback
			&ctl_req_end )
       
       )) {
    print_dbg("\r\n control request for string descriptor failed");
8000781e:	2f e3       	sub	r3,-2
80007820:	83 03       	st.w	r1[0x0],r3
80007822:	2f e6       	sub	r6,-2
    return;
80007824:	81 06       	st.w	r0[0x0],r6
80007826:	d8 32       	popm	r0-r7,pc
80007828:	fe cc b4 c0 	sub	r12,pc,-19264
8000782c:	fe b0 da c6 	rcall	80002db8 <print_dbg>
80007830:	d8 32       	popm	r0-r7,pc
80007832:	d7 03       	nop

80007834 <uhi_ftdi_out_run>:
80007834:	d4 01       	pushm	lr
80007836:	1a da       	st.w	--sp,r10
80007838:	16 98       	mov	r8,r11
8000783a:	18 99       	mov	r9,r12
8000783c:	e0 6a 1c 84 	mov	r10,7300
80007840:	e0 6c 4e 20 	mov	r12,20000
80007844:	15 db       	ld.ub	r11,r10[0x5]
80007846:	74 0a       	ld.w	r10,r10[0x0]
80007848:	1a dc       	st.w	--sp,r12
8000784a:	f5 3c 00 12 	ld.ub	r12,r10[18]
}

// run the output endpoint (bulk)
bool uhi_ftdi_out_run(uint8_t * buf, iram_size_t buf_size,
		      uhd_callback_trans_t callback) {
  return uhd_ep_run(uhi_ftdi_dev.dev->address,
8000784e:	30 1a       	mov	r10,1
80007850:	fe b0 e1 c4 	rcall	80003bd8 <uhd_ep_run>
		    uhi_ftdi_dev.ep_out, true, buf, buf_size,
		    UHI_FTDI_TIMEOUT, callback);
}
80007854:	2f ed       	sub	sp,-8
80007856:	d8 02       	popm	pc

80007858 <uhi_ftdi_in_run>:
80007858:	d4 01       	pushm	lr
8000785a:	1a da       	st.w	--sp,r10
8000785c:	16 98       	mov	r8,r11
8000785e:	18 99       	mov	r9,r12
}

// run the input endpoint (bulk)
bool uhi_ftdi_in_run(uint8_t * buf, iram_size_t buf_size,
		     uhd_callback_trans_t callback) {
  return uhd_ep_run(uhi_ftdi_dev.dev->address,
80007860:	e0 6a 1c 84 	mov	r10,7300
80007864:	e0 6c 4e 20 	mov	r12,20000
80007868:	15 cb       	ld.ub	r11,r10[0x4]
8000786a:	74 0a       	ld.w	r10,r10[0x0]
8000786c:	1a dc       	st.w	--sp,r12
8000786e:	f5 3c 00 12 	ld.ub	r12,r10[18]
80007872:	30 0a       	mov	r10,0
80007874:	fe b0 e1 b2 	rcall	80003bd8 <uhd_ep_run>
		    uhi_ftdi_dev.ep_in, false, buf, buf_size,
		    UHI_FTDI_TIMEOUT, callback);
}
80007878:	2f ed       	sub	sp,-8
8000787a:	d8 02       	popm	pc

8000787c <uhi_ftdi_uninstall>:
8000787c:	d4 01       	pushm	lr
8000787e:	e0 68 1c 84 	mov	r8,7300
80007882:	70 0a       	ld.w	r10,r8[0x0]

  ftdi_change(dev, true);  
}

void uhi_ftdi_uninstall(uhc_device_t* dev) {
  if (uhi_ftdi_dev.dev != dev) {
80007884:	18 3a       	cp.w	r10,r12
80007886:	c0 20       	breq	8000788a <uhi_ftdi_uninstall+0xe>
    return; // Device not enabled in this interface
  }
  uhi_ftdi_dev.dev = NULL;
80007888:	d8 02       	popm	pc
8000788a:	30 0b       	mov	r11,0
  Assert(uhi_ftdi_dev.report!=NULL);
  ftdi_change(dev, false);  
8000788c:	91 0b       	st.w	r8[0x0],r11
8000788e:	c1 1d       	rcall	80007ab0 <ftdi_change>
80007890:	d8 02       	popm	pc
80007892:	d7 03       	nop

80007894 <uhi_ftdi_enable>:
80007894:	eb cd 40 c0 	pushm	r6-r7,lr
80007898:	e0 68 1c 84 	mov	r8,7300
  return UHC_ENUM_UNSUPPORTED; // No interface supported
}

void uhi_ftdi_enable(uhc_device_t* dev) {

  if (uhi_ftdi_dev.dev != dev) {
8000789c:	70 07       	ld.w	r7,r8[0x0]
8000789e:	18 37       	cp.w	r7,r12
800078a0:	c0 30       	breq	800078a6 <uhi_ftdi_enable+0x12>
800078a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  }
  /// bit mode (not bitbang? )
  /// todo: what do these mean???
  // val : ff
  // indx : 1
  send_ctl_request(FTDI_DEVICE_OUT_REQTYPE, 
800078a6:	e0 68 00 ff 	mov	r8,255
800078aa:	30 06       	mov	r6,0
800078ac:	30 bb       	mov	r11,11
800078ae:	1a d6       	st.w	--sp,r6
800078b0:	0c 99       	mov	r9,r6
800078b2:	1a d8       	st.w	--sp,r8
800078b4:	0c 9a       	mov	r10,r6
800078b6:	30 18       	mov	r8,1
800078b8:	34 0c       	mov	r12,64
800078ba:	c3 bf       	rcall	80007730 <send_ctl_request>
		   NULL);
  /// line property
  /// todo: what do these mean???
  // index 1
  // val : 8
  send_ctl_request(FTDI_DEVICE_OUT_REQTYPE, 
800078bc:	30 88       	mov	r8,8
800078be:	1a d6       	st.w	--sp,r6
800078c0:	0c 99       	mov	r9,r6
800078c2:	1a d8       	st.w	--sp,r8
800078c4:	0c 9a       	mov	r10,r6
800078c6:	30 18       	mov	r8,1
800078c8:	30 4b       	mov	r11,4
800078ca:	34 0c       	mov	r12,64
800078cc:	c3 2f       	rcall	80007730 <send_ctl_request>
800078ce:	e0 69 c0 36 	mov	r9,49206
  /// baud rate
  // rq : 3
  // value: 26 (baudrate: 115200)
  // value: 49206 (baudrate : 57600)
  // index: 0
  send_ctl_request(FTDI_DEVICE_OUT_REQTYPE, 
800078d2:	1a d6       	st.w	--sp,r6
800078d4:	0c 98       	mov	r8,r6
800078d6:	1a d9       	st.w	--sp,r9
800078d8:	0c 9a       	mov	r10,r6
800078da:	0c 99       	mov	r9,r6
800078dc:	30 3b       	mov	r11,3
800078de:	34 0c       	mov	r12,64
800078e0:	c2 8f       	rcall	80007730 <send_ctl_request>
800078e2:	e0 68 03 e8 	mov	r8,1000
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800078e6:	30 09       	mov	r9,0
800078e8:	e0 6a 07 e7 	mov	r10,2023
800078ec:	ea 1a 12 c8 	orh	r10,0x12c8
800078f0:	30 3b       	mov	r11,3
800078f2:	e0 a0 13 dd 	rcall	8000a0ac <__avr32_udiv64>
800078f6:	e1 b8 00 42 	mfsr	r8,0x108
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800078fa:	f0 0a 00 0a 	add	r10,r8,r10
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800078fe:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007902:	2f ad       	sub	sp,-24
80007904:	14 38       	cp.w	r8,r10
80007906:	e0 88 00 0c 	brls	8000791e <uhi_ftdi_enable+0x8a>
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000790a:	12 38       	cp.w	r8,r9
8000790c:	e0 88 00 04 	brls	80007914 <uhi_ftdi_enable+0x80>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80007910:	12 3a       	cp.w	r10,r9
80007912:	c0 93       	brcs	80007924 <uhi_ftdi_enable+0x90>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007914:	e1 b9 00 42 	mfsr	r9,0x108
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80007918:	14 38       	cp.w	r8,r10
8000791a:	fe 9b ff f8 	brhi	8000790a <uhi_ftdi_enable+0x76>
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000791e:	12 38       	cp.w	r8,r9
80007920:	fe 98 ff f8 	brls	80007910 <uhi_ftdi_enable+0x7c>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80007924:	0e 9c       	mov	r12,r7
80007926:	30 1b       	mov	r11,1
		   0, 49206,
		   NULL);

  delay_ms(200);

  ftdi_change(dev, true);  
80007928:	cc 4c       	rcall	80007ab0 <ftdi_change>
8000792a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000792e:	d7 03       	nop

80007930 <uhi_ftdi_install>:
80007930:	d4 31       	pushm	r0-r7,lr
80007932:	e0 65 1c 84 	mov	r5,7300
80007936:	18 94       	mov	r4,r12
80007938:	6a 02       	ld.w	r2,r5[0x0]
8000793a:	58 02       	cp.w	r2,0
8000793c:	c0 30       	breq	80007942 <uhi_ftdi_install+0x12>
8000793e:	30 5c       	mov	r12,5
80007940:	d8 32       	popm	r0-r7,pc
80007942:	98 48       	ld.sh	r8,r12[0x8]
  if (uhi_ftdi_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }

  // check vid/pid
  vid = le16_to_cpu(dev->dev_desc.idVendor);
80007944:	10 9b       	mov	r11,r8
  pid = le16_to_cpu(dev->dev_desc.idProduct);
80007946:	5c cb       	swap.bh	r11
80007948:	98 58       	ld.sh	r8,r12[0xa]

  if( (vid == FTDI_VID) && (pid == FTDI_PID) ) {
8000794a:	5c c8       	swap.bh	r8
8000794c:	e0 69 60 01 	mov	r9,24577
80007950:	e0 6a 04 03 	mov	r10,1027
80007954:	f2 08 19 00 	cp.h	r8,r9
80007958:	5f 09       	sreq	r9
8000795a:	f4 0b 19 00 	cp.h	r11,r10
8000795e:	5f 08       	sreq	r8
80007960:	10 69       	and	r9,r8
80007962:	e4 09 18 00 	cp.b	r9,r2
  }

  if (b_iface_supported) {
    uhi_ftdi_dev.dev = dev;
    print_dbg("\r\n completed FTDI device install");
    return UHC_ENUM_SUCCESS;
80007966:	c0 21       	brne	8000796a <uhi_ftdi_install+0x3a>
    ;; // this is an FTDI device, so continue
  } else {
    return UHC_ENUM_UNSUPPORTED;
  }

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
80007968:	da 3a       	popm	r0-r7,pc,r12=1
8000796a:	78 67       	ld.w	r7,r12[0x18]
8000796c:	0f a6       	ld.ub	r6,r7[0x2]
8000796e:	0f b8       	ld.ub	r8,r7[0x3]
80007970:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007974:	5c c6       	swap.bh	r6
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
80007976:	5c 86       	casts.h	r6
    switch (ptr_iface->bDescriptorType) {
80007978:	cf 80       	breq	80007968 <uhi_ftdi_install+0x38>

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
8000797a:	30 43       	mov	r3,4
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
8000797c:	3f f0       	mov	r0,-1
8000797e:	30 51       	mov	r1,5
80007980:	c0 d8       	rjmp	8000799a <uhi_ftdi_install+0x6a>
80007982:	e2 08 18 00 	cp.b	r8,r1
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
	break;
      }
      break;
    default:
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
80007986:	c2 10       	breq	800079c8 <uhi_ftdi_install+0x98>
80007988:	fe cc b5 78 	sub	r12,pc,-19080
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
8000798c:	fe b0 da 16 	rcall	80002db8 <print_dbg>
80007990:	0f 88       	ld.ub	r8,r7[0x0]

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
80007992:	10 16       	sub	r6,r8
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
      break;
    }
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80007994:	5c 86       	casts.h	r6
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  b_iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
80007996:	c3 40       	breq	800079fe <uhi_ftdi_install+0xce>
80007998:	10 07       	add	r7,r8
8000799a:	0f 98       	ld.ub	r8,r7[0x1]
8000799c:	e6 08 18 00 	cp.b	r8,r3

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
800079a0:	cf 11       	brne	80007982 <uhi_ftdi_install+0x52>
800079a2:	0f d8       	ld.ub	r8,r7[0x5]
800079a4:	e0 08 18 00 	cp.b	r8,r0
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
	break;
      }
      break;
    default:
      print_dbg("\r\n ignoring descriptor in ftdi device enumeration");
800079a8:	c0 30       	breq	800079ae <uhi_ftdi_install+0x7e>
  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
	  && (ptr_iface->bInterfaceProtocol == FTDI_PROTOCOL) ) {
800079aa:	30 02       	mov	r2,0
800079ac:	cf 2b       	rjmp	80007990 <uhi_ftdi_install+0x60>
800079ae:	0f f8       	ld.ub	r8,r7[0x7]
800079b0:	e0 08 18 00 	cp.b	r8,r0
	print_dbg("\r\n class/protocol matches FTDI. ");
800079b4:	cf b1       	brne	800079aa <uhi_ftdi_install+0x7a>
800079b6:	fe cc b6 1e 	sub	r12,pc,-18914
	b_iface_supported = true;
	uhi_ftdi_dev.ep_in = 0;
	uhi_ftdi_dev.ep_out = 0;
800079ba:	fe b0 d9 ff 	rcall	80002db8 <print_dbg>
800079be:	30 09       	mov	r9,0

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {

    case USB_DT_INTERFACE:
      if ((ptr_iface->bInterfaceClass == FTDI_CLASS)
800079c0:	30 12       	mov	r2,1
	b_iface_supported = false;
      }
      break;

    case USB_DT_ENDPOINT:
      if (!b_iface_supported) {
800079c2:	aa c9       	st.b	r5[0x4],r9
800079c4:	aa d9       	st.b	r5[0x5],r9
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
800079c6:	ce 5b       	rjmp	80007990 <uhi_ftdi_install+0x60>
800079c8:	58 02       	cp.w	r2,0
800079ca:	ce 30       	breq	80007990 <uhi_ftdi_install+0x60>
800079cc:	0e 9b       	mov	r11,r7
800079ce:	e9 3c 00 12 	ld.ub	r12,r4[18]
	print_dbg("\r\n endpoint allocation failed");
	return UHC_ENUM_HARDWARE_LIMIT;
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
800079d2:	fe b0 e2 81 	rcall	80003ed4 <uhd_ep_alloc>
800079d6:	c1 d0       	breq	80007a10 <uhi_ftdi_install+0xe0>
800079d8:	0f b8       	ld.ub	r8,r7[0x3]
800079da:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
	} else {
	  uhi_ftdi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	}
	break;
      default:
	print_dbg("\r\n unhandled endpoint in ftdi device enumeration");
800079de:	58 28       	cp.w	r8,2
800079e0:	c0 60       	breq	800079ec <uhi_ftdi_install+0xbc>
800079e2:	fe cc b6 06 	sub	r12,pc,-18938
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
      case USB_EP_TYPE_BULK:
	//	print_dbg("\r\n allocating bulk endpoint: ");
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
800079e6:	fe b0 d9 e9 	rcall	80002db8 <print_dbg>
	  uhi_ftdi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
800079ea:	cd 3b       	rjmp	80007990 <uhi_ftdi_install+0x60>
800079ec:	0f a8       	ld.ub	r8,r7[0x2]
800079ee:	30 09       	mov	r9,0
	} else {
	  uhi_ftdi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
800079f0:	f2 08 18 00 	cp.b	r8,r9
800079f4:	eb f8 5e 04 	st.blt	r5[0x4],r8
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (b_iface_supported) {
800079f8:	eb f8 4e 05 	st.bge	r5[0x5],r8
    uhi_ftdi_dev.dev = dev;
800079fc:	cc ab       	rjmp	80007990 <uhi_ftdi_install+0x60>
    print_dbg("\r\n completed FTDI device install");
800079fe:	58 02       	cp.w	r2,0
80007a00:	cb 40       	breq	80007968 <uhi_ftdi_install+0x38>
80007a02:	fe cc b5 be 	sub	r12,pc,-19010
    case USB_DT_ENDPOINT:
      if (!b_iface_supported) {
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	print_dbg("\r\n endpoint allocation failed");
80007a06:	8b 04       	st.w	r5[0x0],r4
80007a08:	fe b0 d9 d8 	rcall	80002db8 <print_dbg>
80007a0c:	0c 9c       	mov	r12,r6
	return UHC_ENUM_HARDWARE_LIMIT;
80007a0e:	d8 32       	popm	r0-r7,pc
80007a10:	fe cc b6 54 	sub	r12,pc,-18860
80007a14:	fe b0 d9 d2 	rcall	80002db8 <print_dbg>
80007a18:	30 4c       	mov	r12,4
80007a1a:	d8 32       	popm	r0-r7,pc

80007a1c <ftdi_rx_done>:
//------- static functions

static void ftdi_rx_done(  usb_add_t add,
			   usb_ep_t ep,
			   uhd_trans_status_t stat,
			   iram_size_t nb) {
80007a1c:	d4 01       	pushm	lr
  status = stat;
80007a1e:	e0 68 1c e0 	mov	r8,7392
  rxBusy = 0;
80007a22:	91 0a       	st.w	r8[0x0],r10
  rxBytes = nb - FTDI_STATUS_BYTES;
80007a24:	e0 68 1c d0 	mov	r8,7376
static void ftdi_rx_done(  usb_add_t add,
			   usb_ep_t ep,
			   uhd_trans_status_t stat,
			   iram_size_t nb) {
  status = stat;
  rxBusy = 0;
80007a28:	20 29       	sub	r9,2
  rxBytes = nb - FTDI_STATUS_BYTES;
80007a2a:	30 0a       	mov	r10,0
80007a2c:	b0 8a       	st.b	r8[0x0],r10
  /* print_dbg_ulong(nb); */
  /* print_dbg(" ; status bytes: 0x"); */
  /* print_dbg_hex(rxBuf[0]); */
  /* print_dbg(" 0x"); */
  /* print_dbg_hex(rxBuf[1]); */			    
  if(rxBytes) {
80007a2e:	e0 68 1c d4 	mov	r8,7380
    //    print_dbg("\r\n ftdi read bytes: ");
    //    print_dbg_ulong(rxBytes);
    // check for monome events
    //    if(monome_read_serial != NULL) { 
      (*monome_read_serial)(); 
80007a32:	91 09       	st.w	r8[0x0],r9
80007a34:	58 09       	cp.w	r9,0
80007a36:	c0 40       	breq	80007a3e <ftdi_rx_done+0x22>
80007a38:	30 c8       	mov	r8,12
80007a3a:	70 08       	ld.w	r8,r8[0x0]
80007a3c:	5d 18       	icall	r8
80007a3e:	d8 02       	popm	pc

80007a40 <ftdi_rx_buf>:
80007a40:	e0 6c 1c 90 	mov	r12,7312
80007a44:	2f ec       	sub	r12,-2
80007a46:	5e fc       	retal	r12

80007a48 <ftdi_rx_bytes>:
80007a48:	e0 68 1c d4 	mov	r8,7380
}

// number of bytes from last rx trasnfer
extern volatile u8 ftdi_rx_bytes() {
  return rxBytes;
}
80007a4c:	11 bc       	ld.ub	r12,r8[0x3]
80007a4e:	5e fc       	retal	r12

80007a50 <ftdi_rx_busy>:
80007a50:	e0 68 1c d0 	mov	r8,7376

// busy flags
extern volatile u8 ftdi_rx_busy() {
  return rxBusy;
}
80007a54:	11 8c       	ld.ub	r12,r8[0x0]
80007a56:	5e fc       	retal	r12

80007a58 <ftdi_tx_busy>:
80007a58:	e0 68 1c 8d 	mov	r8,7309

extern volatile u8 ftdi_tx_busy() {
  return txBusy;
}
80007a5c:	11 8c       	ld.ub	r12,r8[0x0]
80007a5e:	5e fc       	retal	r12

80007a60 <ftdi_tx_done>:
80007a60:	d4 01       	pushm	lr
80007a62:	e0 68 1c e0 	mov	r8,7392
static void ftdi_tx_done(
			       usb_add_t add,
			       usb_ep_t ep,
			       uhd_trans_status_t stat,
			       iram_size_t nb) {
  status = stat;
80007a66:	30 09       	mov	r9,0
  txBusy = 0;
80007a68:	91 0a       	st.w	r8[0x0],r10
80007a6a:	e0 68 1c 8d 	mov	r8,7309
  /* print_dbg("\r\n ftdi tx transfer callback. status: 0x"); */
  /* print_dbg_hex((u32)status); */
  if (status != UHD_TRANS_NOERROR) {
80007a6e:	b0 89       	st.b	r8[0x0],r9
    print_dbg("\r\n ftdi tx error");
80007a70:	58 0a       	cp.w	r10,0
80007a72:	c0 50       	breq	80007a7c <ftdi_tx_done+0x1c>
80007a74:	fe cc b6 0c 	sub	r12,pc,-18932
80007a78:	fe b0 d9 a0 	rcall	80002db8 <print_dbg>
80007a7c:	d8 02       	popm	pc
80007a7e:	d7 03       	nop

80007a80 <ftdi_setup>:
80007a80:	d4 01       	pushm	lr
80007a82:	20 3d       	sub	sp,12
80007a84:	fe cc b6 08 	sub	r12,pc,-18936
// setup new device connection
void ftdi_setup(void) {
  char * manstr;
  char * prodstr;
  char * serstr;
  print_dbg("\r\n FTDI setup routine");
80007a88:	fe b0 d9 98 	rcall	80002db8 <print_dbg>

  // get string data...
  ftdi_get_strings(&manstr, &prodstr, &serstr);  
80007a8c:	1a 9a       	mov	r10,sp
80007a8e:	fa cb ff fc 	sub	r11,sp,-4
80007a92:	fa cc ff f8 	sub	r12,sp,-8
80007a96:	c6 9e       	rcall	80007768 <ftdi_get_strings>
  // print the strings
  // print_unicode_string(manstr, FTDI_STRING_MAX_LEN);
  //  print_unicode_string(prodstr, FTDI_STRING_MAX_LEN);
  //  print_unicode_string(serstr, FTDI_STRING_MAX_LEN);
  //// query if this is a monome device
  check_monome_device_desc(manstr, prodstr, serstr);
80007a98:	40 0a       	lddsp	r10,sp[0x0]
80007a9a:	40 1b       	lddsp	r11,sp[0x4]
80007a9c:	40 2c       	lddsp	r12,sp[0x8]
80007a9e:	fe b0 f7 57 	rcall	8000694c <check_monome_device_desc>
  //// TODO: other protocols??

  // set connection flag
  ftdiConnect = 1;
80007aa2:	30 19       	mov	r9,1
80007aa4:	e0 68 1c 8e 	mov	r8,7310
}
80007aa8:	b0 89       	st.b	r8[0x0],r9
80007aaa:	2f dd       	sub	sp,-12
80007aac:	d8 02       	popm	pc
80007aae:	d7 03       	nop

80007ab0 <ftdi_change>:
80007ab0:	eb cd 40 80 	pushm	r7,lr
80007ab4:	fe cc b6 20 	sub	r12,pc,-18912
80007ab8:	16 97       	mov	r7,r11
80007aba:	fe b0 d9 7f 	rcall	80002db8 <print_dbg>
80007abe:	58 07       	cp.w	r7,0
void ftdi_change(uhc_device_t* dev, u8 plug) {
  print_dbg("\r\n changed FTDI connection status");
  if(plug) { 
    e.eventType = kEventFtdiConnect; 
  } else {
    e.eventType = kEventFtdiDisconnect;
80007ac0:	c0 b1       	brne	80007ad6 <ftdi_change+0x26>
80007ac2:	e0 68 1c d8 	mov	r8,7384
  }
  // posting an event so the main loop can respond
  post_event(&e); 
80007ac6:	30 89       	mov	r9,8
80007ac8:	91 09       	st.w	r8[0x0],r9
80007aca:	e0 6c 1c d8 	mov	r12,7384
}
80007ace:	fe b0 ef 67 	rcall	8000599c <post_event>
// respond to connection or disconnection of ftdi device.
// may be called from an interrupt
void ftdi_change(uhc_device_t* dev, u8 plug) {
  print_dbg("\r\n changed FTDI connection status");
  if(plug) { 
    e.eventType = kEventFtdiConnect; 
80007ad2:	e3 cd 80 80 	ldm	sp++,r7,pc
80007ad6:	e0 68 1c d8 	mov	r8,7384
80007ada:	30 79       	mov	r9,7
80007adc:	91 09       	st.w	r8[0x0],r9
80007ade:	cf 6b       	rjmp	80007aca <ftdi_change+0x1a>

80007ae0 <ftdi_read>:
80007ae0:	d4 01       	pushm	lr
80007ae2:	30 09       	mov	r9,0
80007ae4:	e0 68 1c d4 	mov	r8,7380
  }
}
    
void ftdi_read(void) {
  rxBytes = 0;
  rxBusy = true;
80007ae8:	91 09       	st.w	r8[0x0],r9
80007aea:	30 19       	mov	r9,1
  if (!uhi_ftdi_in_run((u8*)rxBuf,
80007aec:	e0 68 1c d0 	mov	r8,7376
80007af0:	fe ca 00 d4 	sub	r10,pc,212
80007af4:	b0 89       	st.b	r8[0x0],r9
80007af6:	34 0b       	mov	r11,64
80007af8:	e0 6c 1c 90 	mov	r12,7312
		       FTDI_RX_BUF_SIZE, &ftdi_rx_done)) {
    print_dbg("\r\n ftdi rx transfer error");
80007afc:	ca ee       	rcall	80007858 <uhi_ftdi_in_run>
80007afe:	c0 51       	brne	80007b08 <ftdi_read+0x28>
80007b00:	fe cc b6 48 	sub	r12,pc,-18872
80007b04:	fe b0 d9 5a 	rcall	80002db8 <print_dbg>
80007b08:	d8 02       	popm	pc
80007b0a:	d7 03       	nop

80007b0c <ftdi_write>:
80007b0c:	d4 01       	pushm	lr
80007b0e:	30 19       	mov	r9,1
80007b10:	e0 68 1c 8d 	mov	r8,7309
80007b14:	fe ca 00 b4 	sub	r10,pc,180
80007b18:	b0 89       	st.b	r8[0x0],r9
80007b1a:	c8 de       	rcall	80007834 <uhi_ftdi_out_run>
80007b1c:	c0 51       	brne	80007b26 <ftdi_write+0x1a>
80007b1e:	fe cc b6 4a 	sub	r12,pc,-18870
//-------- extern functions
void ftdi_write(u8* data, u32 bytes) {
  txBusy = 1;
  if(!uhi_ftdi_out_run(data, bytes, &ftdi_tx_done)) {

    print_dbg("\r\n error requesting ftdi output pipe");
80007b22:	fe b0 d9 4b 	rcall	80002db8 <print_dbg>
80007b26:	d8 02       	popm	pc

80007b28 <uhi_midi_uninstall>:
  //  UHI_MIDI_CHANGE(dev, true);
  midi_change(dev, true);  
  print_dbg("\r\n finished uhi_midi_enable");
}

void uhi_midi_uninstall(uhc_device_t* dev) {
80007b28:	d4 01       	pushm	lr
  if (uhi_midi_dev.dev != dev) {
80007b2a:	32 08       	mov	r8,32
80007b2c:	70 0a       	ld.w	r10,r8[0x0]
80007b2e:	18 3a       	cp.w	r10,r12
80007b30:	c0 20       	breq	80007b34 <uhi_midi_uninstall+0xc>
80007b32:	d8 02       	popm	pc
    return; // Device not enabled in this interface
  }
  uhi_midi_dev.dev = NULL;
80007b34:	30 0b       	mov	r11,0
80007b36:	91 0b       	st.w	r8[0x0],r11
  Assert(uhi_midi_dev.report!=NULL);
  midi_change(dev, false);  
80007b38:	c8 cc       	rcall	80007c50 <midi_change>
80007b3a:	d8 02       	popm	pc

80007b3c <uhi_midi_enable>:
80007b3c:	d4 01       	pushm	lr
80007b3e:	32 08       	mov	r8,32
80007b40:	70 09       	ld.w	r9,r8[0x0]
80007b42:	18 39       	cp.w	r9,r12
80007b44:	c0 20       	breq	80007b48 <uhi_midi_enable+0xc>
80007b46:	d8 02       	popm	pc
  ////  TODO: ??? any setup requests necessary?
  /* 		   1, 0xff,  */
  /* 		   NULL); */
  
  //  UHI_MIDI_CHANGE(dev, true);
  midi_change(dev, true);  
80007b48:	30 1b       	mov	r11,1
80007b4a:	c8 3c       	rcall	80007c50 <midi_change>
80007b4c:	fe cc b6 50 	sub	r12,pc,-18864
  print_dbg("\r\n finished uhi_midi_enable");
80007b50:	fe b0 d9 34 	rcall	80002db8 <print_dbg>
80007b54:	d8 02       	popm	pc
80007b56:	d7 03       	nop

80007b58 <uhi_midi_install>:
80007b58:	d4 31       	pushm	r0-r7,lr
80007b5a:	20 1d       	sub	sp,4
80007b5c:	32 05       	mov	r5,32
80007b5e:	18 92       	mov	r2,r12
80007b60:	6a 03       	ld.w	r3,r5[0x0]
80007b62:	58 03       	cp.w	r3,0
80007b64:	c0 40       	breq	80007b6c <uhi_midi_install+0x14>
80007b66:	30 5c       	mov	r12,5
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
    return UHC_ENUM_SUCCESS;
  }
  return UHC_ENUM_UNSUPPORTED; // No interface supported
}
80007b68:	2f fd       	sub	sp,-4
80007b6a:	d8 32       	popm	r0-r7,pc

  if (uhi_midi_dev.dev != NULL) {
    return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
  }

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
80007b6c:	78 67       	ld.w	r7,r12[0x18]
80007b6e:	0f a6       	ld.ub	r6,r7[0x2]
80007b70:	0f b8       	ld.ub	r8,r7[0x3]
80007b72:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007b76:	5c c6       	swap.bh	r6
80007b78:	5c 86       	casts.h	r6
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
80007b7a:	c5 40       	breq	80007c22 <uhi_midi_install+0xca>
    switch (ptr_iface->bDescriptorType) {
80007b7c:	30 44       	mov	r4,4

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
80007b7e:	30 11       	mov	r1,1
	   && (ptr_iface->bInterfaceSubClass == USB_MIDI_IFACE_SUBCLASS) ) {
80007b80:	30 30       	mov	r0,3
80007b82:	c1 18       	rjmp	80007ba4 <uhi_midi_install+0x4c>
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
80007b84:	30 59       	mov	r9,5
80007b86:	f2 08 18 00 	cp.b	r8,r9
80007b8a:	c2 00       	breq	80007bca <uhi_midi_install+0x72>
	;; // ignore endpoint (shouldn't get here)
	break;
      }
      break;
    default:
      print_dbg("\r\n uhi_midi_install ignoring descriptor; type: 0x");
80007b8c:	fe cc b6 04 	sub	r12,pc,-18940
80007b90:	fe b0 d9 14 	rcall	80002db8 <print_dbg>
      print_dbg_hex(ptr_iface->bDescriptorType );
80007b94:	0f 9c       	ld.ub	r12,r7[0x1]
80007b96:	fe b0 d8 e3 	rcall	80002d5c <print_dbg_hex>
      break;
      
    }
      
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
80007b9a:	0f 88       	ld.ub	r8,r7[0x0]
80007b9c:	10 16       	sub	r6,r8

  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
80007b9e:	5c 86       	casts.h	r6
      
    }
      
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80007ba0:	c3 f0       	breq	80007c1e <uhi_midi_install+0xc6>
  conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
  ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
  iface_supported = false;

  while(conf_desc_lgt) {
    switch (ptr_iface->bDescriptorType) {
80007ba2:	10 07       	add	r7,r8
80007ba4:	0f 98       	ld.ub	r8,r7[0x1]
80007ba6:	e8 08 18 00 	cp.b	r8,r4

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
80007baa:	ce d1       	brne	80007b84 <uhi_midi_install+0x2c>
80007bac:	0f d8       	ld.ub	r8,r7[0x5]
80007bae:	e2 08 18 00 	cp.b	r8,r1
	break;
      }
      break;
    default:
      print_dbg("\r\n uhi_midi_install ignoring descriptor; type: 0x");
      print_dbg_hex(ptr_iface->bDescriptorType );
80007bb2:	c0 30       	breq	80007bb8 <uhi_midi_install+0x60>
80007bb4:	30 03       	mov	r3,0
      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
	   && (ptr_iface->bInterfaceSubClass == USB_MIDI_IFACE_SUBCLASS) ) {
80007bb6:	cf 2b       	rjmp	80007b9a <uhi_midi_install+0x42>
80007bb8:	0f e8       	ld.ub	r8,r7[0x6]
80007bba:	e0 08 18 00 	cp.b	r8,r0

#if UHI_MIDI_PRINT_DBG
	print_dbg("\r\n class/subclass matches audio/MIDI. ");
#endif
	iface_supported = true;
	uhi_midi_dev.ep_in = 0;
80007bbe:	cf b1       	brne	80007bb4 <uhi_midi_install+0x5c>
	uhi_midi_dev.ep_out = 0;
80007bc0:	30 08       	mov	r8,0
80007bc2:	30 13       	mov	r3,1

#if UHI_MIDI_PRINT_DBG
	print_dbg("\r\n class/subclass matches audio/MIDI. ");
#endif
	iface_supported = true;
	uhi_midi_dev.ep_in = 0;
80007bc4:	aa d8       	st.b	r5[0x5],r8

      print_dbg("\r\n\r\n\r\n");
#endif
      

      if ( ( ptr_iface->bInterfaceClass == USB_AUDIO_IFACE_CLASS ) 
80007bc6:	aa c8       	st.b	r5[0x4],r8
	iface_supported = false;
      }
      break;

    case USB_DT_ENDPOINT:
      if (!iface_supported) {
80007bc8:	ce 9b       	rjmp	80007b9a <uhi_midi_install+0x42>
80007bca:	58 03       	cp.w	r3,0
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
80007bcc:	ce 70       	breq	80007b9a <uhi_midi_install+0x42>
80007bce:	0e 9b       	mov	r11,r7
80007bd0:	e5 3c 00 12 	ld.ub	r12,r2[18]
80007bd4:	fe b0 e1 80 	rcall	80003ed4 <uhd_ep_alloc>
	print_dbg("\r\n endpoint allocation failed");
	return UHC_ENUM_HARDWARE_LIMIT;
      }

      switch(((usb_ep_desc_t*)ptr_iface)->bmAttributes & USB_EP_TYPE_MASK) {
80007bd8:	c3 00       	breq	80007c38 <uhi_midi_install+0xe0>
80007bda:	0f b8       	ld.ub	r8,r7[0x3]
80007bdc:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80007be0:	58 28       	cp.w	r8,2
      case USB_EP_TYPE_BULK:
       	print_dbg("\r\n allocating bulk endpoint ( ");
80007be2:	cd c1       	brne	80007b9a <uhi_midi_install+0x42>
80007be4:	fe cc b6 cc 	sub	r12,pc,-18740
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
80007be8:	fe b0 d8 e8 	rcall	80002db8 <print_dbg>
80007bec:	30 08       	mov	r8,0
80007bee:	0f a9       	ld.ub	r9,r7[0x2]
80007bf0:	f0 09 18 00 	cp.b	r9,r8
	  /* print_dbg("\r\n ( previous input : 0x"); */
	  /* print_dbg_hex((u32)uhi_midi_dev.ep_in); */
	  /* if(uhi_midi_dev.ep_in != 0) { print_dbg("\r\n reallocating midi input endpoint"); } */
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	} else {
	  print_dbg(" output )");
80007bf4:	c2 05       	brlt	80007c34 <uhi_midi_install+0xdc>
80007bf6:	50 08       	stdsp	sp[0x0],r8
80007bf8:	fe cc b6 c0 	sub	r12,pc,-18752
	  print_dbg("\r\n ( previous output : 0x");
80007bfc:	fe b0 d8 de 	rcall	80002db8 <print_dbg>
	  print_dbg_hex((u32)uhi_midi_dev.ep_out);
80007c00:	fe cc b6 bc 	sub	r12,pc,-18756
80007c04:	fe b0 d8 da 	rcall	80002db8 <print_dbg>
	  if(uhi_midi_dev.ep_out != 0) { print_dbg("\r\n reallocating midi output endpoint"); }
80007c08:	0b dc       	ld.ub	r12,r5[0x5]
80007c0a:	fe b0 d8 a9 	rcall	80002d5c <print_dbg_hex>
80007c0e:	0b d9       	ld.ub	r9,r5[0x5]
	  uhi_midi_dev.ep_out = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
80007c10:	40 08       	lddsp	r8,sp[0x0]
80007c12:	f0 09 18 00 	cp.b	r9,r8
    Assert(conf_desc_lgt>=ptr_iface->bLength);
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
80007c16:	c1 71       	brne	80007c44 <uhi_midi_install+0xec>
80007c18:	0f a8       	ld.ub	r8,r7[0x2]
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
    return UHC_ENUM_SUCCESS;
80007c1a:	aa d8       	st.b	r5[0x5],r8
80007c1c:	cb fb       	rjmp	80007b9a <uhi_midi_install+0x42>
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
    uhi_midi_dev.dev = dev;
    print_dbg("\r\n completed MIDI device install");
80007c1e:	58 03       	cp.w	r3,0
    conf_desc_lgt -= ptr_iface->bLength;
    ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
  }

  if (iface_supported) {
    uhi_midi_dev.dev = dev;
80007c20:	c0 31       	brne	80007c26 <uhi_midi_install+0xce>
    print_dbg("\r\n completed MIDI device install");
80007c22:	30 1c       	mov	r12,1
80007c24:	ca 2b       	rjmp	80007b68 <uhi_midi_install+0x10>
80007c26:	fe cc b6 6a 	sub	r12,pc,-18838
	if (((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN) {
	  /* print_dbg(" input )"); */
	  /* print_dbg("\r\n ( previous input : 0x"); */
	  /* print_dbg_hex((u32)uhi_midi_dev.ep_in); */
	  /* if(uhi_midi_dev.ep_in != 0) { print_dbg("\r\n reallocating midi input endpoint"); } */
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
80007c2a:	8b 02       	st.w	r5[0x0],r2
80007c2c:	fe b0 d8 c6 	rcall	80002db8 <print_dbg>
    case USB_DT_ENDPOINT:
      if (!iface_supported) {
	break;
      }
      if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
	print_dbg("\r\n endpoint allocation failed");
80007c30:	0c 9c       	mov	r12,r6
80007c32:	c9 bb       	rjmp	80007b68 <uhi_midi_install+0x10>
80007c34:	aa c9       	st.b	r5[0x4],r9
	return UHC_ENUM_HARDWARE_LIMIT;
80007c36:	cb 2b       	rjmp	80007b9a <uhi_midi_install+0x42>
	  uhi_midi_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
	} else {
	  print_dbg(" output )");
	  print_dbg("\r\n ( previous output : 0x");
	  print_dbg_hex((u32)uhi_midi_dev.ep_out);
	  if(uhi_midi_dev.ep_out != 0) { print_dbg("\r\n reallocating midi output endpoint"); }
80007c38:	fe cc b8 7c 	sub	r12,pc,-18308
80007c3c:	fe b0 d8 be 	rcall	80002db8 <print_dbg>
80007c40:	30 4c       	mov	r12,4
80007c42:	c9 3b       	rjmp	80007b68 <uhi_midi_install+0x10>
80007c44:	fe cc b6 e4 	sub	r12,pc,-18716
80007c48:	fe b0 d8 b8 	rcall	80002db8 <print_dbg>
80007c4c:	ce 6b       	rjmp	80007c18 <uhi_midi_install+0xc0>
80007c4e:	d7 03       	nop

80007c50 <midi_change>:
  return;
}

// MIDI device was plugged or unplugged
extern void midi_change(uhc_device_t* dev, u8 plug) {
  midiConnect = plug;
80007c50:	e0 68 1c e4 	mov	r8,7396
}
80007c54:	b0 8b       	st.b	r8[0x0],r11
80007c56:	5e fc       	retal	r12

80007c58 <hid_mouse_move>:
void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
  print_dbg_ulong(b_state);
}

void hid_mouse_move(int8_t x, int8_t y, int8_t scroll) {
80007c58:	eb cd 40 e0 	pushm	r5-r7,lr
80007c5c:	16 97       	mov	r7,r11
80007c5e:	14 96       	mov	r6,r10
80007c60:	18 95       	mov	r5,r12
  print_dbg("\r\n usb mouse move; x: ");
80007c62:	fe cc b6 82 	sub	r12,pc,-18814
80007c66:	fe b0 d8 a9 	rcall	80002db8 <print_dbg>
  print_dbg_hex(x);
80007c6a:	f9 d5 b0 08 	bfexts	r12,r5,0x0,0x8
80007c6e:	fe b0 d8 77 	rcall	80002d5c <print_dbg_hex>
  print_dbg(", y: ");
80007c72:	fe cc b6 7a 	sub	r12,pc,-18822
  print_dbg_hex(y);
80007c76:	fe b0 d8 a1 	rcall	80002db8 <print_dbg>
80007c7a:	0e 9c       	mov	r12,r7
80007c7c:	5c 6c       	casts.b	r12
  print_dbg(", scroll: ");
80007c7e:	fe b0 d8 6f 	rcall	80002d5c <print_dbg_hex>
80007c82:	fe cc b6 82 	sub	r12,pc,-18814
  print_dbg_hex(scroll);
80007c86:	fe b0 d8 99 	rcall	80002db8 <print_dbg>
80007c8a:	f9 d6 b0 08 	bfexts	r12,r6,0x0,0x8
}
80007c8e:	fe b0 d8 67 	rcall	80002d5c <print_dbg_hex>
80007c92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007c96:	d7 03       	nop

80007c98 <hid_mouse_btn_middle>:
80007c98:	eb cd 40 80 	pushm	r7,lr
80007c9c:	18 97       	mov	r7,r12
80007c9e:	fe cc b6 92 	sub	r12,pc,-18798
80007ca2:	fe b0 d8 8b 	rcall	80002db8 <print_dbg>
  print_dbg_ulong(b_state);
}

void hid_mouse_btn_middle(bool b_state) {
  print_dbg("\r\n usb mid mouse button: ");
  print_dbg_ulong(b_state);
80007ca6:	0e 9c       	mov	r12,r7
80007ca8:	fe b0 d8 82 	rcall	80002dac <print_dbg_ulong>
}
80007cac:	e3 cd 80 80 	ldm	sp++,r7,pc

80007cb0 <hid_mouse_btn_right>:
80007cb0:	eb cd 40 80 	pushm	r7,lr
80007cb4:	18 97       	mov	r7,r12
80007cb6:	fe cc b6 8e 	sub	r12,pc,-18802
80007cba:	fe b0 d8 7f 	rcall	80002db8 <print_dbg>
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}

void hid_mouse_btn_right(bool b_state) {
  print_dbg("\r\n usb right mouse button: ");
  print_dbg_ulong(b_state);
80007cbe:	0e 9c       	mov	r12,r7
80007cc0:	fe b0 d8 76 	rcall	80002dac <print_dbg_ulong>
}
80007cc4:	e3 cd 80 80 	ldm	sp++,r7,pc

80007cc8 <hid_mouse_btn_left>:
80007cc8:	eb cd 40 80 	pushm	r7,lr
80007ccc:	18 97       	mov	r7,r12
80007cce:	fe cc b6 8a 	sub	r12,pc,-18806
80007cd2:	fe b0 d8 73 	rcall	80002db8 <print_dbg>
#include "hid_mouse.h"

// mouse event callbacks
void hid_mouse_btn_left(bool b_state) {
  print_dbg("\r\n usb left mouse button: ");
  print_dbg_ulong(b_state);
80007cd6:	0e 9c       	mov	r12,r7
80007cd8:	fe b0 d8 6a 	rcall	80002dac <print_dbg_ulong>
  
  //gpio_tgl_gpio_pin(LED_MODE_PIN);
}
80007cdc:	e3 cd 80 80 	ldm	sp++,r7,pc

80007ce0 <uhi_hid_mouse_uninstall>:
	uhi_hid_mouse_start_trans_report(dev->address);
	UHI_HID_MOUSE_CHANGE(dev, true);
}

void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
80007ce0:	d4 01       	pushm	lr
	if (uhi_hid_mouse_dev.dev != dev) {
80007ce2:	e0 68 1c e8 	mov	r8,7400
80007ce6:	70 09       	ld.w	r9,r8[0x0]
80007ce8:	18 39       	cp.w	r9,r12
80007cea:	c0 20       	breq	80007cee <uhi_hid_mouse_uninstall+0xe>
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
80007cec:	d8 02       	popm	pc
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
80007cee:	30 09       	mov	r9,0
void uhi_hid_mouse_uninstall(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
		return; // Device not enabled in this interface
	}
	uhi_hid_mouse_dev.dev = NULL;
80007cf0:	70 2c       	ld.w	r12,r8[0x8]
	Assert(uhi_hid_mouse_dev.report!=NULL);
	free(uhi_hid_mouse_dev.report);
80007cf2:	91 09       	st.w	r8[0x0],r9
80007cf4:	e0 a0 13 26 	rcall	8000a340 <free>
80007cf8:	d8 02       	popm	pc
80007cfa:	d7 03       	nop

80007cfc <uhi_hid_mouse_enable>:
80007cfc:	d4 01       	pushm	lr
80007cfe:	e0 69 1c e8 	mov	r9,7400
	return UHC_ENUM_UNSUPPORTED; // No interface supported
}

void uhi_hid_mouse_enable(uhc_device_t* dev)
{
	if (uhi_hid_mouse_dev.dev != dev) {
80007d02:	72 08       	ld.w	r8,r9[0x0]
80007d04:	18 38       	cp.w	r8,r12
80007d06:	c0 20       	breq	80007d0a <uhi_hid_mouse_enable+0xe>
		return;  // No interface to enable
	}

	// Init value
	uhi_hid_mouse_dev.report_btn_prev = 0;
80007d08:	d8 02       	popm	pc
80007d0a:	30 0a       	mov	r10,0
80007d0c:	f3 6a 00 0c 	st.b	r9[12],r10
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
80007d10:	fe ca ff e0 	sub	r10,pc,-32
80007d14:	13 cb       	ld.ub	r11,r9[0x4]
80007d16:	1a da       	st.w	--sp,r10
80007d18:	30 0a       	mov	r10,0
80007d1a:	1a da       	st.w	--sp,r10
80007d1c:	30 1a       	mov	r10,1
80007d1e:	f1 3c 00 12 	ld.ub	r12,r8[18]
80007d22:	13 d8       	ld.ub	r8,r9[0x5]
80007d24:	72 29       	ld.w	r9,r9[0x8]
80007d26:	fe b0 df 59 	rcall	80003bd8 <uhd_ep_run>
80007d2a:	2f ed       	sub	sp,-8
80007d2c:	d8 02       	popm	pc
80007d2e:	d7 03       	nop

80007d30 <uhi_hid_mouse_report_reception>:
80007d30:	d4 21       	pushm	r4-r7,lr
80007d32:	58 0a       	cp.w	r10,0
80007d34:	5f 18       	srne	r8
80007d36:	58 39       	cp.w	r9,3
{
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80007d38:	5f 89       	srls	r9
static void uhi_hid_mouse_report_reception(
		usb_add_t add,
		usb_ep_t ep,
		uhd_trans_status_t status,
		iram_size_t nb_transfered)
{
80007d3a:	18 96       	mov	r6,r12
	uint8_t state_prev;
	uint8_t state_new;
	UNUSED(ep);

	if ((status != UHD_TRANS_NOERROR) || (nb_transfered < 4)) {
80007d3c:	f3 e8 10 08 	or	r8,r9,r8
80007d40:	c2 d1       	brne	80007d9a <uhi_hid_mouse_report_reception+0x6a>
		return; // HID mouse transfer aborted
	}

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
80007d42:	e0 67 1c e8 	mov	r7,7400
	if ((state_prev & 0x01) != (state_new & 0x01)) {
80007d46:	6e 28       	ld.w	r8,r7[0x8]
80007d48:	ef 35 00 0c 	ld.ub	r5,r7[12]
80007d4c:	11 84       	ld.ub	r4,r8[0x0]
80007d4e:	e9 e5 20 05 	eor	r5,r4,r5
80007d52:	ed b5 00 00 	bld	r5,0x0
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
80007d56:	c3 40       	breq	80007dbe <uhi_hid_mouse_report_reception+0x8e>
80007d58:	ed b5 00 01 	bld	r5,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80007d5c:	c3 70       	breq	80007dca <uhi_hid_mouse_report_reception+0x9a>
80007d5e:	e2 15 00 04 	andl	r5,0x4,COH
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
80007d62:	c2 41       	brne	80007daa <uhi_hid_mouse_report_reception+0x7a>
80007d64:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80007d68:	6e 29       	ld.w	r9,r7[0x8]
80007d6a:	13 9c       	ld.ub	r12,r9[0x1]
80007d6c:	58 0c       	cp.w	r12,0
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
80007d6e:	c1 b1       	brne	80007da4 <uhi_hid_mouse_report_reception+0x74>
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80007d70:	13 ab       	ld.ub	r11,r9[0x2]
80007d72:	58 0b       	cp.w	r11,0
80007d74:	c1 40       	breq	80007d9c <uhi_hid_mouse_report_reception+0x6c>
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
		UHI_HID_MOUSE_EVENT_MOUVE(
80007d76:	13 ba       	ld.ub	r10,r9[0x3]
80007d78:	5c 6a       	casts.b	r10
80007d7a:	5c 6b       	casts.b	r11
80007d7c:	5c 6c       	casts.b	r12
80007d7e:	c6 df       	rcall	80007c58 <hid_mouse_move>
80007d80:	6e 29       	ld.w	r9,r7[0x8]
 * \param add   USB address to use
 */
static void uhi_hid_mouse_start_trans_report(usb_add_t add)
{
	// Start transfer on interrupt endpoint IN
	uhd_ep_run(add, uhi_hid_mouse_dev.ep_in, true, uhi_hid_mouse_dev.report,
80007d82:	fe c8 00 52 	sub	r8,pc,82
80007d86:	0f cb       	ld.ub	r11,r7[0x4]
80007d88:	1a d8       	st.w	--sp,r8
80007d8a:	30 08       	mov	r8,0
80007d8c:	0c 9c       	mov	r12,r6
80007d8e:	1a d8       	st.w	--sp,r8
80007d90:	30 1a       	mov	r10,1
80007d92:	0f d8       	ld.ub	r8,r7[0x5]
80007d94:	fe b0 df 22 	rcall	80003bd8 <uhd_ep_run>
80007d98:	2f ed       	sub	sp,-8
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_Y] != 0)
			|| (uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_SCROLL] != 0)) {
80007d9a:	d8 22       	popm	r4-r7,pc
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80007d9c:	13 ba       	ld.ub	r10,r9[0x3]
80007d9e:	58 0a       	cp.w	r10,0
80007da0:	cf 10       	breq	80007d82 <uhi_hid_mouse_report_reception+0x52>
80007da2:	ce bb       	rjmp	80007d78 <uhi_hid_mouse_report_reception+0x48>
80007da4:	13 ba       	ld.ub	r10,r9[0x3]
80007da6:	13 ab       	ld.ub	r11,r9[0x2]
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
		UHI_HID_MOUSE_EVENT_BTN_MIDDLE((state_new & 0x04) ? true : false);
80007da8:	ce 8b       	rjmp	80007d78 <uhi_hid_mouse_report_reception+0x48>
80007daa:	f9 d4 c0 41 	bfextu	r12,r4,0x2,0x1
80007dae:	c7 5f       	rcall	80007c98 <hid_mouse_btn_middle>
	}
	uhi_hid_mouse_dev.report_btn_prev = state_new;
80007db0:	ef 64 00 0c 	st.b	r7[12],r4

	// Decode moves
	if ((uhi_hid_mouse_dev.report[UHI_HID_MOUSE_MOV_X] != 0)
80007db4:	6e 29       	ld.w	r9,r7[0x8]
80007db6:	13 9c       	ld.ub	r12,r9[0x1]
80007db8:	58 0c       	cp.w	r12,0
80007dba:	cd b0       	breq	80007d70 <uhi_hid_mouse_report_reception+0x40>
80007dbc:	cf 4b       	rjmp	80007da4 <uhi_hid_mouse_report_reception+0x74>

	// Decode buttons
	state_prev = uhi_hid_mouse_dev.report_btn_prev;
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
80007dbe:	f9 d4 c0 01 	bfextu	r12,r4,0x0,0x1
80007dc2:	c8 3f       	rcall	80007cc8 <hid_mouse_btn_left>
80007dc4:	ed b5 00 01 	bld	r5,0x1
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
80007dc8:	cc b1       	brne	80007d5e <uhi_hid_mouse_report_reception+0x2e>
80007dca:	f9 d4 c0 21 	bfextu	r12,r4,0x1,0x1
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
80007dce:	e2 15 00 04 	andl	r5,0x4,COH
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80007dd2:	c6 ff       	rcall	80007cb0 <hid_mouse_btn_right>
	state_new = uhi_hid_mouse_dev.report[UHI_HID_MOUSE_BTN];
	if ((state_prev & 0x01) != (state_new & 0x01)) {
		UHI_HID_MOUSE_EVENT_BTN_LEFT((state_new & 0x01) ? true : false);
	}
	if ((state_prev & 0x02) != (state_new & 0x02)) {
		UHI_HID_MOUSE_EVENT_BTN_RIGHT((state_new & 0x02) ? true : false);
80007dd4:	58 05       	cp.w	r5,0
80007dd6:	cc 70       	breq	80007d64 <uhi_hid_mouse_report_reception+0x34>
	}
	if ((state_prev & 0x04) != (state_new & 0x04)) {
80007dd8:	ce 9b       	rjmp	80007daa <uhi_hid_mouse_report_reception+0x7a>
80007dda:	d7 03       	nop

80007ddc <uhi_hid_mouse_install>:
80007ddc:	d4 21       	pushm	r4-r7,lr
80007dde:	e0 66 1c e8 	mov	r6,7400
80007de2:	18 95       	mov	r5,r12
80007de4:	6c 09       	ld.w	r9,r6[0x0]
80007de6:	58 09       	cp.w	r9,0
80007de8:	c0 30       	breq	80007dee <uhi_hid_mouse_install+0x12>
80007dea:	30 5c       	mov	r12,5
80007dec:	d8 22       	popm	r4-r7,pc
80007dee:	78 67       	ld.w	r7,r12[0x18]
80007df0:	0f aa       	ld.ub	r10,r7[0x2]
80007df2:	0f b8       	ld.ub	r8,r7[0x3]
80007df4:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007df8:	5c c8       	swap.bh	r8
80007dfa:	5c 88       	casts.h	r8

	if (uhi_hid_mouse_dev.dev != NULL) {
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
80007dfc:	c2 80       	breq	80007e4c <uhi_hid_mouse_install+0x70>
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
80007dfe:	12 9c       	mov	r12,r9

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
80007e00:	30 4a       	mov	r10,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
80007e02:	30 3e       	mov	lr,3
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
		switch (ptr_iface->bDescriptorType) {
80007e04:	30 24       	mov	r4,2
80007e06:	30 5b       	mov	r11,5
80007e08:	c0 98       	rjmp	80007e1a <uhi_hid_mouse_install+0x3e>
80007e0a:	f6 09 18 00 	cp.b	r9,r11
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
80007e0e:	c1 00       	breq	80007e2e <uhi_hid_mouse_install+0x52>
80007e10:	0f 89       	ld.ub	r9,r7[0x0]
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80007e12:	12 18       	sub	r8,r9
		default:
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
80007e14:	12 07       	add	r7,r9
		return UHC_ENUM_SOFTWARE_LIMIT; // Device already allocated
	}
	conf_desc_lgt = le16_to_cpu(dev->conf_desc->wTotalLength);
	ptr_iface = (usb_iface_desc_t*)dev->conf_desc;
	b_iface_supported = false;
	while(conf_desc_lgt) {
80007e16:	5c 88       	casts.h	r8
		switch (ptr_iface->bDescriptorType) {
80007e18:	c1 a0       	breq	80007e4c <uhi_hid_mouse_install+0x70>
80007e1a:	0f 99       	ld.ub	r9,r7[0x1]
80007e1c:	f4 09 18 00 	cp.b	r9,r10

		case USB_DT_INTERFACE:
			if ((ptr_iface->bInterfaceClass   == HID_CLASS)
80007e20:	cf 51       	brne	80007e0a <uhi_hid_mouse_install+0x2e>
80007e22:	0f d9       	ld.ub	r9,r7[0x5]
80007e24:	fc 09 18 00 	cp.b	r9,lr
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
80007e28:	c0 d0       	breq	80007e42 <uhi_hid_mouse_install+0x66>
80007e2a:	30 0c       	mov	r12,0
			}
			break;

		case USB_DT_ENDPOINT:
			//  Allocation of the endpoint
			if (!b_iface_supported) {
80007e2c:	cf 2b       	rjmp	80007e10 <uhi_hid_mouse_install+0x34>
80007e2e:	58 0c       	cp.w	r12,0
				break;
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
80007e30:	cf 00       	breq	80007e10 <uhi_hid_mouse_install+0x34>
80007e32:	0e 9b       	mov	r11,r7
80007e34:	eb 3c 00 12 	ld.ub	r12,r5[18]
80007e38:	fe b0 e0 4e 	rcall	80003ed4 <uhd_ep_alloc>
80007e3c:	c0 91       	brne	80007e4e <uhi_hid_mouse_install+0x72>
80007e3e:	30 4c       	mov	r12,4
/**
 * \name Functions required by UHC
 * @{
 */

uhc_enum_status_t uhi_hid_mouse_install(uhc_device_t* dev)
80007e40:	d8 22       	popm	r4-r7,pc
80007e42:	0f f9       	ld.ub	r9,r7[0x7]
80007e44:	e8 09 18 00 	cp.b	r9,r4
80007e48:	5f 0c       	sreq	r12
			// Ignore descriptor
			break;
		}
		Assert(conf_desc_lgt>=ptr_iface->bLength);
		conf_desc_lgt -= ptr_iface->bLength;
		ptr_iface = (usb_iface_desc_t*)((uint8_t*)ptr_iface + ptr_iface->bLength);
80007e4a:	ce 3b       	rjmp	80007e10 <uhi_hid_mouse_install+0x34>
			}
			if (!uhd_ep_alloc(dev->address, (usb_ep_desc_t*)ptr_iface)) {
				return UHC_ENUM_HARDWARE_LIMIT; // Endpoint allocation fail
			}
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
80007e4c:	da 2a       	popm	r4-r7,pc,r12=1
80007e4e:	0f a8       	ld.ub	r8,r7[0x2]
			uhi_hid_mouse_dev.report_size =
80007e50:	ac c8       	st.b	r6[0x4],r8
80007e52:	0f cc       	ld.ub	r12,r7[0x4]
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
80007e54:	ac dc       	st.b	r6[0x5],r12
80007e56:	e0 a0 12 7d 	rcall	8000a350 <malloc>
			if (uhi_hid_mouse_dev.report == NULL) {
80007e5a:	8d 2c       	st.w	r6[0x8],r12
				Assert(false);
				return UHC_ENUM_MEMORY_LIMIT; // Internal RAM allocation fail
			}
			uhi_hid_mouse_dev.dev = dev;
80007e5c:	c0 60       	breq	80007e68 <uhi_hid_mouse_install+0x8c>
80007e5e:	e0 68 1c e8 	mov	r8,7400
			// All endpoints of all interfaces supported allocated
			return UHC_ENUM_SUCCESS;
80007e62:	30 0c       	mov	r12,0
			Assert(((usb_ep_desc_t*)ptr_iface)->bEndpointAddress & USB_EP_DIR_IN);
			uhi_hid_mouse_dev.ep_in = ((usb_ep_desc_t*)ptr_iface)->bEndpointAddress;
			uhi_hid_mouse_dev.report_size =
					le16_to_cpu(((usb_ep_desc_t*)ptr_iface)->wMaxPacketSize);
			uhi_hid_mouse_dev.report = malloc(uhi_hid_mouse_dev.report_size);
			if (uhi_hid_mouse_dev.report == NULL) {
80007e64:	91 05       	st.w	r8[0x0],r5
80007e66:	d8 22       	popm	r4-r7,pc
80007e68:	30 6c       	mov	r12,6
80007e6a:	d8 22       	popm	r4-r7,pc

80007e6c <fatfs_lba_of_cluster>:
// fatfs_lba_of_cluster: This function converts a cluster number into a sector / 
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
80007e6c:	78 c8       	ld.w	r8,r12[0x30]
80007e6e:	58 08       	cp.w	r8,0
80007e70:	c0 80       	breq	80007e80 <fatfs_lba_of_cluster+0x14>
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
    else
        return ((fs->cluster_begin_lba + ((Cluster_Number-2)*fs->sectors_per_cluster)));
80007e72:	78 18       	ld.w	r8,r12[0x4]
80007e74:	20 2b       	sub	r11,2
80007e76:	19 89       	ld.ub	r9,r12[0x0]
80007e78:	f6 09 02 4c 	mul	r12,r11,r9
80007e7c:	10 0c       	add	r12,r8
}
80007e7e:	5e fc       	retal	r12
// LBA number.
//-----------------------------------------------------------------------------
uint32 fatfs_lba_of_cluster(struct fatfs *fs, uint32 Cluster_Number)
{
    if (fs->fat_type == FAT_TYPE_16)
        return (fs->cluster_begin_lba + (fs->root_entry_count * 32 / FAT_SECTOR_SIZE) + ((Cluster_Number-2) * fs->sectors_per_cluster));
80007e80:	19 88       	ld.ub	r8,r12[0x0]
80007e82:	f9 19 00 28 	ld.uh	r9,r12[40]
80007e86:	20 2b       	sub	r11,2
80007e88:	a5 49       	asr	r9,0x4
80007e8a:	b1 3b       	mul	r11,r8
80007e8c:	78 18       	ld.w	r8,r12[0x4]
80007e8e:	f2 08 00 0c 	add	r12,r9,r8
80007e92:	16 0c       	add	r12,r11
80007e94:	5e fc       	retal	r12

80007e96 <fatfs_sector_read>:
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
80007e96:	d4 01       	pushm	lr
80007e98:	16 9e       	mov	lr,r11
    return fs->disk_io.read_media(lba, target, count);
80007e9a:	78 d8       	ld.w	r8,r12[0x34]
}
//-----------------------------------------------------------------------------
// fatfs_sector_read: 
//-----------------------------------------------------------------------------
int fatfs_sector_read(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
80007e9c:	14 9b       	mov	r11,r10
    return fs->disk_io.read_media(lba, target, count);
80007e9e:	1c 9c       	mov	r12,lr
80007ea0:	12 9a       	mov	r10,r9
80007ea2:	5d 18       	icall	r8
}
80007ea4:	d8 02       	popm	pc

80007ea6 <fatfs_sector_write>:
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
80007ea6:	d4 01       	pushm	lr
80007ea8:	16 9e       	mov	lr,r11
    return fs->disk_io.write_media(lba, target, count);
80007eaa:	78 e8       	ld.w	r8,r12[0x38]
}
//-----------------------------------------------------------------------------
// fatfs_sector_write: 
//-----------------------------------------------------------------------------
int fatfs_sector_write(struct fatfs *fs, uint32 lba, uint8 *target, uint32 count)
{
80007eac:	14 9b       	mov	r11,r10
    return fs->disk_io.write_media(lba, target, count);
80007eae:	1c 9c       	mov	r12,lr
80007eb0:	12 9a       	mov	r10,r9
80007eb2:	5d 18       	icall	r8
}
80007eb4:	d8 02       	popm	pc
80007eb6:	d7 03       	nop

80007eb8 <fatfs_write_sector>:
// fatfs_write_sector: Write to the provided cluster and sector offset
// Returns True if success, returns False if not 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_write_sector(struct fatfs *fs, uint32 cluster, uint32 sector, uint8 *target)
{
80007eb8:	eb cd 40 c0 	pushm	r6-r7,lr
80007ebc:	20 2d       	sub	sp,8
80007ebe:	18 96       	mov	r6,r12
    // No write access?
    if (!fs->disk_io.write_media)
80007ec0:	78 e7       	ld.w	r7,r12[0x38]
80007ec2:	58 07       	cp.w	r7,0
80007ec4:	c2 80       	breq	80007f14 <fatfs_write_sector+0x5c>
        return 0;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && cluster == 0)
80007ec6:	58 0b       	cp.w	r11,0
80007ec8:	5f 0e       	sreq	lr
80007eca:	78 c8       	ld.w	r8,r12[0x30]
80007ecc:	58 08       	cp.w	r8,0
80007ece:	5f 08       	sreq	r8
80007ed0:	fd e8 00 08 	and	r8,lr,r8
80007ed4:	c0 f1       	brne	80007ef2 <fatfs_write_sector+0x3a>
    }
    // FAT16/32 Other
    else
    {
        // User target buffer passed in
        if (target)
80007ed6:	58 09       	cp.w	r9,0
80007ed8:	c2 10       	breq	80007f1a <fatfs_write_sector+0x62>
        {
            // Calculate write address
            uint32 lba = fatfs_lba_of_cluster(fs, cluster) + sector;
80007eda:	50 0a       	stdsp	sp[0x0],r10
80007edc:	50 19       	stdsp	sp[0x4],r9
80007ede:	cc 7f       	rcall	80007e6c <fatfs_lba_of_cluster>
80007ee0:	40 0a       	lddsp	r10,sp[0x0]

            // Write to disk
            return fs->disk_io.write_media(lba, target, 1);
80007ee2:	40 19       	lddsp	r9,sp[0x4]
80007ee4:	14 0c       	add	r12,r10
80007ee6:	12 9b       	mov	r11,r9
80007ee8:	30 1a       	mov	r10,1
80007eea:	5d 17       	icall	r7
80007eec:	2f ed       	sub	sp,-8

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
        }
    }
}
80007eee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007ef2:	78 48       	ld.w	r8,r12[0x10]
    if (fs->fat_type == FAT_TYPE_16 && cluster == 0)
    {
        uint32 lba;

        // In FAT16 we cannot extend the root dir!
        if (sector < fs->rootdir_sectors)
80007ef4:	14 38       	cp.w	r8,r10
80007ef6:	e0 88 00 0f 	brls	80007f14 <fatfs_write_sector+0x5c>
80007efa:	78 3c       	ld.w	r12,r12[0xc]
            lba = fs->lba_begin + fs->rootdir_first_sector + sector;
80007efc:	6c 78       	ld.w	r8,r6[0x1c]
80007efe:	10 0c       	add	r12,r8
80007f00:	14 0c       	add	r12,r10
80007f02:	58 09       	cp.w	r9,0
        else
            return 0;

        // User target buffer passed in
        if (target)
80007f04:	cf 11       	brne	80007ee6 <fatfs_write_sector+0x2e>
80007f06:	ed 4c 02 44 	st.w	r6[580],r12
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = lba;
80007f0a:	ec cb ff bc 	sub	r11,r6,-68

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007f0e:	30 1a       	mov	r10,1
80007f10:	5d 17       	icall	r7
80007f12:	ce db       	rjmp	80007eec <fatfs_write_sector+0x34>
80007f14:	2f ed       	sub	sp,-8
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007f16:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80007f1a:	50 0a       	stdsp	sp[0x0],r10
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
80007f1c:	ca 8f       	rcall	80007e6c <fatfs_lba_of_cluster>
80007f1e:	40 0a       	lddsp	r10,sp[0x0]
80007f20:	ec cb ff bc 	sub	r11,r6,-68

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007f24:	14 0c       	add	r12,r10
80007f26:	30 1a       	mov	r10,1
            return fs->disk_io.write_media(lba, target, 1);
        }
        else
        {
            // Calculate write address
            fs->currentsector.address = fatfs_lba_of_cluster(fs, cluster)+sector;
80007f28:	ed 4c 02 44 	st.w	r6[580],r12
80007f2c:	5d 17       	icall	r7
80007f2e:	cd fb       	rjmp	80007eec <fatfs_write_sector+0x34>

80007f30 <fatfs_get_root_cluster>:

            // Write to disk
            return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007f30:	78 2c       	ld.w	r12,r12[0x8]
80007f32:	5e fc       	retal	r12

80007f34 <fatfs_sector_reader>:
80007f34:	eb cd 40 fc 	pushm	r2-r7,lr
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
80007f38:	58 0b       	cp.w	r11,0
80007f3a:	5f 08       	sreq	r8
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
80007f3c:	12 93       	mov	r3,r9
80007f3e:	18 97       	mov	r7,r12
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
80007f40:	78 c9       	ld.w	r9,r12[0x30]
//-----------------------------------------------------------------------------
// fatfs_sector_reader: From the provided startcluster and sector offset
// Returns True if success, returns False if not (including if read out of range)
//-----------------------------------------------------------------------------
int fatfs_sector_reader(struct fatfs *fs, uint32 start_cluster, uint32 offset, uint8 *target)
{
80007f42:	14 96       	mov	r6,r10
    uint32 cluster_chain = 0;
    uint32 i;
    uint32 lba;

    // FAT16 Root directory
    if (fs->fat_type == FAT_TYPE_16 && start_cluster == 0)
80007f44:	58 09       	cp.w	r9,0
80007f46:	5f 09       	sreq	r9
80007f48:	12 68       	and	r8,r9
80007f4a:	c1 80       	breq	80007f7a <fatfs_sector_reader+0x46>
    {
        if (offset < fs->rootdir_sectors)
80007f4c:	78 48       	ld.w	r8,r12[0x10]
80007f4e:	14 38       	cp.w	r8,r10
80007f50:	e0 88 00 34 	brls	80007fb8 <fatfs_sector_reader+0x84>
            lba = fs->lba_begin + fs->rootdir_first_sector + offset;
80007f54:	78 3c       	ld.w	r12,r12[0xc]
80007f56:	6e 78       	ld.w	r8,r7[0x1c]
80007f58:	10 0c       	add	r12,r8
80007f5a:	14 0c       	add	r12,r10
        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
    }

    // User provided target array
    if (target)
80007f5c:	58 03       	cp.w	r3,0
80007f5e:	c2 71       	brne	80007fac <fatfs_sector_reader+0x78>
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
80007f60:	ee f8 02 44 	ld.w	r8,r7[580]
80007f64:	18 38       	cp.w	r8,r12
80007f66:	c2 b0       	breq	80007fbc <fatfs_sector_reader+0x88>
    {
        fs->currentsector.address = lba;
80007f68:	ef 4c 02 44 	st.w	r7[580],r12
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007f6c:	ee cb ff bc 	sub	r11,r7,-68
80007f70:	6e d8       	ld.w	r8,r7[0x34]
80007f72:	30 1a       	mov	r10,1
80007f74:	5d 18       	icall	r8
80007f76:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
    {
        // Set start of cluster chain to initial value
        cluster_chain = start_cluster;

        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
80007f7a:	19 82       	ld.ub	r2,r12[0x0]
80007f7c:	f4 02 0d 08 	divu	r8,r10,r2
80007f80:	10 94       	mov	r4,r8
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
80007f82:	58 08       	cp.w	r8,0
80007f84:	c0 a0       	breq	80007f98 <fatfs_sector_reader+0x64>
80007f86:	30 05       	mov	r5,0
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
80007f88:	0e 9c       	mov	r12,r7
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
80007f8a:	2f f5       	sub	r5,-1
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);
80007f8c:	e0 a0 0d 2c 	rcall	800099e4 <fatfs_find_next_cluster>
80007f90:	18 9b       	mov	r11,r12
        // Find parameters
        cluster_to_read = offset / fs->sectors_per_cluster;      
        sector_to_read = offset - (cluster_to_read*fs->sectors_per_cluster);

        // Follow chain to find cluster to read
        for (i=0; i<cluster_to_read; i++)
80007f92:	0a 34       	cp.w	r4,r5
80007f94:	fe 9b ff fa 	brhi	80007f88 <fatfs_sector_reader+0x54>
            cluster_chain = fatfs_find_next_cluster(fs, cluster_chain);

        // If end of cluster chain then return false
        if (cluster_chain == FAT32_LAST_CLUSTER) 
80007f98:	5b fb       	cp.w	r11,-1
80007f9a:	c0 f0       	breq	80007fb8 <fatfs_sector_reader+0x84>
            return 0;

        // Calculate sector address
        lba = fatfs_lba_of_cluster(fs, cluster_chain)+sector_to_read;
80007f9c:	0e 9c       	mov	r12,r7
80007f9e:	a5 34       	mul	r4,r2
80007fa0:	c6 6f       	rcall	80007e6c <fatfs_lba_of_cluster>
80007fa2:	08 16       	sub	r6,r4
80007fa4:	ec 0c 00 0c 	add	r12,r6,r12
80007fa8:	58 03       	cp.w	r3,0
    }

    // User provided target array
    if (target)
80007faa:	cd b0       	breq	80007f60 <fatfs_sector_reader+0x2c>
80007fac:	6e d8       	ld.w	r8,r7[0x34]
        return fs->disk_io.read_media(lba, target, 1);
80007fae:	06 9b       	mov	r11,r3
80007fb0:	30 1a       	mov	r10,1
80007fb2:	5d 18       	icall	r8
80007fb4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007fb8:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
    {
        fs->currentsector.address = lba;
        return fs->disk_io.read_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007fbc:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

80007fc0 <fatfs_update_file_length>:

    // User provided target array
    if (target)
        return fs->disk_io.read_media(lba, target, 1);
    // Else read sector if not already loaded
    else if (lba != fs->currentsector.address)
80007fc0:	d4 31       	pushm	r0-r7,lr
80007fc2:	18 95       	mov	r5,r12
80007fc4:	16 94       	mov	r4,r11
80007fc6:	14 91       	mov	r1,r10
80007fc8:	12 90       	mov	r0,r9
80007fca:	78 e8       	ld.w	r8,r12[0x38]
    uint16 recordoffset = 0;
    int x=0;
    struct fat_dir_entry *directoryEntry;

    // No write access?
    if (!fs->disk_io.write_media)
80007fcc:	58 08       	cp.w	r8,0
80007fce:	c4 c0       	breq	80008066 <fatfs_update_file_length+0xa6>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
80007fd0:	f8 c7 ff bc 	sub	r7,r12,-68
80007fd4:	30 06       	mov	r6,0
80007fd6:	0c 9a       	mov	r10,r6

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
80007fd8:	30 09       	mov	r9,0
80007fda:	2f f6       	sub	r6,-1
80007fdc:	08 9b       	mov	r11,r4
80007fde:	0a 9c       	mov	r12,r5
80007fe0:	ca af       	rcall	80007f34 <fatfs_sector_reader>
80007fe2:	c4 20       	breq	80008066 <fatfs_update_file_length+0xa6>
80007fe4:	30 03       	mov	r3,0
80007fe6:	c0 48       	rjmp	80007fee <fatfs_update_file_length+0x2e>
80007fe8:	e0 43 02 00 	cp.w	r3,512
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80007fec:	cf 50       	breq	80007fd6 <fatfs_update_file_length+0x16>
80007fee:	ee 03 00 02 	add	r2,r7,r3

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
80007ff2:	2e 03       	sub	r3,-32

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80007ff4:	04 9c       	mov	r12,r2
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
80007ff6:	e0 a0 08 85 	rcall	80009100 <fatfs_entry_lfn_text>
80007ffa:	cf 71       	brne	80007fe8 <fatfs_update_file_length+0x28>
80007ffc:	04 9c       	mov	r12,r2
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
80007ffe:	e0 a0 08 88 	rcall	8000910e <fatfs_entry_lfn_invalid>
80008002:	cf 31       	brne	80007fe8 <fatfs_update_file_length+0x28>
80008004:	04 9c       	mov	r12,r2
                    ;

                // Normal Entry, only 8.3 Text         
                else
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
80008006:	e0 a0 08 b8 	rcall	80009176 <fatfs_entry_sfn_only>
8000800a:	ce f0       	breq	80007fe8 <fatfs_update_file_length+0x28>
8000800c:	30 ba       	mov	r10,11
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
8000800e:	02 9b       	mov	r11,r1
80008010:	04 9c       	mov	r12,r2
80008012:	e0 a0 14 82 	rcall	8000a916 <strncmp>
80008016:	ce 91       	brne	80007fe8 <fatfs_update_file_length+0x28>
80008018:	00 99       	mov	r9,r0
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000801a:	e6 19 00 ff 	andh	r9,0xff,COH
8000801e:	e0 08 15 18 	lsl	r8,r0,0x18
80008022:	f1 e0 13 88 	or	r8,r8,r0>>0x18
80008026:	e2 10 ff 00 	andl	r0,0xff00,COH
8000802a:	f1 e0 10 88 	or	r8,r8,r0<<0x8
8000802e:	f1 e9 12 88 	or	r8,r8,r9>>0x8
80008032:	f0 09 16 18 	lsr	r9,r8,0x18
80008036:	e5 68 00 1f 	st.b	r2[31],r8
8000803a:	e5 69 00 1c 	st.b	r2[28],r9
8000803e:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80008042:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80008046:	04 9b       	mov	r11,r2
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
80008048:	e5 68 00 1e 	st.b	r2[30],r8
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
8000804c:	32 0a       	mov	r10,32
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
8000804e:	04 9c       	mov	r12,r2
80008050:	e5 69 00 1d 	st.b	r2[29],r9
#endif
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
                    {
                        directoryEntry->FileSize = FAT_HTONL(fileLength);
80008054:	e0 a0 13 98 	rcall	8000a784 <memcpy>
                        // TODO: Update last write time

                        // Update sfn entry
                        memcpy((uint8*)(fs->currentsector.sector+recordoffset), (uint8*)directoryEntry, sizeof(struct fat_dir_entry));                    
80008058:	0e 9b       	mov	r11,r7

                        // Write sector back
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
8000805a:	ea fc 02 44 	ld.w	r12,r5[580]
8000805e:	6a e8       	ld.w	r8,r5[0x38]
80008060:	30 1a       	mov	r10,1
80008062:	5d 18       	icall	r8
80008064:	d8 32       	popm	r0-r7,pc
80008066:	d8 3a       	popm	r0-r7,pc,r12=0

80008068 <fatfs_sfn_exists>:
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80008068:	eb cd 40 fe 	pushm	r1-r7,lr
8000806c:	30 06       	mov	r6,0
8000806e:	18 95       	mov	r5,r12
80008070:	16 94       	mov	r4,r11
80008072:	14 91       	mov	r1,r10
80008074:	f8 c3 ff bc 	sub	r3,r12,-68
80008078:	f8 c7 fd bc 	sub	r7,r12,-580
8000807c:	0c 9a       	mov	r10,r6
8000807e:	30 09       	mov	r9,0
80008080:	2f f6       	sub	r6,-1
80008082:	08 9b       	mov	r11,r4

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
80008084:	0a 9c       	mov	r12,r5
80008086:	c5 7f       	rcall	80007f34 <fatfs_sector_reader>
80008088:	c1 90       	breq	800080ba <fatfs_sfn_exists+0x52>
8000808a:	06 92       	mov	r2,r3
8000808c:	c0 48       	rjmp	80008094 <fatfs_sfn_exists+0x2c>
8000808e:	2e 02       	sub	r2,-32
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
80008090:	0e 32       	cp.w	r2,r7
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80008092:	cf 50       	breq	8000807c <fatfs_sfn_exists+0x14>
80008094:	04 9c       	mov	r12,r2
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
80008096:	e0 a0 08 35 	rcall	80009100 <fatfs_entry_lfn_text>
8000809a:	cf a1       	brne	8000808e <fatfs_sfn_exists+0x26>
8000809c:	04 9c       	mov	r12,r2
                    ;

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000809e:	e0 a0 08 38 	rcall	8000910e <fatfs_entry_lfn_invalid>
800080a2:	cf 61       	brne	8000808e <fatfs_sfn_exists+0x26>
800080a4:	04 9c       	mov	r12,r2
                    ;
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
800080a6:	e0 a0 08 68 	rcall	80009176 <fatfs_entry_sfn_only>
800080aa:	cf 20       	breq	8000808e <fatfs_sfn_exists+0x26>
800080ac:	04 9c       	mov	r12,r2
                {
                    if (strncmp((const char*)directoryEntry->Name, shortname, 11)==0)
800080ae:	30 ba       	mov	r10,11
800080b0:	02 9b       	mov	r11,r1
800080b2:	e0 a0 14 32 	rcall	8000a916 <strncmp>
800080b6:	ce c1       	brne	8000808e <fatfs_sfn_exists+0x26>
800080b8:	30 1c       	mov	r12,1
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
800080ba:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
        else
            break;
    } // End of while loop

    return 0;
}
800080be:	d7 03       	nop

800080c0 <fatfs_get_file_entry>:
800080c0:	d4 31       	pushm	r0-r7,lr
800080c2:	fa cd 01 2c 	sub	sp,sp,300
800080c6:	18 95       	mov	r5,r12
800080c8:	50 3b       	stdsp	sp[0xc],r11
800080ca:	fa c7 ff ea 	sub	r7,sp,-22
800080ce:	30 1b       	mov	r11,1
800080d0:	50 2a       	stdsp	sp[0x8],r10
800080d2:	50 49       	stdsp	sp[0x10],r9
    char short_filename[13];
    struct lfn_cache lfn;
    int dotRequired = 0;
    struct fat_dir_entry *directoryEntry;

    fatfs_lfn_cache_init(&lfn, 1);
800080d4:	0e 9c       	mov	r12,r7
800080d6:	e0 a0 08 d0 	rcall	80009276 <fatfs_lfn_cache_init>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
800080da:	30 0b       	mov	r11,0
800080dc:	ea c6 ff bc 	sub	r6,r5,-68
800080e0:	50 1b       	stdsp	sp[0x4],r11
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    memset(short_filename, 0, sizeof(short_filename));
800080e2:	fa c4 fe e4 	sub	r4,sp,-284
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
800080e6:	40 1a       	lddsp	r10,sp[0x4]

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
800080e8:	14 98       	mov	r8,r10
800080ea:	2f f8       	sub	r8,-1
800080ec:	30 09       	mov	r9,0
800080ee:	50 18       	stdsp	sp[0x4],r8
800080f0:	40 3b       	lddsp	r11,sp[0xc]
800080f2:	0a 9c       	mov	r12,r5
800080f4:	c2 0f       	rcall	80007f34 <fatfs_sector_reader>
800080f6:	e0 80 00 85 	breq	80008200 <fatfs_get_file_entry+0x140>
800080fa:	ec c1 ff f6 	sub	r1,r6,-10
800080fe:	30 03       	mov	r3,0
80008100:	32 00       	mov	r0,32
                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
                        if (directoryEntry->Name[i] != ' ')
80008102:	c0 d8       	rjmp	8000811c <fatfs_get_file_entry+0x5c>
80008104:	e6 cb ff bc 	sub	r11,r3,-68
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);
80008108:	0e 9c       	mov	r12,r7
8000810a:	ea 0b 00 0b 	add	r11,r5,r11
8000810e:	e0 a0 07 8d 	rcall	80009028 <fatfs_lfn_cache_entry>
80008112:	2e 03       	sub	r3,-32
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
80008114:	2e 01       	sub	r1,-32
80008116:	e0 43 02 00 	cp.w	r3,512
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
8000811a:	ce 60       	breq	800080e6 <fatfs_get_file_entry+0x26>
8000811c:	ec 03 00 02 	add	r2,r6,r3

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, Cluster, x++, 0)) // If sector read was successfull
80008120:	04 9c       	mov	r12,r2
                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

#if FATFS_INC_LFN_SUPPORT
                // Long File Name Text Found
                if (fatfs_entry_lfn_text(directoryEntry) ) 
80008122:	e0 a0 07 ef 	rcall	80009100 <fatfs_entry_lfn_text>
80008126:	18 9b       	mov	r11,r12
80008128:	ce e1       	brne	80008104 <fatfs_get_file_entry+0x44>
8000812a:	50 0b       	stdsp	sp[0x0],r11
                    fatfs_lfn_cache_entry(&lfn, fs->currentsector.sector+recordoffset);

                // If Invalid record found delete any long file name information collated
                else if (fatfs_entry_lfn_invalid(directoryEntry) ) 
8000812c:	04 9c       	mov	r12,r2
8000812e:	e0 a0 07 f0 	rcall	8000910e <fatfs_entry_lfn_invalid>
80008132:	40 0b       	lddsp	r11,sp[0x0]
80008134:	c4 e1       	brne	800081d0 <fatfs_get_file_entry+0x110>
80008136:	04 9b       	mov	r11,r2
                    fatfs_lfn_cache_init(&lfn, 0);

                // Normal SFN Entry and Long text exists 
                else if (fatfs_entry_lfn_exists(&lfn, directoryEntry) ) 
80008138:	0e 9c       	mov	r12,r7
8000813a:	e0 a0 08 03 	rcall	80009140 <fatfs_entry_lfn_exists>
8000813e:	18 98       	mov	r8,r12
80008140:	c0 d0       	breq	8000815a <fatfs_get_file_entry+0x9a>
80008142:	0e 9c       	mov	r12,r7
                {
                    long_filename = fatfs_lfn_cache_get(&lfn);
80008144:	e0 a0 07 c7 	rcall	800090d2 <fatfs_lfn_cache_get>
80008148:	40 2b       	lddsp	r11,sp[0x8]

                    // Compare names to see if they match
                    if (fatfs_compare_names(long_filename, name_to_find)) 
8000814a:	e0 a0 0a 41 	rcall	800095cc <fatfs_compare_names>
8000814e:	c5 31       	brne	800081f4 <fatfs_get_file_entry+0x134>
80008150:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
80008152:	0e 9c       	mov	r12,r7
80008154:	e0 a0 08 91 	rcall	80009276 <fatfs_lfn_cache_init>
80008158:	cd db       	rjmp	80008112 <fatfs_get_file_entry+0x52>
8000815a:	50 08       	stdsp	sp[0x0],r8
                }                 
                else 
#endif
                // Normal Entry, only 8.3 Text    
                if (fatfs_entry_sfn_only(directoryEntry) )
8000815c:	04 9c       	mov	r12,r2
8000815e:	e0 a0 08 0c 	rcall	80009176 <fatfs_entry_sfn_only>
80008162:	40 08       	lddsp	r8,sp[0x0]
80008164:	cd 70       	breq	80008112 <fatfs_get_file_entry+0x52>
80008166:	30 0a       	mov	r10,0
                {
                    memset(short_filename, 0, sizeof(short_filename));
80008168:	30 0b       	mov	r11,0
8000816a:	54 98       	stdsp	sp[0x124],r8
8000816c:	e8 eb 00 00 	st.d	r4[0],r10
80008170:	fb 68 01 28 	st.b	sp[296],r8
80008174:	e4 08 07 09 	ld.ub	r9,r2[r8]

                    // Copy name to string
                    for (i=0; i<8; i++) 
                        short_filename[i] = directoryEntry->Name[i];
80008178:	e8 08 0b 09 	st.b	r4[r8],r9
8000817c:	2f f8       	sub	r8,-1
8000817e:	58 88       	cp.w	r8,8
                if (fatfs_entry_sfn_only(directoryEntry) )
                {
                    memset(short_filename, 0, sizeof(short_filename));

                    // Copy name to string
                    for (i=0; i<8; i++) 
80008180:	cf a1       	brne	80008174 <fatfs_get_file_entry+0xb4>
80008182:	e3 38 ff fe 	ld.ub	r8,r1[-2]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
80008186:	fb 68 01 25 	st.b	sp[293],r8
8000818a:	e3 38 ff ff 	ld.ub	r8,r1[-1]
8000818e:	e3 39 ff fe 	ld.ub	r9,r1[-2]
                        if (directoryEntry->Name[i] != ' ')
80008192:	fb 68 01 26 	st.b	sp[294],r8

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
80008196:	e3 38 ff ff 	ld.ub	r8,r1[-1]
                        if (directoryEntry->Name[i] != ' ')
8000819a:	e0 08 18 00 	cp.b	r8,r0
8000819e:	c1 d0       	breq	800081d8 <fatfs_get_file_entry+0x118>
800081a0:	03 88       	ld.ub	r8,r1[0x0]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
800081a2:	fb 68 01 27 	st.b	sp[295],r8
800081a6:	30 1a       	mov	r10,1
                        if (directoryEntry->Name[i] != ' ')
800081a8:	e0 08 18 00 	cp.b	r8,r0
800081ac:	c1 f0       	breq	800081ea <fatfs_get_file_entry+0x12a>
800081ae:	fb 38 01 1c 	ld.ub	r8,sp[284]

                    // Dot only required if extension present
                    if (dotRequired)
                    {
                        // If not . or .. entry
                        if (short_filename[0]!='.')
800081b2:	32 ea       	mov	r10,46
                            short_filename[8] = '.';
800081b4:	f4 08 18 00 	cp.b	r8,r10
800081b8:	e0 09 17 00 	moveq	r9,r0
800081bc:	f4 09 17 10 	movne	r9,r10
800081c0:	fb 69 01 24 	st.b	sp[292],r9
800081c4:	40 2b       	lddsp	r11,sp[0x8]
                    }
                    else
                        short_filename[8] = ' ';
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
800081c6:	08 9c       	mov	r12,r4
800081c8:	e0 a0 0a 02 	rcall	800095cc <fatfs_compare_names>
800081cc:	c1 41       	brne	800081f4 <fatfs_get_file_entry+0x134>
800081ce:	18 9b       	mov	r11,r12
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
                        return 1;
                    }

                    fatfs_lfn_cache_init(&lfn, 0);
800081d0:	0e 9c       	mov	r12,r7
800081d2:	e0 a0 08 52 	rcall	80009276 <fatfs_lfn_cache_init>
800081d6:	c9 eb       	rjmp	80008112 <fatfs_get_file_entry+0x52>
800081d8:	03 88       	ld.ub	r8,r1[0x0]

                    // Extension
                    dotRequired = 0;
                    for (i=8; i<11; i++) 
                    {
                        short_filename[i+1] = directoryEntry->Name[i];
800081da:	fb 68 01 27 	st.b	sp[295],r8
800081de:	e0 09 18 00 	cp.b	r9,r0
                        if (directoryEntry->Name[i] != ' ')
800081e2:	5f 1a       	srne	r10
800081e4:	e0 08 18 00 	cp.b	r8,r0
800081e8:	ce 31       	brne	800081ae <fatfs_get_file_entry+0xee>
800081ea:	58 0a       	cp.w	r10,0
                            dotRequired = 1;
                    }

                    // Dot only required if extension present
                    if (dotRequired)
800081ec:	ce 11       	brne	800081ae <fatfs_get_file_entry+0xee>
800081ee:	fb 68 01 24 	st.b	sp[292],r8
                            short_filename[8] = '.';
                        else
                            short_filename[8] = ' ';
                    }
                    else
                        short_filename[8] = ' ';
800081f2:	ce 9b       	rjmp	800081c4 <fatfs_get_file_entry+0x104>
800081f4:	04 9b       	mov	r11,r2
                    
                    // Compare names to see if they match
                    if (fatfs_compare_names(short_filename, name_to_find)) 
                    {
                        memcpy(sfEntry,directoryEntry,sizeof(struct fat_dir_entry));
800081f6:	40 4c       	lddsp	r12,sp[0x10]
800081f8:	32 0a       	mov	r10,32
800081fa:	e0 a0 12 c5 	rcall	8000a784 <memcpy>
800081fe:	30 1c       	mov	r12,1
80008200:	2b 5d       	sub	sp,-300
        else
            break;
    } // End of while loop

    return 0;
}
80008202:	d8 32       	popm	r0-r7,pc

80008204 <fatfs_init>:
80008204:	eb cd 40 f8 	pushm	r3-r7,lr
80008208:	3f f8       	mov	r8,-1
8000820a:	18 97       	mov	r7,r12
8000820c:	30 06       	mov	r6,0
8000820e:	f9 48 02 44 	st.w	r12[580],r8
80008212:	f9 46 02 48 	st.w	r12[584],r6
80008216:	99 96       	st.w	r12[0x24],r6
80008218:	e0 a0 0d 32 	rcall	80009c7c <fatfs_fat_init>
8000821c:	6e d8       	ld.w	r8,r7[0x34]
8000821e:	58 08       	cp.w	r8,0
80008220:	c0 31       	brne	80008226 <fatfs_init+0x22>
80008222:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1
80008226:	0c 9c       	mov	r12,r6
80008228:	30 1a       	mov	r10,1
8000822a:	ee c6 ff bc 	sub	r6,r7,-68
8000822e:	0c 9b       	mov	r11,r6

    // MBR: Sector 0 on the disk
    // NOTE: Some removeable media does not have this.

    // Load MBR (LBA 0) into the 512 byte buffer
    if (!fs->disk_io.read_media(0, fs->currentsector.sector, 1))
80008230:	5d 18       	icall	r8
80008232:	cf 80       	breq	80008222 <fatfs_init+0x1e>
    ///////////////////


    // Make Sure 0x55 and 0xAA are at end of sector
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
80008234:	ef 18 02 42 	ld.uh	r8,r7[578]
80008238:	e0 48 55 aa 	cp.w	r8,21930
8000823c:	c0 40       	breq	80008244 <fatfs_init+0x40>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
8000823e:	3f dc       	mov	r12,-3
80008240:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // (this should be the case regardless of the MBR or boot sector)
    if (fs->currentsector.sector[SIGNATURE_POSITION] != 0x55 || fs->currentsector.sector[SIGNATURE_POSITION+1] != 0xAA)
        return FAT_INIT_INVALID_SIGNATURE;

    // Now check again using the access function to prove endian conversion function
    if (GET_16BIT_WORD(fs->currentsector.sector, SIGNATURE_POSITION) != SIGNATURE_VALUE) 
80008244:	ef 39 02 43 	ld.ub	r9,r7[579]
80008248:	ef 38 02 42 	ld.ub	r8,r7[578]
8000824c:	a9 69       	lsl	r9,0x8
8000824e:	f2 08 00 08 	add	r8,r9,r8
80008252:	e0 48 aa 55 	cp.w	r8,43605
80008256:	c0 40       	breq	8000825e <fatfs_init+0x5a>
80008258:	3f cc       	mov	r12,-4
8000825a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    	   
    if (sizeof(struct fat_dir_entry) != FAT_DIR_ENTRY_SIZE)
        return FAT_INIT_STRUCT_PACKING;

    // Check the partition type code
    switch(fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION])
8000825e:	ef 38 02 06 	ld.ub	r8,r7[518]
80008262:	30 f9       	mov	r9,15
80008264:	f2 08 18 00 	cp.b	r8,r9
80008268:	e0 8b 00 0c 	brhi	80008280 <fatfs_init+0x7c>
8000826c:	30 19       	mov	r9,1
8000826e:	f2 08 09 49 	lsl	r9,r9,r8
80008272:	12 9a       	mov	r10,r9
80008274:	e2 1a d8 60 	andl	r10,0xd860,COH
80008278:	c0 91       	brne	8000828a <fatfs_init+0x86>
8000827a:	ed b9 00 00 	bld	r9,0x0
8000827e:	c2 70       	breq	800082cc <fatfs_init+0xc8>
        break;
        case 0x00:
            valid_partition = 0;
            break;
        default:
            if (fs->currentsector.sector[PARTITION1_TYPECODE_LOCATION] <= 0x06)
80008280:	30 69       	mov	r9,6
80008282:	f2 08 18 00 	cp.b	r8,r9
80008286:	e0 8b 00 23 	brhi	800082cc <fatfs_init+0xc8>
        break;
    }

    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
8000828a:	ef 38 02 0c 	ld.ub	r8,r7[524]
8000828e:	b1 68       	lsl	r8,0x10
80008290:	ef 3c 02 0d 	ld.ub	r12,r7[525]
80008294:	b9 6c       	lsl	r12,0x18
80008296:	10 0c       	add	r12,r8
80008298:	ef 38 02 0a 	ld.ub	r8,r7[522]
8000829c:	10 0c       	add	r12,r8
8000829e:	ef 38 02 0b 	ld.ub	r8,r7[523]
800082a2:	a9 68       	lsl	r8,0x8
800082a4:	10 0c       	add	r12,r8
800082a6:	8f 7c       	st.w	r7[0x1c],r12
    else
        fs->lba_begin = 0;

    // Load Volume 1 table into sector buffer
    // (We may already have this in the buffer if MBR less drive!)
    if (!fs->disk_io.read_media(fs->lba_begin, fs->currentsector.sector, 1))
800082a8:	0c 9b       	mov	r11,r6
800082aa:	6e d8       	ld.w	r8,r7[0x34]
800082ac:	30 1a       	mov	r10,1
800082ae:	5d 18       	icall	r8
800082b0:	cb 90       	breq	80008222 <fatfs_init+0x1e>
        return FAT_INIT_MEDIA_ACCESS_ERROR;

    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
800082b2:	ef 36 00 50 	ld.ub	r6,r7[80]
800082b6:	ef 3a 00 4f 	ld.ub	r10,r7[79]
800082ba:	ec 08 15 08 	lsl	r8,r6,0x8
800082be:	14 08       	add	r8,r10
800082c0:	e0 48 02 00 	cp.w	r8,512
800082c4:	c0 70       	breq	800082d2 <fatfs_init+0xce>
800082c6:	3f ec       	mov	r12,-2
800082c8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    // Read LBA Begin for the file system
    if (valid_partition)        
        fs->lba_begin = GET_32BIT_WORD(fs->currentsector.sector, PARTITION1_LBA_BEGIN_LOCATION);
    // Else possibly MBR less disk
    else
        fs->lba_begin = 0;
800082cc:	30 0c       	mov	r12,0
800082ce:	8f 7c       	st.w	r7[0x1c],r12
800082d0:	ce cb       	rjmp	800082a8 <fatfs_init+0xa4>
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
800082d2:	ef 38 00 51 	ld.ub	r8,r7[81]
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
800082d6:	ef 39 00 55 	ld.ub	r9,r7[85]
    // Make sure there are 512 bytes per cluster
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
800082da:	ae 88       	st.b	r7[0x0],r8
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);
800082dc:	ef 38 00 56 	ld.ub	r8,r7[86]
800082e0:	a9 68       	lsl	r8,0x8
800082e2:	f2 08 00 08 	add	r8,r9,r8
800082e6:	ef 58 00 28 	st.h	r7[40],r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
800082ea:	ef 39 00 5b 	ld.ub	r9,r7[91]
800082ee:	ef 38 00 5a 	ld.ub	r8,r7[90]
800082f2:	f2 05 15 08 	lsl	r5,r9,0x8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
800082f6:	ef 3c 00 53 	ld.ub	r12,r7[83]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
800082fa:	10 05       	add	r5,r8
    if (GET_16BIT_WORD(fs->currentsector.sector, 0x0B) != FAT_SECTOR_SIZE) 
        return FAT_INIT_INVALID_SECTOR_SIZE;

    // Load Parameters of FAT partition     
    fs->sectors_per_cluster = fs->currentsector.sector[BPB_SECPERCLUS];
    reserved_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT);
800082fc:	ef 3b 00 52 	ld.ub	r11,r7[82]
    num_of_fats = fs->currentsector.sector[BPB_NUMFATS];
80008300:	ef 3e 00 54 	ld.ub	lr,r7[84]
    fs->root_entry_count = GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT);

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
80008304:	c1 01       	brne	80008324 <fatfs_init+0x120>
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
80008306:	ef 35 00 6a 	ld.ub	r5,r7[106]
8000830a:	b1 65       	lsl	r5,0x10
8000830c:	ef 34 00 6b 	ld.ub	r4,r7[107]
80008310:	b9 64       	lsl	r4,0x18
80008312:	0a 04       	add	r4,r5
80008314:	ef 35 00 68 	ld.ub	r5,r7[104]
80008318:	0a 04       	add	r4,r5
8000831a:	ef 35 00 69 	ld.ub	r5,r7[105]
8000831e:	a9 65       	lsl	r5,0x8
80008320:	e8 05 00 05 	add	r5,r4,r5
80008324:	8f 85       	st.w	r7[0x20],r5
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
80008326:	ef 35 00 72 	ld.ub	r5,r7[114]
8000832a:	b1 65       	lsl	r5,0x10
8000832c:	ef 34 00 73 	ld.ub	r4,r7[115]
80008330:	b9 64       	lsl	r4,0x18
80008332:	0a 04       	add	r4,r5
80008334:	ef 35 00 70 	ld.ub	r5,r7[112]
80008338:	0a 04       	add	r4,r5
8000833a:	ef 35 00 71 	ld.ub	r5,r7[113]
8000833e:	a9 65       	lsl	r5,0x8
80008340:	e8 05 00 05 	add	r5,r4,r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
80008344:	ef 13 00 28 	ld.uh	r3,r7[40]
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
80008348:	ef 34 00 74 	ld.ub	r4,r7[116]
        fs->fat_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
8000834c:	8f 25       	st.w	r7[0x8],r5
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000834e:	a5 73       	lsl	r3,0x5
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
80008350:	ef 35 00 75 	ld.ub	r5,r7[117]

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
80008354:	e6 c3 fe 01 	sub	r3,r3,-511
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
80008358:	a9 65       	lsl	r5,0x8

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
8000835a:	a9 53       	asr	r3,0x9
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
8000835c:	e8 05 00 05 	add	r5,r4,r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;
80008360:	8f 43       	st.w	r7[0x10],r3
    else
        fs->fat_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);
    
    // For FAT32 (which this may be)
    fs->rootdir_first_cluster = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_ROOTCLUS);
    fs->fs_info_sector = GET_16BIT_WORD(fs->currentsector.sector, BPB_FAT32_FSINFO);
80008362:	ef 55 00 18 	st.h	r7[24],r5

    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
80008366:	6e 84       	ld.w	r4,r7[0x20]
80008368:	f8 05 15 08 	lsl	r5,r12,0x8
8000836c:	fc 04 02 44 	mul	r4,lr,r4
80008370:	16 05       	add	r5,r11
80008372:	5c 75       	castu.h	r5
80008374:	ea 04 00 03 	add	r3,r5,r4
80008378:	8f 33       	st.w	r7[0xc],r3
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
8000837a:	6e 73       	ld.w	r3,r7[0x1c]
8000837c:	06 05       	add	r5,r3

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
8000837e:	ea 04 00 04 	add	r4,r5,r4
    // For FAT16 (which this may be), rootdir_first_cluster is actuall rootdir_first_sector
    fs->rootdir_first_sector = reserved_sectors + (num_of_fats * fs->fat_sectors);
    fs->rootdir_sectors = ((fs->root_entry_count * 32) + (FAT_SECTOR_SIZE - 1)) / FAT_SECTOR_SIZE;

    // First FAT LBA address
    fs->fat_begin_lba = fs->lba_begin + reserved_sectors;
80008382:	8f 55       	st.w	r7[0x14],r5

    // The address of the first data cluster on this volume
    fs->cluster_begin_lba = fs->fat_begin_lba + (num_of_fats * fs->fat_sectors);
80008384:	8f 14       	st.w	r7[0x4],r4

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
80008386:	ef 35 02 42 	ld.ub	r5,r7[578]
8000838a:	ef 34 02 43 	ld.ub	r4,r7[579]
8000838e:	a9 64       	lsl	r4,0x8
80008390:	e8 05 00 05 	add	r5,r4,r5
80008394:	e0 45 aa 55 	cp.w	r5,43605
80008398:	fe 91 ff 53 	brne	8000823e <fatfs_init+0x3a>
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
8000839c:	a9 69       	lsl	r9,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
8000839e:	ef 33 00 56 	ld.ub	r3,r7[86]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
800083a2:	f2 08 00 05 	add	r5,r9,r8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
800083a6:	ef 34 00 55 	ld.ub	r4,r7[85]
    
    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16) != 0)
800083aa:	c0 f1       	brne	800083c8 <fatfs_init+0x1c4>
        FATSz = GET_16BIT_WORD(fs->currentsector.sector, BPB_FATSZ16);
    else
        FATSz = GET_32BIT_WORD(fs->currentsector.sector, BPB_FAT32_FATSZ32);  
800083ac:	ef 38 00 6a 	ld.ub	r8,r7[106]
800083b0:	b1 68       	lsl	r8,0x10
800083b2:	ef 35 00 6b 	ld.ub	r5,r7[107]
800083b6:	b9 65       	lsl	r5,0x18
800083b8:	10 05       	add	r5,r8
800083ba:	ef 38 00 68 	ld.ub	r8,r7[104]
800083be:	10 05       	add	r5,r8
800083c0:	ef 38 00 69 	ld.ub	r8,r7[105]
800083c4:	a9 68       	lsl	r8,0x8
800083c6:	10 05       	add	r5,r8

    if(GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16) != 0)
800083c8:	ef 39 00 58 	ld.ub	r9,r7[88]
800083cc:	ef 38 00 57 	ld.ub	r8,r7[87]
800083d0:	a9 69       	lsl	r9,0x8
800083d2:	10 09       	add	r9,r8
800083d4:	c0 f1       	brne	800083f2 <fatfs_init+0x1ee>
        total_sectors = GET_16BIT_WORD(fs->currentsector.sector, BPB_TOTSEC16);
    else
        total_sectors = GET_32BIT_WORD(fs->currentsector.sector, BPB_TOTSEC32);
800083d6:	ef 38 00 66 	ld.ub	r8,r7[102]
800083da:	b1 68       	lsl	r8,0x10
800083dc:	ef 39 00 67 	ld.ub	r9,r7[103]
800083e0:	b9 69       	lsl	r9,0x18
800083e2:	10 09       	add	r9,r8
800083e4:	ef 38 00 64 	ld.ub	r8,r7[100]
800083e8:	10 09       	add	r9,r8
800083ea:	ef 38 00 65 	ld.ub	r8,r7[101]
800083ee:	a9 68       	lsl	r8,0x8
800083f0:	10 09       	add	r9,r8

    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
800083f2:	0f 88       	ld.ub	r8,r7[0x0]
800083f4:	58 08       	cp.w	r8,0
800083f6:	c0 41       	brne	800083fe <fatfs_init+0x1fa>
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
            return FAT_INIT_OK;
800083f8:	3f bc       	mov	r12,-5
        }
    }
    else
        return FAT_INIT_WRONG_FILESYS_TYPE;    
}
800083fa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
800083fe:	a9 6c       	lsl	r12,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
80008400:	a9 66       	lsl	r6,0x8
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
80008402:	a9 63       	lsl	r3,0x8

    if (GET_16BIT_WORD(fs->currentsector.sector, 0x1FE) != 0xAA55) // This signature should be AA55
        return FAT_INIT_INVALID_SIGNATURE;

    // Calculate the root dir sectors
    root_dir_sectors = ((GET_16BIT_WORD(fs->currentsector.sector, BPB_ROOTENTCNT) * 32) + (GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC) - 1)) / GET_16BIT_WORD(fs->currentsector.sector, BPB_BYTSPERSEC);
80008404:	ec 0a 00 0a 	add	r10,r6,r10
    data_sectors = total_sectors - (GET_16BIT_WORD(fs->currentsector.sector, BPB_RSVDSECCNT) + (fs->currentsector.sector[BPB_NUMFATS] * FATSz) + root_dir_sectors);

    // Find out which version of FAT this is...
    if (fs->sectors_per_cluster != 0)
    {
        count_of_clusters = data_sectors / fs->sectors_per_cluster;
80008408:	e6 04 00 04 	add	r4,r3,r4
8000840c:	ea 0e 02 4e 	mul	lr,r5,lr
80008410:	f8 0b 00 0b 	add	r11,r12,r11
80008414:	f4 c5 00 01 	sub	r5,r10,1
80008418:	e8 0c 15 05 	lsl	r12,r4,0x5
8000841c:	18 05       	add	r5,r12
8000841e:	ea 0a 0c 04 	divs	r4,r5,r10
80008422:	e8 0a 11 00 	rsub	r10,r4,0
80008426:	16 1a       	sub	r10,r11
80008428:	1c 1a       	sub	r10,lr
8000842a:	f4 09 00 09 	add	r9,r10,r9
8000842e:	f2 08 0d 08 	divu	r8,r9,r8

        if(count_of_clusters < 4085) 
80008432:	e0 48 0f f4 	cp.w	r8,4084
80008436:	fe 98 ff e1 	brls	800083f8 <fatfs_init+0x1f4>
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
8000843a:	e0 48 ff f4 	cp.w	r8,65524
8000843e:	f9 bc 08 00 	movls	r12,0

            // Volume is FAT16
            fs->fat_type = FAT_TYPE_16;
80008442:	ef fc 8a 0c 	st.wls	r7[0x30],r12
            // Volume is FAT12 
            return FAT_INIT_WRONG_FILESYS_TYPE;
        else if(count_of_clusters < 65525) 
        {
            // Clear this FAT32 specific param
            fs->rootdir_first_cluster = 0;
80008446:	ef fc 8a 02 	st.wls	r7[0x8],r12
            return FAT_INIT_OK;
        }
        else
        {
            // Volume is FAT32
            fs->fat_type = FAT_TYPE_32;
8000844a:	f9 b8 0b 01 	movhi	r8,1
8000844e:	ef f8 ba 0c 	st.whi	r7[0x30],r8
80008452:	f9 bc 0b 00 	movhi	r12,0
            return FAT_INIT_OK;
80008456:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000845a:	d7 03       	nop

8000845c <fatfs_cache_init>:
        file->cluster_cache_data[i] = 0; 
    }
#endif
    
    return 1;
}
8000845c:	5e ff       	retal	1

8000845e <fatfs_cache_get_next_cluster>:
        return 1;
    }
#endif
    
    return 0;
}
8000845e:	5e fd       	retal	0

80008460 <fatfs_cache_set_next_cluster>:
        file->cluster_cache_data[slot] = nextCluster;
    }
#endif

    return 1;
}
80008460:	5e ff       	retal	1
80008462:	d7 03       	nop

80008464 <_allocate_file>:
{
    struct fat_node * node;

    FAT_ASSERT(list);

    node = fat_list_first(list);
80008464:	e0 6a 29 f8 	mov	r10,10744
    if (node)
80008468:	74 0c       	ld.w	r12,r10[0x0]
8000846a:	58 0c       	cp.w	r12,0
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
8000846c:	5e 0c       	reteq	r12
        list->head = node->next;
8000846e:	78 08       	ld.w	r8,r12[0x0]
80008470:	58 08       	cp.w	r8,0
80008472:	f9 f9 00 01 	ld.weq	r9,r12[0x4]
80008476:	f5 f9 0a 00 	st.weq	r10[0x0],r9
    else
        node->previous->next = node->next;
8000847a:	f9 f9 10 01 	ld.wne	r9,r12[0x4]
8000847e:	f1 f9 1a 01 	st.wne	r8[0x4],r9
80008482:	f9 f9 10 01 	ld.wne	r9,r12[0x4]
80008486:	f9 f8 10 00 	ld.wne	r8,r12[0x0]

    if(!node->next)
        list->tail = node->previous;
8000848a:	58 09       	cp.w	r9,0
8000848c:	f5 f8 0a 01 	st.weq	r10[0x4],r8
    else
        node->next->previous = node->previous;
80008490:	f3 f8 1a 00 	st.wne	r9[0x0],r8
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
80008494:	e0 6a 1c f8 	mov	r10,7416
80008498:	74 18       	ld.w	r8,r10[0x4]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000849a:	58 08       	cp.w	r8,0
    new_node->next = node->next;
8000849c:	c0 e0       	breq	800084b8 <_allocate_file+0x54>
8000849e:	99 08       	st.w	r12[0x0],r8
    if (!node->next)
800084a0:	70 19       	ld.w	r9,r8[0x4]
        list->tail = new_node;
800084a2:	99 19       	st.w	r12[0x4],r9
800084a4:	70 19       	ld.w	r9,r8[0x4]
800084a6:	58 09       	cp.w	r9,0
    else
        node->next->previous = new_node;
800084a8:	f5 fc 0a 01 	st.weq	r10[0x4],r12
    node->next = new_node;
800084ac:	f3 fc 1a 00 	st.wne	r9[0x0],r12

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
800084b0:	91 1c       	st.w	r8[0x4],r12
}
800084b2:	f8 cc 04 3c 	sub	r12,r12,1084
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
800084b6:	5e fc       	retal	r12
800084b8:	74 08       	ld.w	r8,r10[0x0]
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
800084ba:	58 08       	cp.w	r8,0
    new_node->next = node;
800084bc:	c0 e0       	breq	800084d8 <_allocate_file+0x74>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
800084be:	70 09       	ld.w	r9,r8[0x0]
    new_node->next = node;
    if (!node->previous)
800084c0:	99 18       	st.w	r12[0x4],r8
        list->head = new_node;
800084c2:	99 09       	st.w	r12[0x0],r9
800084c4:	70 09       	ld.w	r9,r8[0x0]
800084c6:	58 09       	cp.w	r9,0
    else
        node->previous->next = new_node;
800084c8:	f5 fc 0a 00 	st.weq	r10[0x0],r12
    node->previous = new_node;
800084cc:	f3 fc 1a 01 	st.wne	r9[0x4],r12

    // Add to open list
    if (node)
        fat_list_insert_last(&_open_file_list, node);

    return fat_list_entry(node, FL_FILE, list_node);
800084d0:	91 0c       	st.w	r8[0x0],r12
}
800084d2:	f8 cc 04 3c 	sub	r12,r12,1084
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
800084d6:	5e fc       	retal	r12
        list->tail = node;
        node->previous = 0;
        node->next = 0;
800084d8:	95 1c       	st.w	r10[0x4],r12

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
800084da:	95 0c       	st.w	r10[0x0],r12
800084dc:	99 18       	st.w	r12[0x4],r8
800084de:	99 08       	st.w	r12[0x0],r8
800084e0:	ce 9b       	rjmp	800084b2 <_allocate_file+0x4e>
800084e2:	d7 03       	nop

800084e4 <_free_file>:
800084e4:	f8 f8 04 3c 	ld.w	r8,r12[1084]
inline void fat_list_remove(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
800084e8:	58 08       	cp.w	r8,0
800084ea:	c1 f0       	breq	80008528 <_free_file+0x44>
        list->head = node->next;
    else
        node->previous->next = node->next;
800084ec:	f8 f9 04 40 	ld.w	r9,r12[1088]
800084f0:	91 19       	st.w	r8[0x4],r9
800084f2:	f8 f8 04 40 	ld.w	r8,r12[1088]
800084f6:	f8 f9 04 3c 	ld.w	r9,r12[1084]

    if(!node->next)
800084fa:	58 08       	cp.w	r8,0
800084fc:	c1 e0       	breq	80008538 <_free_file+0x54>
        list->tail = node->previous;
    else
        node->next->previous = node->previous;
800084fe:	91 09       	st.w	r8[0x0],r9
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
80008500:	e0 6b 29 f8 	mov	r11,10744
{
    // Remove from open list
    fat_list_remove(&_open_file_list, &file->list_node);

    // Add to free list
    fat_list_insert_last(&_free_file_list, &file->list_node);
80008504:	f8 c9 fb c4 	sub	r9,r12,-1084
80008508:	76 18       	ld.w	r8,r11[0x4]
8000850a:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
8000850c:	c1 a0       	breq	80008540 <_free_file+0x5c>
8000850e:	f9 48 04 3c 	st.w	r12[1084],r8
    new_node->next = node->next;
80008512:	70 1a       	ld.w	r10,r8[0x4]
80008514:	f9 4a 04 40 	st.w	r12[1088],r10
    if (!node->next)
        list->tail = new_node;
80008518:	70 1a       	ld.w	r10,r8[0x4]
8000851a:	58 0a       	cp.w	r10,0
8000851c:	f7 f9 0a 01 	st.weq	r11[0x4],r9
    else
        node->next->previous = new_node;
80008520:	f5 f9 1a 00 	st.wne	r10[0x0],r9
    node->next = new_node;
80008524:	91 19       	st.w	r8[0x4],r9
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if(!node->previous)
        list->head = node->next;
80008526:	5e fc       	retal	r12
80008528:	10 99       	mov	r9,r8
8000852a:	e0 6a 1c f8 	mov	r10,7416
8000852e:	f8 f8 04 40 	ld.w	r8,r12[1088]
    else
        node->previous->next = node->next;

    if(!node->next)
80008532:	95 08       	st.w	r10[0x0],r8
        list->tail = node->previous;
80008534:	58 08       	cp.w	r8,0
80008536:	ce 41       	brne	800084fe <_free_file+0x1a>
80008538:	e0 68 1c f8 	mov	r8,7416
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
8000853c:	91 19       	st.w	r8[0x4],r9
8000853e:	ce 1b       	rjmp	80008500 <_free_file+0x1c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
80008540:	76 08       	ld.w	r8,r11[0x0]
    new_node->next = node;
80008542:	58 08       	cp.w	r8,0
80008544:	c0 e0       	breq	80008560 <_free_file+0x7c>
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
80008546:	70 0a       	ld.w	r10,r8[0x0]
80008548:	f9 48 04 40 	st.w	r12[1088],r8
    new_node->next = node;
    if (!node->previous)
        list->head = new_node;
8000854c:	f9 4a 04 3c 	st.w	r12[1084],r10
80008550:	70 0a       	ld.w	r10,r8[0x0]
    else
        node->previous->next = new_node;
80008552:	58 0a       	cp.w	r10,0
80008554:	f7 f9 0a 00 	st.weq	r11[0x0],r9
    node->previous = new_node;
80008558:	f5 f9 1a 01 	st.wne	r10[0x4],r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
    {
        list->head = node;
8000855c:	91 09       	st.w	r8[0x0],r9
        list->tail = node;
        node->previous = 0;
        node->next = 0;
8000855e:	5e fc       	retal	r12
80008560:	97 19       	st.w	r11[0x4],r9

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
80008562:	97 09       	st.w	r11[0x0],r9
80008564:	f9 48 04 40 	st.w	r12[1088],r8
80008568:	f9 48 04 3c 	st.w	r12[1084],r8
8000856c:	5e fc       	retal	r12
8000856e:	d7 03       	nop

80008570 <fl_init>:

//-----------------------------------------------------------------------------
// fl_init: Initialise library
//-----------------------------------------------------------------------------
void fl_init(void)
{    
80008570:	eb cd 40 f8 	pushm	r3-r7,lr
inline void fat_list_init(struct fat_list *list);
inline void fat_list_init(struct fat_list *list)
{
    FAT_ASSERT(list);

    list->head = list->tail = 0;
80008574:	30 08       	mov	r8,0
80008576:	e0 69 1c f8 	mov	r9,7416
8000857a:	e0 66 29 f8 	mov	r6,10744
8000857e:	93 08       	st.w	r9[0x0],r8
80008580:	93 18       	st.w	r9[0x4],r8
80008582:	8d 18       	st.w	r6[0x4],r8
80008584:	8d 08       	st.w	r6[0x0],r8
    fat_list_init(&_free_file_list);
    fat_list_init(&_open_file_list);

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);
80008586:	e0 65 21 6c 	mov	r5,8556
8000858a:	10 9a       	mov	r10,r8
8000858c:	e0 63 04 44 	mov	r3,1092
80008590:	10 9e       	mov	lr,r8
80008592:	f4 03 02 49 	mul	r9,r10,r3
80008596:	10 97       	mov	r7,r8
80008598:	f2 c9 fb c4 	sub	r9,r9,-1084
8000859c:	ea cc fb c4 	sub	r12,r5,-1084
800085a0:	ea cb fb c0 	sub	r11,r5,-1088
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
800085a4:	ea 09 00 09 	add	r9,r5,r9
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node;
    new_node->next = node->next;
800085a8:	58 08       	cp.w	r8,0
800085aa:	c1 d0       	breq	800085e4 <fl_init+0x74>
    if (!node->next)
800085ac:	99 08       	st.w	r12[0x0],r8
800085ae:	70 14       	ld.w	r4,r8[0x4]
800085b0:	97 04       	st.w	r11[0x0],r4
800085b2:	70 14       	ld.w	r4,r8[0x4]
        list->tail = new_node;
    else
        node->next->previous = new_node;
800085b4:	58 04       	cp.w	r4,0
800085b6:	f2 0e 17 00 	moveq	lr,r9
    node->next = new_node;
800085ba:	e9 f9 1a 00 	st.wne	r4[0x0],r9

    fat_list_init(&_free_file_list);
    fat_list_init(&_open_file_list);

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
800085be:	91 19       	st.w	r8[0x4],r9
800085c0:	0e 99       	mov	r9,r7
800085c2:	2f fa       	sub	r10,-1
800085c4:	f8 cc fb bc 	sub	r12,r12,-1092
800085c8:	f6 cb fb bc 	sub	r11,r11,-1092
800085cc:	58 2a       	cp.w	r10,2
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);
800085ce:	c2 10       	breq	80008610 <fl_init+0xa0>
800085d0:	12 97       	mov	r7,r9
800085d2:	1c 98       	mov	r8,lr
800085d4:	f4 03 02 49 	mul	r9,r10,r3
800085d8:	f2 c9 fb c4 	sub	r9,r9,-1084
inline void fat_list_insert_last(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->tail)
800085dc:	ea 09 00 09 	add	r9,r5,r9
inline void fat_list_insert_first(struct fat_list *list, struct fat_node *node) 
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);

    if (!list->head)
800085e0:	58 08       	cp.w	r8,0
{
    FAT_ASSERT(list);
    FAT_ASSERT(node);
    FAT_ASSERT(new_node);

    new_node->previous = node->previous;
800085e2:	ce 51       	brne	800085ac <fl_init+0x3c>
800085e4:	58 07       	cp.w	r7,0
    new_node->next = node;
800085e6:	c1 d0       	breq	80008620 <fl_init+0xb0>
    if (!node->previous)
800085e8:	6e 08       	ld.w	r8,r7[0x0]
800085ea:	99 08       	st.w	r12[0x0],r8
800085ec:	97 07       	st.w	r11[0x0],r7
800085ee:	6e 08       	ld.w	r8,r7[0x0]
        list->head = new_node;
    else
        node->previous->next = new_node;
800085f0:	58 08       	cp.w	r8,0
800085f2:	f2 08 17 00 	moveq	r8,r9
800085f6:	f1 f9 1a 01 	st.wne	r8[0x4],r9

    fat_list_init(&_free_file_list);
    fat_list_init(&_open_file_list);

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
800085fa:	ee 08 17 10 	movne	r8,r7
800085fe:	8f 09       	st.w	r7[0x0],r9
80008600:	2f fa       	sub	r10,-1
80008602:	10 99       	mov	r9,r8
80008604:	f8 cc fb bc 	sub	r12,r12,-1092
80008608:	f6 cb fb bc 	sub	r11,r11,-1092
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
8000860c:	58 2a       	cp.w	r10,2
8000860e:	ce 11       	brne	800085d0 <fl_init+0x60>

    fat_list_init(&_free_file_list);
    fat_list_init(&_open_file_list);

    // Add all file objects to free list
    for (i=0;i<FATFS_MAX_OPEN_FILES;i++)
80008610:	8d 09       	st.w	r6[0x0],r9
        fat_list_insert_last(&_free_file_list, &_files[i].list_node);

    _filelib_init = 1;
80008612:	e0 68 29 f4 	mov	r8,10740
}
80008616:	30 19       	mov	r9,1

    if (!list->head)
    {
        list->head = node;
        list->tail = node;
        node->previous = 0;
80008618:	8d 1e       	st.w	r6[0x4],lr
        node->next = 0;
8000861a:	91 09       	st.w	r8[0x0],r9
8000861c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80008620:	99 07       	st.w	r12[0x0],r7
80008622:	97 07       	st.w	r11[0x0],r7
80008624:	12 9e       	mov	lr,r9
80008626:	cc eb       	rjmp	800085c2 <fl_init+0x52>

80008628 <_open_directory>:
80008628:	eb cd 40 fe 	pushm	r1-r7,lr
8000862c:	fa cd 01 24 	sub	sp,sp,292
//-----------------------------------------------------------------------------
// _open_directory: Cycle through path string to find the start cluster
// address of the highest subdir.
//-----------------------------------------------------------------------------
static int _open_directory(char *path, uint32 *pathCluster)
{
80008630:	18 93       	mov	r3,r12
80008632:	16 91       	mov	r1,r11
    char currentfolder[FATFS_MAX_LONG_FILENAME];
    struct fat_dir_entry sfEntry;
    uint32 startcluster;

    // Set starting cluster to root cluster
    startcluster = fatfs_get_root_cluster(&_fs);
80008634:	e0 6c 1d 04 	mov	r12,7428
80008638:	fe b0 fc 7c 	rcall	80007f30 <fatfs_get_root_cluster>

    // Find number of levels
    levels = fatfs_total_path_levels(path);
8000863c:	18 95       	mov	r5,r12
8000863e:	06 9c       	mov	r12,r3
80008640:	e0 a0 07 98 	rcall	80009570 <fatfs_total_path_levels>

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
80008644:	18 92       	mov	r2,r12
80008646:	c3 35       	brlt	800086ac <_open_directory+0x84>
80008648:	30 07       	mov	r7,0
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
            return 0;

        // Find clusteraddress for folder (currentfolder) 
        if (fatfs_get_file_entry(&_fs, startcluster, currentfolder,&sfEntry))
8000864a:	1a 96       	mov	r6,sp
8000864c:	fa c4 fe fc 	sub	r4,sp,-260
80008650:	c2 18       	rjmp	80008692 <_open_directory+0x6a>
80008652:	0a 9b       	mov	r11,r5
80008654:	08 99       	mov	r9,r4
80008656:	1a 9a       	mov	r10,sp
80008658:	e0 6c 1d 04 	mov	r12,7428
8000865c:	fe b0 fd 32 	rcall	800080c0 <fatfs_get_file_entry>
        {
            // Check entry is folder
            if (fatfs_entry_is_dir(&sfEntry))
80008660:	c2 30       	breq	800086a6 <_open_directory+0x7e>
80008662:	08 9c       	mov	r12,r4
80008664:	e0 a0 05 9f 	rcall	800091a2 <fatfs_entry_is_dir>
                startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
80008668:	c1 f0       	breq	800086a6 <_open_directory+0x7e>
8000866a:	fb 19 01 18 	ld.uh	r9,sp[280]
8000866e:	fb 18 01 1e 	ld.uh	r8,sp[286]
80008672:	f2 05 15 08 	lsl	r5,r9,0x8
80008676:	eb d5 c0 10 	bfextu	r5,r5,0x0,0x10
8000867a:	eb e9 12 85 	or	r5,r5,r9>>0x8
8000867e:	f0 09 15 08 	lsl	r9,r8,0x8
80008682:	b1 65       	lsl	r5,0x10
80008684:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
80008688:	f3 e8 12 88 	or	r8,r9,r8>>0x8

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
8000868c:	10 05       	add	r5,r8
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
8000868e:	0e 32       	cp.w	r2,r7
80008690:	c0 e5       	brlt	800086ac <_open_directory+0x84>
80008692:	0e 9b       	mov	r11,r7

    // Find number of levels
    levels = fatfs_total_path_levels(path);

    // Cycle through each level and get the start sector
    for (sublevel=0;sublevel<(levels+1);sublevel++) 
80008694:	e0 69 01 04 	mov	r9,260
    {
        if (fatfs_get_substring(path, sublevel, currentfolder, sizeof(currentfolder)) == -1)
80008698:	2f f7       	sub	r7,-1
8000869a:	1a 9a       	mov	r10,sp
8000869c:	06 9c       	mov	r12,r3
8000869e:	e0 a0 08 8f 	rcall	800097bc <fatfs_get_substring>
        else
            return 0;
    }

    *pathCluster = startcluster;
    return 1;
800086a2:	5b fc       	cp.w	r12,-1
800086a4:	cd 71       	brne	80008652 <_open_directory+0x2a>
800086a6:	2b 7d       	sub	sp,-292
        }
        else
            return 0;
    }

    *pathCluster = startcluster;
800086a8:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
800086ac:	83 05       	st.w	r1[0x0],r5
800086ae:	2b 7d       	sub	sp,-292
800086b0:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1

800086b4 <_check_file_open>:
800086b4:	d4 21       	pushm	r4-r7,lr
800086b6:	e0 68 1c f8 	mov	r8,7416
800086ba:	18 96       	mov	r6,r12
800086bc:	70 07       	ld.w	r7,r8[0x0]
800086be:	58 07       	cp.w	r7,0
800086c0:	c1 a0       	breq	800086f4 <_check_file_open+0x40>
800086c2:	f8 c5 ff ec 	sub	r5,r12,-20
800086c6:	f8 c4 fe e8 	sub	r4,r12,-280
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
800086ca:	c0 48       	rjmp	800086d2 <_check_file_open+0x1e>
800086cc:	6e 17       	ld.w	r7,r7[0x4]
800086ce:	58 07       	cp.w	r7,0
    {
        FL_FILE* openFile = fat_list_entry(node, FL_FILE, list_node);
800086d0:	c1 20       	breq	800086f4 <_check_file_open+0x40>
800086d2:	ee c8 04 3c 	sub	r8,r7,1084

        // If not the current file 
        if (openFile != file)
800086d6:	0c 38       	cp.w	r8,r6
        {
            // Compare path and name
            if ( (fatfs_compare_names(openFile->path,file->path)) && (fatfs_compare_names(openFile->filename,file->filename)) )
800086d8:	cf a0       	breq	800086cc <_check_file_open+0x18>
800086da:	0a 9b       	mov	r11,r5
800086dc:	ee cc 04 28 	sub	r12,r7,1064
800086e0:	e0 a0 07 76 	rcall	800095cc <fatfs_compare_names>
800086e4:	cf 40       	breq	800086cc <_check_file_open+0x18>
800086e6:	ee cc 03 24 	sub	r12,r7,804
800086ea:	08 9b       	mov	r11,r4
800086ec:	e0 a0 07 70 	rcall	800095cc <fatfs_compare_names>
800086f0:	ce e0       	breq	800086cc <_check_file_open+0x18>
static int _check_file_open(FL_FILE* file)
{
    struct fat_node *node;
    
    // Compare open files
    fat_list_for_each(&_open_file_list, node)
800086f2:	da 2a       	popm	r4-r7,pc,r12=1
800086f4:	d8 2a       	popm	r4-r7,pc,r12=0
800086f6:	d7 03       	nop

800086f8 <_write_sectors>:
800086f8:	d4 31       	pushm	r0-r7,lr
800086fa:	20 3d       	sub	sp,12
static uint32 _write_sectors(FL_FILE* file, uint32 offset, uint8 *buf, uint32 count)
{
    uint32 SectorNumber = 0;
    uint32 ClusterIdx = 0;
    uint32 Cluster = 0;
    uint32 LastCluster = FAT32_LAST_CLUSTER;
800086fc:	3f f8       	mov	r8,-1
//-----------------------------------------------------------------------------
// _write_sectors: Write sector(s) to disk
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
static uint32 _write_sectors(FL_FILE* file, uint32 offset, uint8 *buf, uint32 count)
{
800086fe:	12 90       	mov	r0,r9
    uint32 SectorNumber = 0;
    uint32 ClusterIdx = 0;
    uint32 Cluster = 0;
    uint32 LastCluster = FAT32_LAST_CLUSTER;
80008700:	50 28       	stdsp	sp[0x8],r8
    uint32 i;
    uint32 lba;
    uint32 TotalWriteCount = count;

    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
80008702:	e0 69 1d 04 	mov	r9,7428
80008706:	50 0a       	stdsp	sp[0x0],r10
80008708:	13 88       	ld.ub	r8,r9[0x0]
8000870a:	f6 08 0d 06 	divu	r6,r11,r8
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);
8000870e:	18 95       	mov	r5,r12
80008710:	ec 08 02 42 	mul	r2,r6,r8
80008714:	0c 94       	mov	r4,r6
80008716:	f6 02 01 02 	sub	r2,r11,r2
    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000871a:	f8 f7 02 28 	ld.w	r7,r12[552]
    // Find values for Cluster index & sector within cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    SectorNumber = offset - (ClusterIdx * _fs.sectors_per_cluster);

    // Limit number of sectors written to the number remaining in this cluster
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
8000871e:	e4 00 00 09 	add	r9,r2,r0
80008722:	12 38       	cp.w	r8,r9
80008724:	e0 01 17 20 	movhs	r1,r0
        count = _fs.sectors_per_cluster - SectorNumber;
80008728:	f1 d2 e3 11 	subcs	r1,r8,r2

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000872c:	0c 37       	cp.w	r7,r6
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000872e:	c5 b0       	breq	800087e4 <_write_sectors+0xec>
80008730:	58 06       	cp.w	r6,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;
80008732:	c4 e1       	brne	800087ce <_write_sectors+0xd6>
80008734:	6a 16       	ld.w	r6,r5[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
80008736:	30 07       	mov	r7,0
80008738:	0e 34       	cp.w	r4,r7
8000873a:	e0 88 00 58 	brls	800087ea <_write_sectors+0xf2>
8000873e:	fa c3 ff fc 	sub	r3,sp,-4

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
80008742:	c0 98       	rjmp	80008754 <_write_sectors+0x5c>
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
80008744:	50 26       	stdsp	sp[0x8],r6
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
80008746:	2f f7       	sub	r7,-1

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
80008748:	40 16       	lddsp	r6,sp[0x4]
8000874a:	5b f6       	cp.w	r6,-1
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
8000874c:	c1 c0       	breq	80008784 <_write_sectors+0x8c>
8000874e:	0e 34       	cp.w	r4,r7
80008750:	e0 88 00 2a 	brls	800087a4 <_write_sectors+0xac>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
80008754:	0e 9a       	mov	r10,r7
80008756:	06 99       	mov	r9,r3
80008758:	0a 9b       	mov	r11,r5
8000875a:	e0 6c 1d 04 	mov	r12,7428
8000875e:	c8 0e       	rcall	8000845e <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
80008760:	cf 21       	brne	80008744 <_write_sectors+0x4c>
80008762:	0c 9b       	mov	r11,r6
80008764:	e0 6c 1d 04 	mov	r12,7428

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
80008768:	e0 a0 09 3e 	rcall	800099e4 <fatfs_find_next_cluster>
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000876c:	0e 9a       	mov	r10,r7

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
8000876e:	18 99       	mov	r9,r12
80008770:	50 1c       	stdsp	sp[0x4],r12
80008772:	0a 9b       	mov	r11,r5
80008774:	e0 6c 1d 04 	mov	r12,7428
            i = 0;
            Cluster = file->startcluster;
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
80008778:	c7 4e       	rcall	80008460 <fatfs_cache_set_next_cluster>
                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            LastCluster = Cluster;
            Cluster = nextCluster;
8000877a:	50 26       	stdsp	sp[0x8],r6

            // Dont keep following a dead end
            if (Cluster == FAT32_LAST_CLUSTER)
8000877c:	2f f7       	sub	r7,-1
8000877e:	40 16       	lddsp	r6,sp[0x4]
80008780:	5b f6       	cp.w	r6,-1
80008782:	ce 61       	brne	8000874e <_write_sectors+0x56>

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
        {
            // Add some more cluster(s) to the last good cluster chain
            if (!fatfs_add_free_space(&_fs, &LastCluster,  (TotalWriteCount + _fs.sectors_per_cluster -1) / _fs.sectors_per_cluster))
80008784:	e0 69 1d 04 	mov	r9,7428
80008788:	13 88       	ld.ub	r8,r9[0x0]
8000878a:	e0 cb 00 01 	sub	r11,r0,1
8000878e:	10 0b       	add	r11,r8
80008790:	f6 08 0d 0a 	divu	r10,r11,r8
80008794:	fa cb ff f8 	sub	r11,sp,-8
80008798:	e0 6c 1d 04 	mov	r12,7428
            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
8000879c:	e0 a0 0b a6 	rcall	80009ee8 <fatfs_add_free_space>

            Cluster = LastCluster;
        }

        // Record current cluster lookup details
        file->last_fat_lookup.CurrentCluster = Cluster;
800087a0:	c1 e0       	breq	800087dc <_write_sectors+0xe4>
800087a2:	40 26       	lddsp	r6,sp[0x8]
        file->last_fat_lookup.ClusterIdx = ClusterIdx;
    }

    // Calculate write address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + SectorNumber;
800087a4:	eb 44 02 28 	st.w	r5[552],r4
800087a8:	eb 46 02 2c 	st.w	r5[556],r6

    if (fatfs_sector_write(&_fs, lba, buf, count))
800087ac:	0c 9b       	mov	r11,r6
800087ae:	e0 6c 1d 04 	mov	r12,7428
800087b2:	fe b0 fb 5d 	rcall	80007e6c <fatfs_lba_of_cluster>
800087b6:	02 99       	mov	r9,r1
800087b8:	f8 02 00 0b 	add	r11,r12,r2
        return count;
    else
        return 0;
}
800087bc:	40 0a       	lddsp	r10,sp[0x0]
800087be:	e0 6c 1d 04 	mov	r12,7428
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
800087c2:	fe b0 fb 72 	rcall	80007ea6 <fatfs_sector_write>
800087c6:	c0 b0       	breq	800087dc <_write_sectors+0xe4>
800087c8:	02 9c       	mov	r12,r1
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
800087ca:	2f dd       	sub	sp,-12
800087cc:	d8 32       	popm	r0-r7,pc
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
800087ce:	ee c9 ff ff 	sub	r9,r7,-1

    if (fatfs_sector_write(&_fs, lba, buf, count))
        return count;
    else
        return 0;
}
800087d2:	0c 39       	cp.w	r9,r6
800087d4:	cb 01       	brne	80008734 <_write_sectors+0x3c>
800087d6:	f8 f6 02 2c 	ld.w	r6,r12[556]
    if ((SectorNumber + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - SectorNumber;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
800087da:	ca fb       	rjmp	80008738 <_write_sectors+0x40>
800087dc:	30 01       	mov	r1,0
            if (Cluster == FAT32_LAST_CLUSTER)
                break;
        }

        // If we have reached the end of the chain, allocate more!
        if (Cluster == FAT32_LAST_CLUSTER)
800087de:	02 9c       	mov	r12,r1
800087e0:	2f dd       	sub	sp,-12
800087e2:	d8 32       	popm	r0-r7,pc
800087e4:	f8 f6 02 2c 	ld.w	r6,r12[556]
800087e8:	ce 2b       	rjmp	800087ac <_write_sectors+0xb4>
800087ea:	5b f6       	cp.w	r6,-1
800087ec:	cd c1       	brne	800087a4 <_write_sectors+0xac>
800087ee:	cc eb       	rjmp	8000878a <_write_sectors+0x92>

800087f0 <fl_fflush>:
800087f0:	eb cd 40 c0 	pushm	r6-r7,lr
800087f4:	e0 68 29 f4 	mov	r8,10740
800087f8:	18 97       	mov	r7,r12
800087fa:	70 08       	ld.w	r8,r8[0x0]
800087fc:	58 08       	cp.w	r8,0
800087fe:	c1 30       	breq	80008824 <fl_fflush+0x34>
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (file)
80008800:	58 07       	cp.w	r7,0
    {
        FL_LOCK(&_fs);
80008802:	c0 f0       	breq	80008820 <fl_fflush+0x30>
80008804:	e0 66 1d 04 	mov	r6,7428
80008808:	6c f8       	ld.w	r8,r6[0x3c]
8000880a:	58 08       	cp.w	r8,0

        // If some write data still in buffer
        if (file->file_data_dirty)
8000880c:	c0 20       	breq	80008810 <fl_fflush+0x20>
8000880e:	5d 18       	icall	r8
80008810:	ee f8 04 34 	ld.w	r8,r7[1076]
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
                file->file_data_dirty = 0;
        }

        FL_UNLOCK(&_fs);
80008814:	58 08       	cp.w	r8,0
80008816:	c0 91       	brne	80008828 <fl_fflush+0x38>
80008818:	6d 08       	ld.w	r8,r6[0x40]
8000881a:	58 08       	cp.w	r8,0
    }
#endif
    return 0;
}
8000881c:	c0 20       	breq	80008820 <fl_fflush+0x30>
8000881e:	5d 18       	icall	r8
{
#if FATFS_INC_WRITE_SUPPORT
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008820:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80008824:	ca 6e       	rcall	80008570 <fl_init>

        // If some write data still in buffer
        if (file->file_data_dirty)
        {
            // Write back current sector before loading next
            if (_write_sectors(file, file->file_data_address, file->file_data_sector, 1))
80008826:	ce db       	rjmp	80008800 <fl_fflush+0x10>
80008828:	30 19       	mov	r9,1
8000882a:	ee ca fd d0 	sub	r10,r7,-560
8000882e:	ee fb 04 30 	ld.w	r11,r7[1072]
80008832:	0e 9c       	mov	r12,r7
80008834:	c6 2f       	rcall	800086f8 <_write_sectors>
                file->file_data_dirty = 0;
80008836:	f9 b8 01 00 	movne	r8,0
8000883a:	ef f8 1b 0d 	st.wne	r7[0x434],r8
8000883e:	ce db       	rjmp	80008818 <fl_fflush+0x28>

80008840 <_read_sectors>:
80008840:	d4 31       	pushm	r0-r7,lr
80008842:	20 1d       	sub	sp,4
80008844:	12 92       	mov	r2,r9
80008846:	e0 68 1d 04 	mov	r8,7428
8000884a:	18 96       	mov	r6,r12
8000884c:	11 88       	ld.ub	r8,r8[0x0]
8000884e:	14 90       	mov	r0,r10
    uint32 Cluster = 0;
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
80008850:	f6 08 0d 04 	divu	r4,r11,r8
    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
80008854:	f8 f7 02 28 	ld.w	r7,r12[552]
    uint32 i;
    uint32 lba;

    // Find cluster index within file & sector with cluster
    ClusterIdx = offset / _fs.sectors_per_cluster;      
    Sector = offset - (ClusterIdx * _fs.sectors_per_cluster);
80008858:	e8 08 02 41 	mul	r1,r4,r8
8000885c:	08 95       	mov	r5,r4
8000885e:	f6 01 01 01 	sub	r1,r11,r1

    // Limit number of sectors read to the number remaining in this cluster
    if ((Sector + count) > _fs.sectors_per_cluster)
80008862:	e2 09 00 09 	add	r9,r1,r9
        count = _fs.sectors_per_cluster - Sector;
80008866:	12 38       	cp.w	r8,r9
80008868:	f1 d1 e3 12 	subcs	r2,r8,r1

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
8000886c:	08 37       	cp.w	r7,r4
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
8000886e:	c4 00       	breq	800088ee <_read_sectors+0xae>
80008870:	58 04       	cp.w	r4,0
        // Start searching from the beginning..
        else
        {
            // Set start of cluster chain to initial value
            i = 0;
            Cluster = file->startcluster;                    
80008872:	c4 61       	brne	800088fe <_read_sectors+0xbe>
80008874:	6c 14       	ld.w	r4,r6[0x4]
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
80008876:	30 07       	mov	r7,0
80008878:	0e 35       	cp.w	r5,r7
8000887a:	e0 88 00 23 	brls	800088c0 <_read_sectors+0x80>
8000887e:	1a 93       	mov	r3,sp
80008880:	c0 68       	rjmp	8000888c <_read_sectors+0x4c>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
            }            

            Cluster = nextCluster;
80008882:	2f f7       	sub	r7,-1
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
80008884:	40 04       	lddsp	r4,sp[0x0]
80008886:	0e 35       	cp.w	r5,r7
80008888:	e0 88 00 1c 	brls	800088c0 <_read_sectors+0x80>
        {
            uint32 nextCluster;
            
            // Does the entry exist in the cache?
            if (!fatfs_cache_get_next_cluster(&_fs, file, i, &nextCluster))            
8000888c:	0e 9a       	mov	r10,r7
8000888e:	1a 99       	mov	r9,sp
80008890:	0c 9b       	mov	r11,r6
80008892:	e0 6c 1d 04 	mov	r12,7428
80008896:	fe b0 fd e4 	rcall	8000845e <fatfs_cache_get_next_cluster>
            {
                // Scan file linked list to find next entry
                nextCluster = fatfs_find_next_cluster(&_fs, Cluster);
8000889a:	cf 41       	brne	80008882 <_read_sectors+0x42>
8000889c:	08 9b       	mov	r11,r4
8000889e:	e0 6c 1d 04 	mov	r12,7428
800088a2:	e0 a0 08 a1 	rcall	800099e4 <fatfs_find_next_cluster>

                // Push entry into cache
                fatfs_cache_set_next_cluster(&_fs, file, i, nextCluster);
800088a6:	0e 9a       	mov	r10,r7
800088a8:	18 99       	mov	r9,r12
800088aa:	50 0c       	stdsp	sp[0x0],r12
800088ac:	0c 9b       	mov	r11,r6
            i = 0;
            Cluster = file->startcluster;                    
        }

        // Follow chain to find cluster to read
        for ( ;i<ClusterIdx; i++)
800088ae:	e0 6c 1d 04 	mov	r12,7428
800088b2:	fe b0 fd d7 	rcall	80008460 <fatfs_cache_set_next_cluster>
800088b6:	2f f7       	sub	r7,-1

            Cluster = nextCluster;
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
800088b8:	40 04       	lddsp	r4,sp[0x0]
800088ba:	0e 35       	cp.w	r5,r7
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
800088bc:	fe 9b ff e8 	brhi	8000888c <_read_sectors+0x4c>
        }

        // Record current cluster lookup details (if valid)
        if (Cluster != FAT32_LAST_CLUSTER)
        {
            file->last_fat_lookup.CurrentCluster = Cluster;
800088c0:	5b f4       	cp.w	r4,-1
800088c2:	c1 a0       	breq	800088f6 <_read_sectors+0xb6>
    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
        return 0;

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;
800088c4:	ed 45 02 28 	st.w	r6[552],r5
800088c8:	ed 44 02 2c 	st.w	r6[556],r4

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
800088cc:	08 9b       	mov	r11,r4
800088ce:	e0 6c 1d 04 	mov	r12,7428
800088d2:	fe b0 fa cd 	rcall	80007e6c <fatfs_lba_of_cluster>
800088d6:	04 99       	mov	r9,r2
800088d8:	f8 01 00 0b 	add	r11,r12,r1
        return count;
    else
        return 0;
}
800088dc:	00 9a       	mov	r10,r0
800088de:	e0 6c 1d 04 	mov	r12,7428
    if ((Sector + count) > _fs.sectors_per_cluster)
        count = _fs.sectors_per_cluster - Sector;

    // Quick lookup for next link in the chain
    if (ClusterIdx == file->last_fat_lookup.ClusterIdx)
        Cluster = file->last_fat_lookup.CurrentCluster;
800088e2:	fe b0 fa da 	rcall	80007e96 <fatfs_sector_read>
            file->last_fat_lookup.ClusterIdx = ClusterIdx;
        }
    }

    // If end of cluster chain then return false
    if (Cluster == FAT32_LAST_CLUSTER) 
800088e6:	c0 80       	breq	800088f6 <_read_sectors+0xb6>
800088e8:	04 9c       	mov	r12,r2

    // Calculate sector address
    lba = fatfs_lba_of_cluster(&_fs, Cluster) + Sector;

    // Read sector of file
    if (fatfs_sector_read(&_fs, lba, buffer, count))
800088ea:	2f fd       	sub	sp,-4
        return count;
    else
        return 0;
}
800088ec:	d8 32       	popm	r0-r7,pc
800088ee:	f8 f4 02 2c 	ld.w	r4,r12[556]
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
800088f2:	5b f4       	cp.w	r4,-1
800088f4:	ce c1       	brne	800088cc <_read_sectors+0x8c>
800088f6:	30 02       	mov	r2,0
800088f8:	04 9c       	mov	r12,r2
        {
            i = file->last_fat_lookup.ClusterIdx;
            Cluster = file->last_fat_lookup.CurrentCluster;
800088fa:	2f fd       	sub	sp,-4
800088fc:	d8 32       	popm	r0-r7,pc
        Cluster = file->last_fat_lookup.CurrentCluster;
    // Else walk the chain
    else
    {
        // Starting from last recorded cluster?
        if (ClusterIdx && ClusterIdx == file->last_fat_lookup.ClusterIdx + 1)
800088fe:	ee c8 ff ff 	sub	r8,r7,-1
80008902:	08 38       	cp.w	r8,r4
80008904:	cb 81       	brne	80008874 <_read_sectors+0x34>
80008906:	f8 f4 02 2c 	ld.w	r4,r12[556]
8000890a:	cb 7b       	rjmp	80008878 <_read_sectors+0x38>

8000890c <fl_fwrite>:
8000890c:	d4 31       	pushm	r0-r7,lr
8000890e:	e0 68 29 f4 	mov	r8,10740
80008912:	18 90       	mov	r0,r12
80008914:	16 96       	mov	r6,r11
80008916:	14 92       	mov	r2,r10
    uint8 *buffer = (uint8 *)data;
    uint32 bytesWritten = 0;
    uint32 copyCount;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008918:	12 97       	mov	r7,r9
8000891a:	70 08       	ld.w	r8,r8[0x0]
8000891c:	58 08       	cp.w	r8,0
8000891e:	e0 80 00 9e 	breq	80008a5a <fl_fwrite+0x14e>

    if (!file)
80008922:	58 07       	cp.w	r7,0
80008924:	e0 80 00 a0 	breq	80008a64 <fl_fwrite+0x158>
        return -1;

    FL_LOCK(&_fs);
80008928:	e0 69 1d 04 	mov	r9,7428
8000892c:	72 f8       	ld.w	r8,r9[0x3c]
8000892e:	58 08       	cp.w	r8,0

    // No write permissions
    if (!(file->flags & FILE_WRITE))
80008930:	c0 20       	breq	80008934 <fl_fwrite+0x28>
80008932:	5d 18       	icall	r8
80008934:	ef 38 04 38 	ld.ub	r8,r7[1080]
80008938:	ed b8 00 01 	bld	r8,0x1
        FL_UNLOCK(&_fs);
        return -1;
    }

    // Append writes to end of file
    if (file->flags & FILE_APPEND)
8000893c:	e0 81 00 97 	brne	80008a6a <fl_fwrite+0x15e>
80008940:	ed b8 00 02 	bld	r8,0x2
        file->bytenum = file->filelength;
80008944:	ef fa 10 02 	ld.wne	r10,r7[0x8]
80008948:	ef fa 00 03 	ld.weq	r10,r7[0xc]
int fl_fwrite(const void * data, int size, int count, void *f )
{
    FL_FILE *file = (FL_FILE *)f;
    uint32 sector;
    uint32 offset;    
    uint32 length = (size*count);
8000894c:	ef fa 0a 02 	st.weq	r7[0x8],r10
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesWritten < length)
80008950:	ad 32       	mul	r2,r6

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
80008952:	58 02       	cp.w	r2,0
80008954:	c3 b0       	breq	800089ca <fl_fwrite+0xbe>
    if (file->flags & FILE_APPEND)
        file->bytenum = file->filelength;
    // Else write to current position

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;
80008956:	e7 da c0 09 	bfextu	r3,r10,0x0,0x9
                    // NOTE: This does not have succeed; if last sector of file
                    // reached, no valid data will be read in, but write will 
                    // allocate some more space for new data.

                    // Get LBA of sector offset within file
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
8000895a:	f4 05 16 09 	lsr	r5,r10,0x9
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);    
8000895e:	ee c1 fd d0 	sub	r1,r7,-560
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesWritten < length)
    {
        // Whole sector or more to be written?
        if ((offset == 0) && ((length - bytesWritten) >= FAT_SECTOR_SIZE))
80008962:	30 06       	mov	r6,0

            // Increment file pointer
            file->bytenum += copyCount;

            // Move onto next sector and reset copy offset
            sector+= sectorsWrote;
80008964:	58 03       	cp.w	r3,0
                break;
        }
        else
        {
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
80008966:	c6 60       	breq	80008a32 <fl_fwrite+0x126>
80008968:	04 94       	mov	r4,r2
8000896a:	e0 68 02 00 	mov	r8,512
8000896e:	06 18       	sub	r8,r3
80008970:	10 34       	cp.w	r4,r8
            // Only require some of this sector?
            if (copyCount > (length - bytesWritten))
                copyCount = (length - bytesWritten);

            // Do we need to read a new sector?
            if (file->file_data_address != sector)
80008972:	f0 04 17 b0 	movhi	r4,r8
80008976:	ee f8 04 30 	ld.w	r8,r7[1072]
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
8000897a:	0a 38       	cp.w	r8,r5
8000897c:	c1 30       	breq	800089a2 <fl_fwrite+0x96>
8000897e:	ee f8 04 34 	ld.w	r8,r7[1076]
                    fl_fflush(file);

                // If we plan to overwrite the whole sector, we don't need to read it first!
                if (copyCount != FAT_SECTOR_SIZE)
80008982:	58 08       	cp.w	r8,0
80008984:	c5 e1       	brne	80008a40 <fl_fwrite+0x134>
80008986:	e0 44 02 00 	cp.w	r4,512
                    // NOTE: This does not have succeed; if last sector of file
                    // reached, no valid data will be read in, but write will 
                    // allocate some more space for new data.

                    // Get LBA of sector offset within file
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
8000898a:	c0 70       	breq	80008998 <fl_fwrite+0x8c>
8000898c:	30 19       	mov	r9,1
8000898e:	02 9a       	mov	r10,r1
80008990:	0a 9b       	mov	r11,r5
80008992:	0e 9c       	mov	r12,r7
80008994:	c5 6f       	rcall	80008840 <_read_sectors>
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);    
                }

                file->file_data_address = sector;
                file->file_data_dirty = 0;
80008996:	c5 80       	breq	80008a46 <fl_fwrite+0x13a>
                    // Get LBA of sector offset within file
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);    
                }

                file->file_data_address = sector;
80008998:	30 08       	mov	r8,0
8000899a:	ef 45 04 30 	st.w	r7[1072],r5
                file->file_data_dirty = 0;
8000899e:	ef 48 04 34 	st.w	r7[1076],r8
            }

            // Copy from application buffer into sector buffer
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);
800089a2:	e2 03 00 0c 	add	r12,r1,r3
800089a6:	e0 06 00 0b 	add	r11,r0,r6
800089aa:	08 9a       	mov	r10,r4
800089ac:	e0 a0 0e ec 	rcall	8000a784 <memcpy>

            // Mark buffer as dirty
            file->file_data_dirty = 1;
800089b0:	6e 28       	ld.w	r8,r7[0x8]
        
            // Increase total read count 
            bytesWritten += copyCount;

            // Increment file pointer
            file->bytenum += copyCount;
800089b2:	30 19       	mov	r9,1

            // Copy from application buffer into sector buffer
            memcpy((uint8*)(file->file_data_sector + offset), (uint8*)(buffer + bytesWritten), copyCount);

            // Mark buffer as dirty
            file->file_data_dirty = 1;
800089b4:	08 08       	add	r8,r4
800089b6:	ef 49 04 34 	st.w	r7[1076],r9

            // Increment file pointer
            file->bytenum += copyCount;

            // Move onto next sector and reset copy offset
            sector++;
800089ba:	8f 28       	st.w	r7[0x8],r8

            // Mark buffer as dirty
            file->file_data_dirty = 1;
        
            // Increase total read count 
            bytesWritten += copyCount;
800089bc:	2f f5       	sub	r5,-1

            // Increment file pointer
            file->bytenum += copyCount;

            // Move onto next sector and reset copy offset
            sector++;
800089be:	08 06       	add	r6,r4
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesWritten < length)
800089c0:	30 03       	mov	r3,0
800089c2:	0c 32       	cp.w	r2,r6
800089c4:	e0 8b 00 37 	brhi	80008a32 <fl_fwrite+0x126>
            offset = 0;
        }
    }

    // Write increased extent of the file?
    if (file->bytenum > file->filelength)
800089c8:	10 9a       	mov	r10,r8
    {
        // Increase file size to new point
        file->filelength = file->bytenum;
800089ca:	6e 38       	ld.w	r8,r7[0xc]
800089cc:	14 38       	cp.w	r8,r10
800089ce:	ef fa 3a 03 	st.wcs	r7[0xc],r10

        // We are changing the file length and this 
        // will need to be writen back at some point
        file->filelength_changed = 1;
800089d2:	f9 b8 03 01 	movlo	r8,1
800089d6:	ef f8 3a 04 	st.wcs	r7[0x10],r8
    }

    FL_UNLOCK(&_fs);
800089da:	e0 69 1d 04 	mov	r9,7428
800089de:	73 08       	ld.w	r8,r9[0x40]
800089e0:	58 08       	cp.w	r8,0

    return (size*count);
}
800089e2:	c0 20       	breq	800089e6 <fl_fwrite+0xda>
800089e4:	5d 18       	icall	r8
        if ((offset == 0) && ((length - bytesWritten) >= FAT_SECTOR_SIZE))
        {
            uint32 sectorsWrote;

            // Buffered sector, flush back to disk
            if (file->file_data_address != 0xFFFFFFFF)
800089e6:	04 9c       	mov	r12,r2
800089e8:	d8 32       	popm	r0-r7,pc
800089ea:	ee f8 04 30 	ld.w	r8,r7[1072]
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
800089ee:	5b f8       	cp.w	r8,-1
800089f0:	c0 b0       	breq	80008a06 <fl_fwrite+0xfa>
800089f2:	ee f8 04 34 	ld.w	r8,r7[1076]
                    fl_fflush(file);

                file->file_data_address = 0xFFFFFFFF;
800089f6:	58 08       	cp.w	r8,0
800089f8:	c2 e1       	brne	80008a54 <fl_fwrite+0x148>
800089fa:	3f f8       	mov	r8,-1
                file->file_data_dirty = 0;
800089fc:	ef 48 04 30 	st.w	r7[1072],r8
80008a00:	30 08       	mov	r8,0
            }

            // Write as many sectors as possible
            sectorsWrote = _write_sectors(file, sector, (uint8*)(buffer + bytesWritten), (length - bytesWritten) / FAT_SECTOR_SIZE);
80008a02:	ef 48 04 34 	st.w	r7[1076],r8
80008a06:	e8 09 16 09 	lsr	r9,r4,0x9
80008a0a:	e0 06 00 0a 	add	r10,r0,r6
80008a0e:	0a 9b       	mov	r11,r5
80008a10:	0e 9c       	mov	r12,r7

            // Increase total read count 
            bytesWritten += copyCount;

            // Increment file pointer
            file->bytenum += copyCount;
80008a12:	c7 3e       	rcall	800086f8 <_write_sectors>
                file->file_data_dirty = 0;
            }

            // Write as many sectors as possible
            sectorsWrote = _write_sectors(file, sector, (uint8*)(buffer + bytesWritten), (length - bytesWritten) / FAT_SECTOR_SIZE);
            copyCount = FAT_SECTOR_SIZE * sectorsWrote;
80008a14:	6e 28       	ld.w	r8,r7[0x8]
80008a16:	f8 09 15 09 	lsl	r9,r12,0x9

            // Increase total read count 
            bytesWritten += copyCount;

            // Increment file pointer
            file->bytenum += copyCount;
80008a1a:	f2 08 00 08 	add	r8,r9,r8
80008a1e:	8f 28       	st.w	r7[0x8],r8

            // Move onto next sector and reset copy offset
            sector+= sectorsWrote;
            offset = 0;

            if (!sectorsWrote)
80008a20:	10 9a       	mov	r10,r8
80008a22:	58 0c       	cp.w	r12,0
            // Write as many sectors as possible
            sectorsWrote = _write_sectors(file, sector, (uint8*)(buffer + bytesWritten), (length - bytesWritten) / FAT_SECTOR_SIZE);
            copyCount = FAT_SECTOR_SIZE * sectorsWrote;

            // Increase total read count 
            bytesWritten += copyCount;
80008a24:	cd 30       	breq	800089ca <fl_fwrite+0xbe>

            // Increment file pointer
            file->bytenum += copyCount;

            // Move onto next sector and reset copy offset
            sector+= sectorsWrote;
80008a26:	12 06       	add	r6,r9

            // Increment file pointer
            file->bytenum += copyCount;

            // Move onto next sector and reset copy offset
            sector++;
80008a28:	18 05       	add	r5,r12
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesWritten < length)
80008a2a:	30 03       	mov	r3,0
80008a2c:	0c 32       	cp.w	r2,r6
80008a2e:	fe 98 ff cd 	brls	800089c8 <fl_fwrite+0xbc>
    {
        // Whole sector or more to be written?
        if ((offset == 0) && ((length - bytesWritten) >= FAT_SECTOR_SIZE))
80008a32:	e4 06 01 04 	sub	r4,r2,r6
80008a36:	e0 44 01 ff 	cp.w	r4,511
80008a3a:	fe 98 ff 98 	brls	8000896a <fl_fwrite+0x5e>
            // Do we need to read a new sector?
            if (file->file_data_address != sector)
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);
80008a3e:	cd 6b       	rjmp	800089ea <fl_fwrite+0xde>
80008a40:	0e 9c       	mov	r12,r7
80008a42:	cd 7e       	rcall	800087f0 <fl_fflush>
80008a44:	ca 1b       	rjmp	80008986 <fl_fwrite+0x7a>
                    // reached, no valid data will be read in, but write will 
                    // allocate some more space for new data.

                    // Get LBA of sector offset within file
                    if (!_read_sectors(file, sector, file->file_data_sector, 1))
                        memset(file->file_data_sector, 0x00, FAT_SECTOR_SIZE);    
80008a46:	18 9b       	mov	r11,r12
80008a48:	e0 6a 02 00 	mov	r10,512
80008a4c:	02 9c       	mov	r12,r1
80008a4e:	e0 a0 0f 3f 	rcall	8000a8cc <memset>
80008a52:	ca 3b       	rjmp	80008998 <fl_fwrite+0x8c>
            // Buffered sector, flush back to disk
            if (file->file_data_address != 0xFFFFFFFF)
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);
80008a54:	0e 9c       	mov	r12,r7
80008a56:	cc de       	rcall	800087f0 <fl_fflush>
80008a58:	cd 1b       	rjmp	800089fa <fl_fwrite+0xee>
80008a5a:	fe b0 fd 8b 	rcall	80008570 <fl_init>
    uint8 *buffer = (uint8 *)data;
    uint32 bytesWritten = 0;
    uint32 copyCount;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008a5e:	58 07       	cp.w	r7,0

    if (!file)
80008a60:	fe 91 ff 64 	brne	80008928 <fl_fwrite+0x1c>
80008a64:	3f f2       	mov	r2,-1
        // We are changing the file length and this 
        // will need to be writen back at some point
        file->filelength_changed = 1;
    }

    FL_UNLOCK(&_fs);
80008a66:	04 9c       	mov	r12,r2

    return (size*count);
}
80008a68:	d8 32       	popm	r0-r7,pc
80008a6a:	e0 69 1d 04 	mov	r9,7428
    FL_LOCK(&_fs);

    // No write permissions
    if (!(file->flags & FILE_WRITE))
    {
        FL_UNLOCK(&_fs);
80008a6e:	73 08       	ld.w	r8,r9[0x40]
80008a70:	58 08       	cp.w	r8,0
80008a72:	cf 90       	breq	80008a64 <fl_fwrite+0x158>
80008a74:	5d 18       	icall	r8
80008a76:	3f f2       	mov	r2,-1
80008a78:	cb 7b       	rjmp	800089e6 <fl_fwrite+0xda>
80008a7a:	d7 03       	nop

80008a7c <fl_fputs>:
80008a7c:	eb cd 40 c0 	pushm	r6-r7,lr
80008a80:	16 96       	mov	r6,r11
80008a82:	18 97       	mov	r7,r12
80008a84:	e0 a0 0f 3e 	rcall	8000a900 <strlen>
80008a88:	0c 99       	mov	r9,r6
80008a8a:	18 9a       	mov	r10,r12
80008a8c:	30 1b       	mov	r11,1
80008a8e:	0e 9c       	mov	r12,r7
80008a90:	c3 ef       	rcall	8000890c <fl_fwrite>
80008a92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008a96:	d7 03       	nop

80008a98 <fl_fread>:
80008a98:	eb cd 40 fe 	pushm	r1-r7,lr

    if (res == len)
        return len;
    else
        return res;
}
80008a9c:	20 2d       	sub	sp,8
80008a9e:	e0 68 29 f4 	mov	r8,10740
}
//-----------------------------------------------------------------------------
// fl_fread: Read a block of data from the file
//-----------------------------------------------------------------------------
int fl_fread(void * buffer, int size, int length, void *f )
{
80008aa2:	18 95       	mov	r5,r12
    int bytesRead = 0;    

    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008aa4:	12 97       	mov	r7,r9
80008aa6:	70 08       	ld.w	r8,r8[0x0]
80008aa8:	58 08       	cp.w	r8,0

    if (buffer==NULL || file==NULL)
80008aaa:	c0 d0       	breq	80008ac4 <fl_fread+0x2c>
80008aac:	58 07       	cp.w	r7,0
80008aae:	5f 09       	sreq	r9
80008ab0:	58 05       	cp.w	r5,0
80008ab2:	5f 08       	sreq	r8
80008ab4:	f3 e8 10 08 	or	r8,r9,r8
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
80008ab8:	c0 d0       	breq	80008ad2 <fl_fread+0x3a>
        // Increment file pointer
        file->bytenum += copyCount;
    }    

    return bytesRead;
}
80008aba:	3f f6       	mov	r6,-1
80008abc:	0c 9c       	mov	r12,r6
80008abe:	2f ed       	sub	sp,-8
80008ac0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
    int bytesRead = 0;    

    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008ac4:	50 1b       	stdsp	sp[0x4],r11
80008ac6:	50 0a       	stdsp	sp[0x0],r10
80008ac8:	fe b0 fd 54 	rcall	80008570 <fl_init>
80008acc:	40 0a       	lddsp	r10,sp[0x0]
80008ace:	40 1b       	lddsp	r11,sp[0x4]

    if (buffer==NULL || file==NULL)
        return -1;

    // No read permissions
    if (!(file->flags & FILE_READ))
80008ad0:	ce eb       	rjmp	80008aac <fl_fread+0x14>
80008ad2:	ef 38 04 38 	ld.ub	r8,r7[1080]
80008ad6:	ed b8 00 00 	bld	r8,0x0
int fl_fread(void * buffer, int size, int length, void *f )
{
    uint32 sector;
    uint32 offset;
    int copyCount;
    int count = size * length;
80008ada:	cf 01       	brne	80008aba <fl_fread+0x22>
80008adc:	f4 0b 02 44 	mul	r4,r10,r11
    // No read permissions
    if (!(file->flags & FILE_READ))
        return -1;

    // Nothing to be done
    if (!count)
80008ae0:	58 04       	cp.w	r4,0
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
80008ae2:	c0 31       	brne	80008ae8 <fl_fread+0x50>
80008ae4:	30 06       	mov	r6,0
    // Nothing to be done
    if (!count)
        return 0;

    // Check if read starts past end of file
    if (file->bytenum >= file->filelength)
80008ae6:	ce bb       	rjmp	80008abc <fl_fread+0x24>
80008ae8:	6e 23       	ld.w	r3,r7[0x8]
80008aea:	6e 38       	ld.w	r8,r7[0xc]
80008aec:	10 33       	cp.w	r3,r8
        return -1;

    // Limit to file size
    if ( (file->bytenum + count) > file->filelength )
80008aee:	ce 62       	brcc	80008aba <fl_fread+0x22>
80008af0:	e8 03 00 09 	add	r9,r4,r3
        count = file->filelength - file->bytenum;
80008af4:	12 38       	cp.w	r8,r9
80008af6:	f1 d3 e3 14 	subcs	r4,r8,r3
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
80008afa:	58 04       	cp.w	r4,0
80008afc:	fe 9a ff f4 	brle	80008ae4 <fl_fread+0x4c>

    // Calculate start sector
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;
80008b00:	e5 d3 c0 09 	bfextu	r2,r3,0x0,0x9
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
80008b04:	ee c1 fd d0 	sub	r1,r7,-560
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
80008b08:	a9 93       	lsr	r3,0x9
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
80008b0a:	30 06       	mov	r6,0
80008b0c:	58 02       	cp.w	r2,0
80008b0e:	c2 b1       	brne	80008b64 <fl_fread+0xcc>
                // Flush un-written data to file
                if (file->file_data_dirty)
                    fl_fflush(file);

                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
80008b10:	c2 48       	rjmp	80008b58 <fl_fread+0xc0>
80008b12:	30 19       	mov	r9,1
80008b14:	02 9a       	mov	r10,r1
80008b16:	06 9b       	mov	r11,r3
80008b18:	0e 9c       	mov	r12,r7
80008b1a:	c9 3e       	rcall	80008840 <_read_sectors>
80008b1c:	cd 00       	breq	80008abc <fl_fread+0x24>
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
                file->file_data_dirty = 0;
80008b1e:	30 08       	mov	r8,0
                // Get LBA of sector offset within file
                if (!_read_sectors(file, sector, file->file_data_sector, 1))
                    // Read failed - out of range (probably)
                    break;

                file->file_data_address = sector;
80008b20:	ef 43 04 30 	st.w	r7[1072],r3
                file->file_data_dirty = 0;
80008b24:	ef 48 04 34 	st.w	r7[1076],r8
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
80008b28:	e0 68 02 00 	mov	r8,512
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
80008b2c:	e2 02 00 0b 	add	r11,r1,r2
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
80008b30:	f0 02 01 02 	sub	r2,r8,r2
80008b34:	e8 06 01 08 	sub	r8,r4,r6

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);

            // Move onto next sector and reset copy offset
            sector++;
80008b38:	2f f3       	sub	r3,-1
                file->file_data_address = sector;
                file->file_data_dirty = 0;
            }
        
            // We have upto one sector to copy
            copyCount = FAT_SECTOR_SIZE - offset;
80008b3a:	e4 08 0d 42 	min	r2,r2,r8
            // Only require some of this sector?
            if (copyCount > (count - bytesRead))
                copyCount = (count - bytesRead);

            // Copy to application buffer
            memcpy( (uint8*)((uint8*)buffer + bytesRead), (uint8*)(file->file_data_sector + offset), copyCount);
80008b3e:	ea 06 00 0c 	add	r12,r5,r6
80008b42:	04 9a       	mov	r10,r2
80008b44:	e0 a0 0e 20 	rcall	8000a784 <memcpy>
    
        // Increase total read count 
        bytesRead += copyCount;

        // Increment file pointer
        file->bytenum += copyCount;
80008b48:	6e 28       	ld.w	r8,r7[0x8]
80008b4a:	04 08       	add	r8,r2
80008b4c:	8f 28       	st.w	r7[0x8],r8
            sector++;
            offset = 0;
        }
    
        // Increase total read count 
        bytesRead += copyCount;
80008b4e:	04 06       	add	r6,r2

        // Increment file pointer
        file->bytenum += copyCount;
80008b50:	30 02       	mov	r2,0
    sector = file->bytenum / FAT_SECTOR_SIZE;

    // Offset to start copying data from first sector
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
80008b52:	0c 34       	cp.w	r4,r6
80008b54:	fe 9a ff b4 	brle	80008abc <fl_fread+0x24>
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
80008b58:	e8 06 01 09 	sub	r9,r4,r6
80008b5c:	e0 49 01 ff 	cp.w	r9,511
80008b60:	e0 89 00 0d 	brgt	80008b7a <fl_fread+0xe2>
                break;
        }
        else
        {
            // Do we need to re-read the sector?
            if (file->file_data_address != sector)
80008b64:	ee f8 04 30 	ld.w	r8,r7[1072]
80008b68:	06 38       	cp.w	r8,r3
80008b6a:	cd f0       	breq	80008b28 <fl_fread+0x90>
            {
                // Flush un-written data to file
                if (file->file_data_dirty)
80008b6c:	ee f8 04 34 	ld.w	r8,r7[1076]
80008b70:	58 08       	cp.w	r8,0
80008b72:	cd 00       	breq	80008b12 <fl_fread+0x7a>
                    fl_fflush(file);
80008b74:	0e 9c       	mov	r12,r7
80008b76:	c3 de       	rcall	800087f0 <fl_fflush>
80008b78:	cc db       	rjmp	80008b12 <fl_fread+0x7a>
80008b7a:	a9 59       	asr	r9,0x9
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
        {
            // Read as many sectors as possible into target buffer
            uint32 sectorsRead = _read_sectors(file, sector, (uint8*)((uint8*)buffer + bytesRead), (count - bytesRead) / FAT_SECTOR_SIZE);        
80008b7c:	ea 06 00 0a 	add	r10,r5,r6
80008b80:	06 9b       	mov	r11,r3
80008b82:	0e 9c       	mov	r12,r7
80008b84:	c5 ee       	rcall	80008840 <_read_sectors>
80008b86:	c9 b0       	breq	80008abc <fl_fread+0x24>
80008b88:	18 03       	add	r3,r12
            if (sectorsRead)
80008b8a:	f8 02 15 09 	lsl	r2,r12,0x9
            {
                // We have upto one sector to copy
                copyCount = FAT_SECTOR_SIZE * sectorsRead;
80008b8e:	cd db       	rjmp	80008b48 <fl_fread+0xb0>

80008b90 <fl_fgetc>:
80008b90:	d4 01       	pushm	lr
    offset = file->bytenum % FAT_SECTOR_SIZE;

    while (bytesRead < count)
    {        
        // Read whole sector, read from media directly into target buffer
        if ((offset == 0) && ((count - bytesRead) >= FAT_SECTOR_SIZE))
80008b92:	20 1d       	sub	sp,4
80008b94:	30 08       	mov	r8,0
80008b96:	18 99       	mov	r9,r12
80008b98:	30 1a       	mov	r10,1
80008b9a:	fa cc ff fc 	sub	r12,sp,-4
80008b9e:	14 9b       	mov	r11,r10
80008ba0:	18 f8       	st.b	--r12,r8
80008ba2:	c7 bf       	rcall	80008a98 <fl_fread>
80008ba4:	58 1c       	cp.w	r12,1
80008ba6:	fb fc 08 03 	ld.ubeq	r12,sp[0x3]
    int res;
    uint8 data = 0;
    
    res = fl_fread(&data, 1, 1, f);
    if (res == 1)
        return (int)data;
80008baa:	2f fd       	sub	sp,-4
    else
        return res;
}
80008bac:	d8 02       	popm	pc
80008bae:	d7 03       	nop

80008bb0 <fl_fclose>:
80008bb0:	eb cd 40 c0 	pushm	r6-r7,lr
void fl_fclose(void *f)
{
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008bb4:	e0 68 29 f4 	mov	r8,10740
80008bb8:	18 97       	mov	r7,r12
80008bba:	70 08       	ld.w	r8,r8[0x0]
80008bbc:	58 08       	cp.w	r8,0

    if (file)
80008bbe:	c2 50       	breq	80008c08 <fl_fclose+0x58>
80008bc0:	58 07       	cp.w	r7,0
    {
        FL_LOCK(&_fs);
80008bc2:	c2 10       	breq	80008c04 <fl_fclose+0x54>
80008bc4:	e0 66 1d 04 	mov	r6,7428
80008bc8:	6c f8       	ld.w	r8,r6[0x3c]
80008bca:	58 08       	cp.w	r8,0

        // Flush un-written data to file
        fl_fflush(f);
80008bcc:	c0 20       	breq	80008bd0 <fl_fclose+0x20>
80008bce:	5d 18       	icall	r8
80008bd0:	0e 9c       	mov	r12,r7

        // File size changed?
        if (file->filelength_changed)
80008bd2:	c0 fe       	rcall	800087f0 <fl_fflush>
80008bd4:	6e 48       	ld.w	r8,r7[0x10]
80008bd6:	58 08       	cp.w	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
80008bd8:	c1 b1       	brne	80008c0e <fl_fclose+0x5e>
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
        file->filelength_changed = 0;
80008bda:	30 08       	mov	r8,0
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
#endif
            file->filelength_changed = 0;
        }

        file->bytenum = 0;
80008bdc:	8f 48       	st.w	r7[0x10],r8
        file->filelength = 0;
80008bde:	8f 28       	st.w	r7[0x8],r8
        file->startcluster = 0;
80008be0:	8f 38       	st.w	r7[0xc],r8
        file->file_data_address = 0xFFFFFFFF;
        file->file_data_dirty = 0;
80008be2:	8f 18       	st.w	r7[0x4],r8
80008be4:	ef 48 04 34 	st.w	r7[1076],r8
        file->filelength_changed = 0;

        // Free file handle
        _free_file(file);
80008be8:	3f f8       	mov	r8,-1
        }

        file->bytenum = 0;
        file->filelength = 0;
        file->startcluster = 0;
        file->file_data_address = 0xFFFFFFFF;
80008bea:	0e 9c       	mov	r12,r7
80008bec:	ef 48 04 30 	st.w	r7[1072],r8
        file->file_data_dirty = 0;
        file->filelength_changed = 0;

        // Free file handle
        _free_file(file);
80008bf0:	fe b0 fc 7a 	rcall	800084e4 <_free_file>

        fatfs_fat_purge(&_fs);
80008bf4:	e0 6c 1d 04 	mov	r12,7428

        FL_UNLOCK(&_fs);
80008bf8:	e0 a0 06 de 	rcall	800099b4 <fatfs_fat_purge>
80008bfc:	6d 08       	ld.w	r8,r6[0x40]
80008bfe:	58 08       	cp.w	r8,0
80008c00:	c0 20       	breq	80008c04 <fl_fclose+0x54>
80008c02:	5d 18       	icall	r8
void fl_fclose(void *f)
{
    FL_FILE *file = (FL_FILE *)f;

    // If first call to library, initialise
    CHECK_FL_INIT();
80008c04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008c08:	fe b0 fc b4 	rcall	80008570 <fl_init>
        // File size changed?
        if (file->filelength_changed)
        {
#if FATFS_INC_WRITE_SUPPORT
            // Update filesize in directory
            fatfs_update_file_length(&_fs, file->parentcluster, (char*)file->shortfilename, file->filelength);
80008c0c:	cd ab       	rjmp	80008bc0 <fl_fclose+0x10>
80008c0e:	6e 39       	ld.w	r9,r7[0xc]
80008c10:	ee ca fd e4 	sub	r10,r7,-540
80008c14:	6e 0b       	ld.w	r11,r7[0x0]
80008c16:	e0 6c 1d 04 	mov	r12,7428
#endif
            file->filelength_changed = 0;
80008c1a:	fe b0 f9 d3 	rcall	80007fc0 <fatfs_update_file_length>
80008c1e:	30 08       	mov	r8,0
80008c20:	8f 48       	st.w	r7[0x10],r8
80008c22:	cd cb       	rjmp	80008bda <fl_fclose+0x2a>

80008c24 <_open_file>:
80008c24:	d4 21       	pushm	r4-r7,lr
80008c26:	20 8d       	sub	sp,32
80008c28:	18 94       	mov	r4,r12
80008c2a:	fe b0 fc 1d 	rcall	80008464 <_allocate_file>
80008c2e:	18 97       	mov	r7,r12
80008c30:	c7 50       	breq	80008d1a <_open_file+0xf6>
80008c32:	f8 c5 ff ec 	sub	r5,r12,-20
80008c36:	e0 6a 01 04 	mov	r10,260
80008c3a:	30 0b       	mov	r11,0
    file = _allocate_file();
    if (!file)
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
80008c3c:	0a 9c       	mov	r12,r5
80008c3e:	e0 a0 0e 47 	rcall	8000a8cc <memset>
    memset(file->filename, '\0', sizeof(file->filename));
80008c42:	ee c6 fe e8 	sub	r6,r7,-280
80008c46:	e0 6a 01 04 	mov	r10,260
80008c4a:	30 0b       	mov	r11,0
80008c4c:	0c 9c       	mov	r12,r6
80008c4e:	e0 a0 0e 3f 	rcall	8000a8cc <memset>

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)path, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
80008c52:	e0 68 01 04 	mov	r8,260
80008c56:	08 9c       	mov	r12,r4
80008c58:	0c 99       	mov	r9,r6
80008c5a:	10 9a       	mov	r10,r8
80008c5c:	0a 9b       	mov	r11,r5
80008c5e:	e0 a0 06 07 	rcall	8000986c <fatfs_split_path>
80008c62:	5b fc       	cp.w	r12,-1
80008c64:	c6 50       	breq	80008d2e <_open_file+0x10a>
        _free_file(file);
        return NULL;
    }

    // Check if file already open
    if (_check_file_open(file))
80008c66:	0e 9c       	mov	r12,r7
80008c68:	fe b0 fd 26 	rcall	800086b4 <_check_file_open>
80008c6c:	c6 11       	brne	80008d2e <_open_file+0x10a>
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
80008c6e:	ef 38 00 14 	ld.ub	r8,r7[20]
80008c72:	f8 08 18 00 	cp.b	r8,r12
80008c76:	c5 50       	breq	80008d20 <_open_file+0xfc>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
80008c78:	0a 9c       	mov	r12,r5
80008c7a:	0e 9b       	mov	r11,r7
80008c7c:	fe b0 fc d6 	rcall	80008628 <_open_directory>
80008c80:	18 98       	mov	r8,r12
80008c82:	c5 d0       	breq	80008d3c <_open_file+0x118>
        {
            _free_file(file);
            return NULL;
80008c84:	6e 0b       	ld.w	r11,r7[0x0]
        }
    }

    // Using dir cluster address search for filename
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry))
80008c86:	0c 9a       	mov	r10,r6
80008c88:	e0 6c 1d 04 	mov	r12,7428
80008c8c:	1a 96       	mov	r6,sp
80008c8e:	1a 99       	mov	r9,sp
80008c90:	fe b0 fa 18 	rcall	800080c0 <fatfs_get_file_entry>
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
80008c94:	c4 d0       	breq	80008d2e <_open_file+0x10a>
80008c96:	1a 9c       	mov	r12,sp
80008c98:	e0 a0 02 8a 	rcall	800091ac <fatfs_entry_is_file>
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
80008c9c:	c4 90       	breq	80008d2e <_open_file+0x10a>
80008c9e:	1a 9b       	mov	r11,sp
80008ca0:	30 ba       	mov	r10,11
80008ca2:	ee cc fd e4 	sub	r12,r7,-540
80008ca6:	e0 a0 0d 6f 	rcall	8000a784 <memcpy>
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
80008caa:	40 7a       	lddsp	r10,sp[0x1c]
        // Make sure entry is file not dir!
        if (fatfs_entry_is_file(&sfEntry))
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
80008cac:	3f f8       	mov	r8,-1
80008cae:	14 9c       	mov	r12,r10
80008cb0:	f4 06 15 18 	lsl	r6,r10,0x18
80008cb4:	e6 1c 00 ff 	andh	r12,0xff,COH
80008cb8:	ed ea 13 86 	or	r6,r6,r10>>0x18
80008cbc:	e2 1a ff 00 	andl	r10,0xff00,COH
80008cc0:	ed ea 10 8a 	or	r10,r6,r10<<0x8
80008cc4:	f5 ec 12 8a 	or	r10,r10,r12>>0x8
80008cc8:	30 09       	mov	r9,0
            file->bytenum = 0;
80008cca:	8f 3a       	st.w	r7[0xc],r10
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
80008ccc:	8f 29       	st.w	r7[0x8],r9
80008cce:	fb 16 00 14 	ld.uh	r6,sp[20]
80008cd2:	fb 1a 00 1a 	ld.uh	r10,sp[26]
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
80008cd6:	ef 48 02 2c 	st.w	r7[556],r8
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
80008cda:	ef 48 04 30 	st.w	r7[1072],r8
            file->file_data_dirty = 0;
            file->filelength_changed = 0;

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
80008cde:	ef 48 02 28 	st.w	r7[552],r8
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
80008ce2:	ec 08 15 08 	lsl	r8,r6,0x8
80008ce6:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80008cea:	f1 e6 12 86 	or	r6,r8,r6>>0x8
80008cee:	f4 08 15 08 	lsl	r8,r10,0x8
80008cf2:	b1 66       	lsl	r6,0x10
80008cf4:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80008cf8:	f1 ea 12 8a 	or	r10,r8,r10>>0x8
80008cfc:	ec 0a 00 0a 	add	r10,r6,r10

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

            fatfs_cache_init(&_fs, file);
80008d00:	0e 9b       	mov	r11,r7
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
            file->filelength_changed = 0;
80008d02:	e0 6c 1d 04 	mov	r12,7428
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
            file->file_data_address = 0xFFFFFFFF;
            file->file_data_dirty = 0;
80008d06:	8f 49       	st.w	r7[0x10],r9
        {
            // Initialise file details
            memcpy(file->shortfilename, sfEntry.Name, FAT_SFN_SIZE_FULL);
            file->filelength = FAT_HTONL(sfEntry.FileSize);
            file->bytenum = 0;
            file->startcluster = ((FAT_HTONS((uint32)sfEntry.FstClusHI))<<16) + FAT_HTONS(sfEntry.FstClusLO);
80008d08:	ef 49 04 34 	st.w	r7[1076],r9

            // Quick lookup for next link in the chain
            file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
            file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

            fatfs_cache_init(&_fs, file);
80008d0c:	8f 1a       	st.w	r7[0x4],r10

            fatfs_fat_purge(&_fs);
80008d0e:	fe b0 fb a7 	rcall	8000845c <fatfs_cache_init>
80008d12:	e0 6c 1d 04 	mov	r12,7428
            return file;
        }

    _free_file(file);
    return NULL;
}
80008d16:	e0 a0 06 4f 	rcall	800099b4 <fatfs_fat_purge>
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0]==0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
80008d1a:	0e 9c       	mov	r12,r7
80008d1c:	2f 8d       	sub	sp,-32
80008d1e:	d8 22       	popm	r4-r7,pc
80008d20:	e0 6c 1d 04 	mov	r12,7428
80008d24:	fe b0 f9 06 	rcall	80007f30 <fatfs_get_root_cluster>
            fatfs_fat_purge(&_fs);

            return file;
        }

    _free_file(file);
80008d28:	18 9b       	mov	r11,r12
80008d2a:	8f 0c       	st.w	r7[0x0],r12
80008d2c:	ca db       	rjmp	80008c86 <_open_file+0x62>
    return NULL;
}
80008d2e:	0e 9c       	mov	r12,r7
80008d30:	fe b0 fb da 	rcall	800084e4 <_free_file>
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
        {
            _free_file(file);
80008d34:	30 07       	mov	r7,0
80008d36:	0e 9c       	mov	r12,r7
80008d38:	2f 8d       	sub	sp,-32
80008d3a:	d8 22       	popm	r4-r7,pc
            return NULL;
80008d3c:	0e 9c       	mov	r12,r7
80008d3e:	10 97       	mov	r7,r8
80008d40:	fe b0 fb d2 	rcall	800084e4 <_free_file>
80008d44:	ce bb       	rjmp	80008d1a <_open_file+0xf6>
80008d46:	d7 03       	nop

80008d48 <fl_fopen>:
80008d48:	d4 31       	pushm	r0-r7,lr
80008d4a:	20 ed       	sub	sp,56
80008d4c:	e0 68 29 f4 	mov	r8,10740
80008d50:	18 96       	mov	r6,r12
80008d52:	70 08       	ld.w	r8,r8[0x0]
80008d54:	58 08       	cp.w	r8,0
80008d56:	c0 90       	breq	80008d68 <fl_fopen+0x20>
80008d58:	e0 68 1d 00 	mov	r8,7424
80008d5c:	70 08       	ld.w	r8,r8[0x0]
80008d5e:	58 08       	cp.w	r8,0
80008d60:	c0 d1       	brne	80008d7a <fl_fopen+0x32>
80008d62:	30 0c       	mov	r12,0
80008d64:	2f 2d       	sub	sp,-56
80008d66:	d8 32       	popm	r0-r7,pc
80008d68:	50 0b       	stdsp	sp[0x0],r11
80008d6a:	fe b0 fc 03 	rcall	80008570 <fl_init>
80008d6e:	e0 68 1d 00 	mov	r8,7424
80008d72:	40 0b       	lddsp	r11,sp[0x0]
    uint8 flags = 0;

    // If first call to library, initialise
    CHECK_FL_INIT();

    if (!_filelib_valid)
80008d74:	70 08       	ld.w	r8,r8[0x0]
80008d76:	58 08       	cp.w	r8,0
80008d78:	cf 50       	breq	80008d62 <fl_fopen+0x1a>
        return NULL;

    if (!path || !mode)
80008d7a:	58 0b       	cp.w	r11,0
80008d7c:	5f 09       	sreq	r9
80008d7e:	58 06       	cp.w	r6,0
80008d80:	5f 08       	sreq	r8
80008d82:	f3 e8 10 08 	or	r8,r9,r8
80008d86:	ce e1       	brne	80008d62 <fl_fopen+0x1a>
    FL_UNLOCK(&_fs);
}
//-----------------------------------------------------------------------------
// fopen: Open or Create a file for reading or writing
//-----------------------------------------------------------------------------
void* fl_fopen(const char *path, const char *mode)
80008d88:	16 9c       	mov	r12,r11
80008d8a:	30 07       	mov	r7,0
80008d8c:	50 0b       	stdsp	sp[0x0],r11
80008d8e:	e0 a0 0d b9 	rcall	8000a900 <strlen>
80008d92:	0e 98       	mov	r8,r7
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
    {
        switch (mode[i])
80008d94:	fe ca c7 34 	sub	r10,pc,-14540
80008d98:	40 0b       	lddsp	r11,sp[0x0]
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008d9a:	18 38       	cp.w	r8,r12
80008d9c:	c1 e4       	brge	80008dd8 <fl_fopen+0x90>
    {
        switch (mode[i])
80008d9e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80008da2:	22 b9       	sub	r9,43
80008da4:	e0 49 00 4c 	cp.w	r9,76
80008da8:	e0 8b 00 08 	brhi	80008db8 <fl_fopen+0x70>
80008dac:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
80008db0:	ed b7 00 00 	bld	r7,0x0
80008db4:	c3 81       	brne	80008e24 <fl_fopen+0xdc>
                flags |= FILE_WRITE;
80008db6:	a1 b7       	sbr	r7,0x1
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008db8:	2f f8       	sub	r8,-1
80008dba:	cf 0b       	rjmp	80008d9a <fl_fopen+0x52>
            break;
        case 'w':
        case 'W':
            flags |= FILE_WRITE;
            flags |= FILE_ERASE;
            flags |= FILE_CREATE;
80008dbc:	e8 17 00 32 	orl	r7,0x32
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008dc0:	2f f8       	sub	r8,-1
80008dc2:	ce cb       	rjmp	80008d9a <fl_fopen+0x52>
    {
        switch (mode[i])
        {
        case 'r':
        case 'R':
            flags |= FILE_READ;
80008dc4:	a1 a7       	sbr	r7,0x0
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008dc6:	2f f8       	sub	r8,-1
80008dc8:	ce 9b       	rjmp	80008d9a <fl_fopen+0x52>
                flags |= FILE_CREATE;
            }
            break;
        case 'b':
        case 'B':
            flags |= FILE_BINARY;
80008dca:	a3 b7       	sbr	r7,0x3
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008dcc:	2f f8       	sub	r8,-1
80008dce:	ce 6b       	rjmp	80008d9a <fl_fopen+0x52>
            break;
        case 'a':
        case 'A':
            flags |= FILE_WRITE;
            flags |= FILE_APPEND;
            flags |= FILE_CREATE;
80008dd0:	e8 17 00 26 	orl	r7,0x26
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008dd4:	2f f8       	sub	r8,-1
80008dd6:	ce 2b       	rjmp	80008d9a <fl_fopen+0x52>
    // No write support!
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
80008dd8:	e0 65 1d 04 	mov	r5,7428
80008ddc:	6a e8       	ld.w	r8,r5[0x38]
80008dde:	58 08       	cp.w	r8,0
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);

    FL_LOCK(&_fs);
80008de0:	c3 d0       	breq	80008e5a <fl_fopen+0x112>
80008de2:	6a f8       	ld.w	r8,r5[0x3c]
80008de4:	58 08       	cp.w	r8,0
80008de6:	c0 20       	breq	80008dea <fl_fopen+0xa2>

    // Read
    if (flags & FILE_READ)
80008de8:	5d 18       	icall	r8
80008dea:	e7 d7 c0 01 	bfextu	r3,r7,0x0,0x1
        file = _open_file(path);

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
80008dee:	c2 91       	brne	80008e40 <fl_fopen+0xf8>
80008df0:	0e 92       	mov	r2,r7
80008df2:	e2 12 00 20 	andl	r2,0x20,COH
80008df6:	c3 51       	brne	80008e60 <fl_fopen+0x118>
        file = _create_file(path);
#endif

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
80008df8:	04 94       	mov	r4,r2
80008dfa:	58 03       	cp.w	r3,0
        if ((flags & FILE_CREATE) && !file)
80008dfc:	c2 c1       	brne	80008e54 <fl_fopen+0x10c>
80008dfe:	58 02       	cp.w	r2,0
80008e00:	5f 18       	srne	r8
80008e02:	58 04       	cp.w	r4,0
80008e04:	5f 09       	sreq	r9
80008e06:	10 69       	and	r9,r8
80008e08:	e6 09 18 00 	cp.b	r9,r3
            if (flags & (FILE_WRITE | FILE_APPEND))
80008e0c:	c2 40       	breq	80008e54 <fl_fopen+0x10c>
80008e0e:	0e 98       	mov	r8,r7
80008e10:	e2 18 00 06 	andl	r8,0x6,COH
80008e14:	c1 d1       	brne	80008e4e <fl_fopen+0x106>
                file = _open_file(path);

    if (file)
        file->flags = flags;

    FL_UNLOCK(&_fs);
80008e16:	06 94       	mov	r4,r3
80008e18:	6b 08       	ld.w	r8,r5[0x40]
80008e1a:	58 08       	cp.w	r8,0
80008e1c:	c0 20       	breq	80008e20 <fl_fopen+0xd8>
80008e1e:	5d 18       	icall	r8
80008e20:	08 9c       	mov	r12,r4
            flags |= FILE_CREATE;
            break;
        case '+':
            if (flags & FILE_READ)
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
80008e22:	ca 1b       	rjmp	80008d64 <fl_fopen+0x1c>
80008e24:	ed b7 00 01 	bld	r7,0x1
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
            }
            else if (flags & FILE_APPEND)
80008e28:	c0 80       	breq	80008e38 <fl_fopen+0xf0>
80008e2a:	ed b7 00 02 	bld	r7,0x2
            {
                flags |= FILE_READ;
                flags |= FILE_WRITE;
                flags |= FILE_APPEND;
                flags |= FILE_CREATE;
80008e2e:	cc 51       	brne	80008db8 <fl_fopen+0x70>
80008e30:	e8 17 00 27 	orl	r7,0x27
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008e34:	2f f8       	sub	r8,-1
                flags |= FILE_WRITE;
            else if (flags & FILE_WRITE)
            {
                flags |= FILE_READ;
                flags |= FILE_ERASE;
                flags |= FILE_CREATE;
80008e36:	cb 2b       	rjmp	80008d9a <fl_fopen+0x52>
80008e38:	e8 17 00 31 	orl	r7,0x31
    //        All writing operations are performed at the end of the file, protecting the previous content to be overwritten. 
    //        You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations 
    //        will move it back to the end of file. 
    //        The file is created if it does not exist. 

    for (i=0;i<(int)strlen(mode);i++)
80008e3c:	2f f8       	sub	r8,-1

    FL_LOCK(&_fs);

    // Read
    if (flags & FILE_READ)
        file = _open_file(path);
80008e3e:	ca eb       	rjmp	80008d9a <fl_fopen+0x52>
80008e40:	0c 9c       	mov	r12,r6
80008e42:	cf 1e       	rcall	80008c24 <_open_file>
80008e44:	18 94       	mov	r4,r12

    // Create New
#if FATFS_INC_WRITE_SUPPORT
    if (!file && (flags & FILE_CREATE))
80008e46:	cd 50       	breq	80008df0 <fl_fopen+0xa8>
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);

    if (file)
        file->flags = flags;
80008e48:	e9 67 04 38 	st.b	r4[1080],r7
80008e4c:	ce 6b       	rjmp	80008e18 <fl_fopen+0xd0>

    // Write Existing (and not open due to read or create)
    if (!(flags & FILE_READ))
        if ((flags & FILE_CREATE) && !file)
            if (flags & (FILE_WRITE | FILE_APPEND))
                file = _open_file(path);
80008e4e:	0c 9c       	mov	r12,r6
80008e50:	ce ae       	rcall	80008c24 <_open_file>
80008e52:	18 94       	mov	r4,r12
80008e54:	58 04       	cp.w	r4,0

    if (file)
80008e56:	cf 91       	brne	80008e48 <fl_fopen+0x100>
80008e58:	ce 0b       	rjmp	80008e18 <fl_fopen+0xd0>
80008e5a:	e2 17 00 d9 	andl	r7,0xd9,COH
    flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
#endif

    // No write access - remove write/modify flags
    if (!_fs.disk_io.write_media)
        flags &= ~(FILE_CREATE | FILE_WRITE | FILE_APPEND);
80008e5e:	cc 2b       	rjmp	80008de2 <fl_fopen+0x9a>
80008e60:	6a e4       	ld.w	r4,r5[0x38]
    struct fat_dir_entry sfEntry;
    char shortFilename[FAT_SFN_SIZE_FULL];
    int tailNum = 0;

    // No write access?
    if (!_fs.disk_io.write_media)
80008e62:	58 04       	cp.w	r4,0
80008e64:	cc b0       	breq	80008dfa <fl_fopen+0xb2>
80008e66:	fe b0 fa ff 	rcall	80008464 <_allocate_file>
        return NULL;

    // Allocate a new file handle
    file = _allocate_file();
80008e6a:	18 94       	mov	r4,r12
80008e6c:	cc 70       	breq	80008dfa <fl_fopen+0xb2>
    if (!file)
80008e6e:	f8 c1 ff ec 	sub	r1,r12,-20
        return NULL;

    // Clear filename
    memset(file->path, '\0', sizeof(file->path));
80008e72:	e0 6a 01 04 	mov	r10,260
80008e76:	30 0b       	mov	r11,0
80008e78:	02 9c       	mov	r12,r1
80008e7a:	e0 a0 0d 29 	rcall	8000a8cc <memset>
80008e7e:	e8 c8 fe e8 	sub	r8,r4,-280
    memset(file->filename, '\0', sizeof(file->filename));
80008e82:	e0 6a 01 04 	mov	r10,260
80008e86:	50 28       	stdsp	sp[0x8],r8
80008e88:	30 0b       	mov	r11,0
80008e8a:	10 9c       	mov	r12,r8
80008e8c:	e0 a0 0d 20 	rcall	8000a8cc <memset>
80008e90:	e0 68 01 04 	mov	r8,260

    // Split full path into filename and directory path
    if (fatfs_split_path((char*)filename, file->path, sizeof(file->path), file->filename, sizeof(file->filename)) == -1)
80008e94:	40 29       	lddsp	r9,sp[0x8]
80008e96:	10 9a       	mov	r10,r8
80008e98:	02 9b       	mov	r11,r1
80008e9a:	0c 9c       	mov	r12,r6
80008e9c:	e0 a0 04 e8 	rcall	8000986c <fatfs_split_path>
80008ea0:	5b fc       	cp.w	r12,-1
80008ea2:	e0 80 00 82 	breq	80008fa6 <fl_fopen+0x25e>
        _free_file(file);
        return NULL;
    }

    // Check if file already open
    if (_check_file_open(file))
80008ea6:	08 9c       	mov	r12,r4
80008ea8:	fe b0 fc 06 	rcall	800086b4 <_check_file_open>
80008eac:	c7 d1       	brne	80008fa6 <fl_fopen+0x25e>
        _free_file(file);
        return NULL;
    }

    // If file is in the root dir
    if (file->path[0] == 0)
80008eae:	e9 38 00 14 	ld.ub	r8,r4[20]
80008eb2:	f8 08 18 00 	cp.b	r8,r12
80008eb6:	c6 61       	brne	80008f82 <fl_fopen+0x23a>
        file->parentcluster = fatfs_get_root_cluster(&_fs);
80008eb8:	e0 6c 1d 04 	mov	r12,7428
80008ebc:	fe b0 f8 3a 	rcall	80007f30 <fatfs_get_root_cluster>
80008ec0:	18 9b       	mov	r11,r12
            return NULL;
        }
    }

    // Check if same filename exists in directory
    if (fatfs_get_file_entry(&_fs, file->parentcluster, file->filename,&sfEntry) == 1)
80008ec2:	89 0c       	st.w	r4[0x0],r12
80008ec4:	fa c9 ff f4 	sub	r9,sp,-12
80008ec8:	40 2a       	lddsp	r10,sp[0x8]
80008eca:	e0 6c 1d 04 	mov	r12,7428
80008ece:	fe b0 f8 f9 	rcall	800080c0 <fatfs_get_file_entry>
    }

    file->startcluster = 0;

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
80008ed2:	58 1c       	cp.w	r12,1
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
80008ed4:	c6 90       	breq	80008fa6 <fl_fopen+0x25e>

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
80008ed6:	30 19       	mov	r9,1
80008ed8:	30 01       	mov	r1,0
    {
        _free_file(file);
        return NULL;
    }

    file->startcluster = 0;
80008eda:	e8 ca ff fc 	sub	r10,r4,-4

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
80008ede:	89 11       	st.w	r4[0x4],r1
80008ee0:	12 9b       	mov	r11,r9
80008ee2:	e0 6c 1d 04 	mov	r12,7428
80008ee6:	e0 a0 08 33 	rcall	80009f4c <fatfs_allocate_free_space>
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
80008eea:	18 98       	mov	r8,r12
80008eec:	c5 30       	breq	80008f92 <fl_fopen+0x24a>
80008eee:	e8 c8 fd e4 	sub	r8,r4,-540
80008ef2:	50 18       	stdsp	sp[0x4],r8
80008ef4:	c1 28       	rjmp	80008f18 <fl_fopen+0x1d0>
80008ef6:	02 9a       	mov	r10,r1
80008ef8:	fa cb ff d4 	sub	r11,sp,-44
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);

        // Check if entry exists already or not
        if (fatfs_sfn_exists(&_fs, file->parentcluster, (char*)file->shortfilename) == 0)
80008efc:	40 1c       	lddsp	r12,sp[0x4]
80008efe:	cd 7d       	rcall	800092ac <fatfs_lfn_generate_tail>
80008f00:	40 1a       	lddsp	r10,sp[0x4]
80008f02:	68 0b       	ld.w	r11,r4[0x0]
80008f04:	e0 6c 1d 04 	mov	r12,7428
80008f08:	fe b0 f8 b0 	rcall	80008068 <fatfs_sfn_exists>
            break;

        tailNum++;
    }
    while (tailNum < 9999);
80008f0c:	18 90       	mov	r0,r12
80008f0e:	c1 30       	breq	80008f34 <fl_fopen+0x1ec>
80008f10:	2f f1       	sub	r1,-1
    // Generate a short filename & tail
    tailNum = 0;
    do 
    {
        // Create a standard short filename (without tail)
        fatfs_lfn_create_sfn(shortFilename, file->filename);
80008f12:	e0 41 27 0f 	cp.w	r1,9999
80008f16:	c4 30       	breq	80008f9c <fl_fopen+0x254>
80008f18:	40 2b       	lddsp	r11,sp[0x8]
80008f1a:	fa cc ff d4 	sub	r12,sp,-44

        // If second hit or more, generate a ~n tail        
        if (tailNum != 0)
80008f1e:	e0 a0 02 29 	rcall	80009370 <fatfs_lfn_create_sfn>
            fatfs_lfn_generate_tail((char*)file->shortfilename, shortFilename, tailNum);
        // Try with no tail if first entry
        else
            memcpy(file->shortfilename, shortFilename, FAT_SFN_SIZE_FULL);
80008f22:	58 01       	cp.w	r1,0
80008f24:	ce 91       	brne	80008ef6 <fl_fopen+0x1ae>
80008f26:	30 ba       	mov	r10,11
80008f28:	fa cb ff d4 	sub	r11,sp,-44
80008f2c:	40 1c       	lddsp	r12,sp[0x4]
        tailNum++;
    }
    while (tailNum < 9999);

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
80008f2e:	e0 a0 0c 2b 	rcall	8000a784 <memcpy>
80008f32:	ce 7b       	rjmp	80008f00 <fl_fopen+0x1b8>
        return NULL;
    }
#endif

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
80008f34:	e0 41 27 0f 	cp.w	r1,9999
80008f38:	c3 20       	breq	80008f9c <fl_fopen+0x254>
80008f3a:	1a dc       	st.w	--sp,r12
80008f3c:	40 29       	lddsp	r9,sp[0x8]
80008f3e:	1a dc       	st.w	--sp,r12
80008f40:	e0 6c 1d 04 	mov	r12,7428
80008f44:	40 4a       	lddsp	r10,sp[0x10]
80008f46:	68 18       	ld.w	r8,r4[0x4]
80008f48:	68 0b       	ld.w	r11,r4[0x0]
80008f4a:	e0 a0 06 b7 	rcall	80009cb8 <fatfs_add_file_entry>
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
80008f4e:	2f ed       	sub	sp,-8
    file->file_data_dirty = 0;
    file->filelength_changed = 0;
80008f50:	18 91       	mov	r1,r12
        _free_file(file);
        return NULL;
    }

    // General
    file->filelength = 0;
80008f52:	58 0c       	cp.w	r12,0
    file->bytenum = 0;
80008f54:	c2 e0       	breq	80008fb0 <fl_fopen+0x268>
    file->file_data_address = 0xFFFFFFFF;
    file->file_data_dirty = 0;
80008f56:	3f f8       	mov	r8,-1
80008f58:	89 40       	st.w	r4[0x10],r0
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;
80008f5a:	89 30       	st.w	r4[0xc],r0
80008f5c:	89 20       	st.w	r4[0x8],r0
    }

    // General
    file->filelength = 0;
    file->bytenum = 0;
    file->file_data_address = 0xFFFFFFFF;
80008f5e:	e9 40 04 34 	st.w	r4[1076],r0
    file->file_data_dirty = 0;
    file->filelength_changed = 0;

    // Quick lookup for next link in the chain
    file->last_fat_lookup.ClusterIdx = 0xFFFFFFFF;
80008f62:	e9 48 02 2c 	st.w	r4[556],r8
    file->last_fat_lookup.CurrentCluster = 0xFFFFFFFF;

    fatfs_cache_init(&_fs, file);
80008f66:	e9 48 04 30 	st.w	r4[1072],r8
80008f6a:	e9 48 02 28 	st.w	r4[552],r8
    
    fatfs_fat_purge(&_fs);
80008f6e:	08 9b       	mov	r11,r4
80008f70:	e0 6c 1d 04 	mov	r12,7428
80008f74:	fe b0 fa 74 	rcall	8000845c <fatfs_cache_init>
    if (file->path[0] == 0)
        file->parentcluster = fatfs_get_root_cluster(&_fs);
    else
    {
        // Find parent directory start cluster
        if (!_open_directory(file->path, &file->parentcluster))
80008f78:	e0 6c 1d 04 	mov	r12,7428
80008f7c:	e0 a0 05 1c 	rcall	800099b4 <fatfs_fat_purge>
80008f80:	c3 db       	rjmp	80008dfa <fl_fopen+0xb2>
        {
            _free_file(file);
80008f82:	02 9c       	mov	r12,r1
80008f84:	08 9b       	mov	r11,r4
    file->startcluster = 0;

    // Create the file space for the file (at least one clusters worth!)
    if (!fatfs_allocate_free_space(&_fs, 1, &file->startcluster, 1))
    {
        _free_file(file);
80008f86:	fe b0 fb 51 	rcall	80008628 <_open_directory>
80008f8a:	18 98       	mov	r8,r12
80008f8c:	c0 30       	breq	80008f92 <fl_fopen+0x24a>
80008f8e:	68 0b       	ld.w	r11,r4[0x0]

    // We reached the max number of duplicate short file names (unlikely!)
    if (tailNum == 9999)
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
80008f90:	c9 ab       	rjmp	80008ec4 <fl_fopen+0x17c>
80008f92:	08 9c       	mov	r12,r4
80008f94:	10 94       	mov	r4,r8
80008f96:	fe b0 fa a7 	rcall	800084e4 <_free_file>

        _free_file(file);
80008f9a:	c3 0b       	rjmp	80008dfa <fl_fopen+0xb2>
80008f9c:	68 1b       	ld.w	r11,r4[0x4]
80008f9e:	e0 6c 1d 04 	mov	r12,7428

    // Add file to disk
    if (!fatfs_add_file_entry(&_fs, file->parentcluster, (char*)file->filename, (char*)file->shortfilename, file->startcluster, 0, 0))
    {
        // Delete allocated space
        fatfs_free_cluster_chain(&_fs, file->startcluster);
80008fa2:	e0 a0 06 3b 	rcall	80009c18 <fatfs_free_cluster_chain>
80008fa6:	08 9c       	mov	r12,r4
80008fa8:	30 04       	mov	r4,0

        _free_file(file);
80008faa:	fe b0 fa 9d 	rcall	800084e4 <_free_file>
80008fae:	c2 6b       	rjmp	80008dfa <fl_fopen+0xb2>
80008fb0:	68 1b       	ld.w	r11,r4[0x4]
80008fb2:	e0 6c 1d 04 	mov	r12,7428
80008fb6:	e0 a0 06 31 	rcall	80009c18 <fatfs_free_cluster_chain>
80008fba:	08 9c       	mov	r12,r4
80008fbc:	02 94       	mov	r4,r1
80008fbe:	fe b0 fa 93 	rcall	800084e4 <_free_file>
80008fc2:	c1 cb       	rjmp	80008dfa <fl_fopen+0xb2>

80008fc4 <fl_attach_media>:
80008fc4:	eb cd 40 80 	pushm	r7,lr
80008fc8:	20 1d       	sub	sp,4
80008fca:	e0 68 29 f4 	mov	r8,10740
80008fce:	18 97       	mov	r7,r12
80008fd0:	70 08       	ld.w	r8,r8[0x0]
80008fd2:	58 08       	cp.w	r8,0
80008fd4:	c1 10       	breq	80008ff6 <fl_attach_media+0x32>
80008fd6:	e0 6c 1d 04 	mov	r12,7428
80008fda:	99 d7       	st.w	r12[0x34],r7
80008fdc:	99 eb       	st.w	r12[0x38],r11
80008fde:	fe b0 f9 13 	rcall	80008204 <fatfs_init>
80008fe2:	18 97       	mov	r7,r12
80008fe4:	c0 e1       	brne	80009000 <fl_attach_media+0x3c>
80008fe6:	30 19       	mov	r9,1
80008fe8:	e0 68 1d 00 	mov	r8,7424
80008fec:	0e 9c       	mov	r12,r7
80008fee:	91 09       	st.w	r8[0x0],r9
80008ff0:	2f fd       	sub	sp,-4
80008ff2:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ff6:	50 0b       	stdsp	sp[0x0],r11
80008ff8:	fe b0 fa bc 	rcall	80008570 <fl_init>
80008ffc:	40 0b       	lddsp	r11,sp[0x0]
80008ffe:	ce cb       	rjmp	80008fd6 <fl_attach_media+0x12>
80009000:	fe cc c8 6c 	sub	r12,pc,-14228
80009004:	fe b0 ce da 	rcall	80002db8 <print_dbg>
80009008:	fe cc c8 48 	sub	r12,pc,-14264
8000900c:	fe b0 ce d6 	rcall	80002db8 <print_dbg>
80009010:	0e 9c       	mov	r12,r7
80009012:	fe b0 ce a5 	rcall	80002d5c <print_dbg_hex>
        return res;
    }

    _filelib_valid = 1;
    return FAT_INIT_OK;
}
80009016:	fe cc d4 fe 	sub	r12,pc,-11010
8000901a:	fe b0 ce cf 	rcall	80002db8 <print_dbg>
8000901e:	0e 9c       	mov	r12,r7
80009020:	2f fd       	sub	sp,-4
80009022:	e3 cd 80 80 	ldm	sp++,r7,pc
80009026:	d7 03       	nop

80009028 <fatfs_lfn_cache_entry>:
// fatfs_lfn_cache_entry - Function extracts long file name text from sector 
// at a specific offset
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
80009028:	eb cd 40 c0 	pushm	r6-r7,lr
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
8000902c:	31 49       	mov	r9,20
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_lfn_cache_entry(struct lfn_cache *lfn, uint8 *entryBuffer)
{
    uint8 LFNIndex, i;
    LFNIndex = entryBuffer[0] & 0x1F;
8000902e:	17 88       	ld.ub	r8,r11[0x0]
80009030:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5

    // Limit file name to cache size!
    if (LFNIndex > MAX_LONGFILENAME_ENTRIES)
80009034:	f2 08 18 00 	cp.b	r8,r9
80009038:	e0 8b 00 4b 	brhi	800090ce <fatfs_lfn_cache_entry+0xa6>
        return ;

    // This is an error condition
    if (LFNIndex == 0)
8000903c:	58 08       	cp.w	r8,0
8000903e:	c4 80       	breq	800090ce <fatfs_lfn_cache_entry+0xa6>
        return ;

    if (lfn->no_of_strings == 0) 
80009040:	f9 3a 01 05 	ld.ub	r10,r12[261]
80009044:	30 09       	mov	r9,0
        lfn->no_of_strings = LFNIndex;
80009046:	f2 0a 18 00 	cp.b	r10,r9
8000904a:	f9 f8 0f 05 	st.beq	r12[0x105],r8

    lfn->String[LFNIndex-1][0] = entryBuffer[1];
8000904e:	20 18       	sub	r8,1
80009050:	17 99       	ld.ub	r9,r11[0x1]
80009052:	f0 08 00 1a 	add	r10,r8,r8<<0x1
80009056:	f0 0a 00 28 	add	r8,r8,r10<<0x2
8000905a:	f8 08 00 0a 	add	r10,r12,r8
8000905e:	14 98       	mov	r8,r10
80009060:	10 c9       	st.b	r8++,r9
    lfn->String[LFNIndex-1][1] = entryBuffer[3];
80009062:	17 b9       	ld.ub	r9,r11[0x3]
80009064:	b0 89       	st.b	r8[0x0],r9
    lfn->String[LFNIndex-1][2] = entryBuffer[5];
80009066:	17 d9       	ld.ub	r9,r11[0x5]
80009068:	b4 a9       	st.b	r10[0x2],r9
    lfn->String[LFNIndex-1][3] = entryBuffer[7];
8000906a:	17 fc       	ld.ub	r12,r11[0x7]
8000906c:	b4 bc       	st.b	r10[0x3],r12
    lfn->String[LFNIndex-1][4] = entryBuffer[9];
8000906e:	f7 3c 00 09 	ld.ub	r12,r11[9]
80009072:	b4 cc       	st.b	r10[0x4],r12
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
80009074:	f7 3c 00 0e 	ld.ub	r12,r11[14]
80009078:	b4 dc       	st.b	r10[0x5],r12
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
8000907a:	f7 36 00 10 	ld.ub	r6,r11[16]
8000907e:	b4 e6       	st.b	r10[0x6],r6
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
80009080:	f7 36 00 12 	ld.ub	r6,r11[18]
80009084:	b4 f6       	st.b	r10[0x7],r6
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
80009086:	f7 36 00 14 	ld.ub	r6,r11[20]
8000908a:	f5 66 00 08 	st.b	r10[8],r6
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
8000908e:	f7 36 00 16 	ld.ub	r6,r11[22]
80009092:	f5 66 00 09 	st.b	r10[9],r6
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
80009096:	f7 36 00 18 	ld.ub	r6,r11[24]
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
8000909a:	14 98       	mov	r8,r10
    lfn->String[LFNIndex-1][5] = entryBuffer[0x0E];
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
8000909c:	f5 66 00 0a 	st.b	r10[10],r6
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
800090a0:	30 09       	mov	r9,0
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
800090a2:	f7 36 00 1c 	ld.ub	r6,r11[28]
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
800090a6:	3f fe       	mov	lr,-1
    lfn->String[LFNIndex-1][6] = entryBuffer[0x10];
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
800090a8:	f5 66 00 0b 	st.b	r10[11],r6
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
800090ac:	32 07       	mov	r7,32
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
800090ae:	f7 3b 00 1e 	ld.ub	r11,r11[30]

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
800090b2:	30 dc       	mov	r12,13
    lfn->String[LFNIndex-1][7] = entryBuffer[0x12];
    lfn->String[LFNIndex-1][8] = entryBuffer[0x14];
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];
800090b4:	f5 6b 00 0c 	st.b	r10[12],r11

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
        if (lfn->String[LFNIndex-1][i]==0xFF) 
800090b8:	11 8a       	ld.ub	r10,r8[0x0]
            lfn->String[LFNIndex-1][i] = 0x20; // Replace with spaces
800090ba:	fc 0a 18 00 	cp.b	r10,lr
800090be:	f1 f7 0e 00 	st.beq	r8[0x0],r7
    lfn->String[LFNIndex-1][9] = entryBuffer[0x16];
    lfn->String[LFNIndex-1][10] = entryBuffer[0x18];                                           
    lfn->String[LFNIndex-1][11] = entryBuffer[0x1C];
    lfn->String[LFNIndex-1][12] = entryBuffer[0x1E];

    for (i=0; i<MAX_LFN_ENTRY_LENGTH; i++)
800090c2:	2f f9       	sub	r9,-1
800090c4:	2f f8       	sub	r8,-1
800090c6:	5c 59       	castu.b	r9
800090c8:	f8 09 18 00 	cp.b	r9,r12
800090cc:	cf 61       	brne	800090b8 <fatfs_lfn_cache_entry+0x90>
800090ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800090d2 <fatfs_lfn_cache_get>:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
800090d2:	f9 38 01 05 	ld.ub	r8,r12[261]
800090d6:	31 49       	mov	r9,20
800090d8:	f2 08 18 00 	cp.b	r8,r9
800090dc:	c0 e0       	breq	800090f8 <fatfs_lfn_cache_get+0x26>
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
800090de:	58 08       	cp.w	r8,0
800090e0:	c0 31       	brne	800090e6 <fatfs_lfn_cache_get+0x14>
        lfn->String[lfn->no_of_strings][0] = '\0';
    else
        lfn->String[0][0] = '\0';
800090e2:	b8 88       	st.b	r12[0x0],r8

    return (char*)&lfn->String[0][0];
}
800090e4:	5e fc       	retal	r12
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
    else if (lfn->no_of_strings)
        lfn->String[lfn->no_of_strings][0] = '\0';
800090e6:	f0 08 00 19 	add	r9,r8,r8<<0x1
800090ea:	f0 09 00 28 	add	r8,r8,r9<<0x2
800090ee:	30 09       	mov	r9,0
800090f0:	f8 08 00 08 	add	r8,r12,r8
800090f4:	b0 89       	st.b	r8[0x0],r9
800090f6:	5e fc       	retal	r12
#if FATFS_INC_LFN_SUPPORT
char* fatfs_lfn_cache_get(struct lfn_cache *lfn)
{
    // Null terminate long filename
    if (lfn->no_of_strings == MAX_LONGFILENAME_ENTRIES)
        lfn->Null = '\0';
800090f8:	30 08       	mov	r8,0
800090fa:	f9 68 01 04 	st.b	r12[260],r8
800090fe:	5e fc       	retal	r12

80009100 <fatfs_entry_lfn_text>:
//-----------------------------------------------------------------------------
// fatfs_entry_lfn_text: If LFN text entry found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_text(struct fat_dir_entry *entry)
{
80009100:	f9 38 00 0b 	ld.ub	r8,r12[11]
80009104:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009108:	58 f8       	cp.w	r8,15
    if ((entry->Attr & FILE_ATTR_LFN_TEXT) == FILE_ATTR_LFN_TEXT) 
        return 1;
    else 
        return 0;
}
8000910a:	5f 0c       	sreq	r12
8000910c:	5e fc       	retal	r12

8000910e <fatfs_entry_lfn_invalid>:
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8000910e:	3e 58       	mov	r8,-27
80009110:	19 89       	ld.ub	r9,r12[0x0]
80009112:	f0 09 18 00 	cp.b	r9,r8
80009116:	5f 0a       	sreq	r10
80009118:	30 08       	mov	r8,0
8000911a:	f0 09 18 00 	cp.b	r9,r8
8000911e:	5f 09       	sreq	r9
80009120:	f5 e9 10 09 	or	r9,r10,r9
80009124:	f0 09 18 00 	cp.b	r9,r8
80009128:	c0 b1       	brne	8000913e <fatfs_entry_lfn_invalid+0x30>
         (entry->Name[0]==FILE_HEADER_DELETED)||
         (entry->Attr==FILE_ATTR_VOLUME_ID) || 
8000912a:	f9 38 00 0b 	ld.ub	r8,r12[11]
// fatfs_entry_lfn_invalid: If SFN found not relating to LFN
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_invalid(struct fat_dir_entry *entry)
{
    if ( (entry->Name[0]==FILE_HEADER_BLANK)  || 
8000912e:	30 89       	mov	r9,8
80009130:	f2 08 18 00 	cp.b	r8,r9
80009134:	c0 50       	breq	8000913e <fatfs_entry_lfn_invalid+0x30>
80009136:	e2 18 00 06 	andl	r8,0x6,COH
8000913a:	5f 1c       	srne	r12
8000913c:	5e fc       	retal	r12
8000913e:	5e ff       	retal	1

80009140 <fatfs_entry_lfn_exists>:
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
80009140:	f7 38 00 0b 	ld.ub	r8,r11[11]
80009144:	30 f9       	mov	r9,15
80009146:	f2 08 18 00 	cp.b	r8,r9
8000914a:	c1 50       	breq	80009174 <fatfs_entry_lfn_exists+0x34>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
8000914c:	17 89       	ld.ub	r9,r11[0x0]
// fatfs_entry_lfn_exists: If LFN exists and correlation SFN found
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
int fatfs_entry_lfn_exists(struct lfn_cache *lfn, struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
8000914e:	58 09       	cp.w	r9,0
80009150:	c1 20       	breq	80009174 <fatfs_entry_lfn_exists+0x34>
80009152:	3e 5a       	mov	r10,-27
80009154:	f4 09 18 00 	cp.b	r9,r10
80009158:	c0 e0       	breq	80009174 <fatfs_entry_lfn_exists+0x34>
8000915a:	30 89       	mov	r9,8
8000915c:	f2 08 18 00 	cp.b	r8,r9
80009160:	c0 a0       	breq	80009174 <fatfs_entry_lfn_exists+0x34>
80009162:	e2 18 00 06 	andl	r8,0x6,COH
80009166:	c0 71       	brne	80009174 <fatfs_entry_lfn_exists+0x34>
80009168:	f9 39 01 05 	ld.ub	r9,r12[261]
8000916c:	f0 09 18 00 	cp.b	r9,r8
80009170:	5f 1c       	srne	r12
80009172:	5e fc       	retal	r12
80009174:	5e fd       	retal	0

80009176 <fatfs_entry_sfn_only>:
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
80009176:	f9 38 00 0b 	ld.ub	r8,r12[11]
8000917a:	30 f9       	mov	r9,15
8000917c:	f2 08 18 00 	cp.b	r8,r9
80009180:	c1 00       	breq	800091a0 <fatfs_entry_sfn_only+0x2a>
         (entry->Name[0]!=FILE_HEADER_BLANK) && 
80009182:	19 89       	ld.ub	r9,r12[0x0]
//-----------------------------------------------------------------------------
// fatfs_entry_sfn_only: If SFN only exists
//-----------------------------------------------------------------------------
int fatfs_entry_sfn_only(struct fat_dir_entry *entry)
{
    if ( (entry->Attr!=FILE_ATTR_LFN_TEXT) && 
80009184:	58 09       	cp.w	r9,0
80009186:	c0 d0       	breq	800091a0 <fatfs_entry_sfn_only+0x2a>
80009188:	3e 5a       	mov	r10,-27
8000918a:	f4 09 18 00 	cp.b	r9,r10
8000918e:	c0 90       	breq	800091a0 <fatfs_entry_sfn_only+0x2a>
80009190:	30 89       	mov	r9,8
80009192:	f2 08 18 00 	cp.b	r8,r9
80009196:	c0 50       	breq	800091a0 <fatfs_entry_sfn_only+0x2a>
80009198:	e2 18 00 06 	andl	r8,0x6,COH
8000919c:	5f 0c       	sreq	r12
8000919e:	5e fc       	retal	r12
800091a0:	5e fd       	retal	0

800091a2 <fatfs_entry_is_dir>:
// TODO: FILE_ATTR_SYSHID ?!?!??!
//-----------------------------------------------------------------------------
// fatfs_entry_is_dir: Returns 1 if a directory
//-----------------------------------------------------------------------------
int fatfs_entry_is_dir(struct fat_dir_entry *entry)
{
800091a2:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_DIR) 
        return 1;
    else 
        return 0;
}
800091a6:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
800091aa:	5e fc       	retal	r12

800091ac <fatfs_entry_is_file>:
//-----------------------------------------------------------------------------
// fatfs_entry_is_file: Returns 1 is a file entry
//-----------------------------------------------------------------------------
int fatfs_entry_is_file(struct fat_dir_entry *entry)
{
800091ac:	f9 3c 00 0b 	ld.ub	r12,r12[11]
    if (entry->Attr & FILE_TYPE_FILE) 
        return 1;
    else 
        return 0;
}
800091b0:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
800091b4:	5e fc       	retal	r12

800091b6 <fatfs_sfn_create_entry>:
//-----------------------------------------------------------------------------
// fatfs_sfn_create_entry: Create the short filename directory entry
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
800091b6:	eb cd 40 80 	pushm	r7,lr
800091ba:	30 0e       	mov	lr,0
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];
800091bc:	f8 0e 07 07 	ld.ub	r7,r12[lr]
800091c0:	f2 0e 0b 07 	st.b	r9[lr],r7
void fatfs_sfn_create_entry(char *shortfilename, uint32 size, uint32 startCluster, struct fat_dir_entry *entry, int dir)
{
    int i;

    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
800091c4:	2f fe       	sub	lr,-1
800091c6:	58 be       	cp.w	lr,11
800091c8:	cf a1       	brne	800091bc <fatfs_sfn_create_entry+0x6>
        entry->Name[i] = shortfilename[i];

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
800091ca:	30 0c       	mov	r12,0
    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;
800091cc:	30 0e       	mov	lr,0
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
800091ce:	f3 6c 00 19 	st.b	r9[25],r12
    // Copy short filename
    for (i=0;i<FAT_SFN_SIZE_FULL;i++)
        entry->Name[i] = shortfilename[i];

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
800091d2:	f3 6c 00 0d 	st.b	r9[13],r12
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
800091d6:	f3 6c 00 0e 	st.b	r9[14],r12
800091da:	f3 6c 00 0f 	st.b	r9[15],r12
    entry->CrtDate[1] = 0x00;
800091de:	f3 6c 00 11 	st.b	r9[17],r12
    entry->CrtDate[0] = 0x20;
    entry->LstAccDate[1] = 0x00;
800091e2:	f3 6c 00 13 	st.b	r9[19],r12
    entry->LstAccDate[0] = 0x20;
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
800091e6:	f3 6c 00 16 	st.b	r9[22],r12
800091ea:	f3 6c 00 17 	st.b	r9[23],r12

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
800091ee:	32 0c       	mov	r12,32
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    

    if (!dir)
        entry->Attr = FILE_TYPE_FILE;
800091f0:	58 08       	cp.w	r8,0
800091f2:	f3 fc 0e 0b 	st.beq	r9[0xb],r12
    else
        entry->Attr = FILE_TYPE_DIR;
800091f6:	f9 b8 01 10 	movne	r8,16
800091fa:	f3 f8 1e 0b 	st.bne	r9[0xb],r8

    entry->NTRes = 0x00;
800091fe:	f3 6e 00 0c 	st.b	r9[12],lr

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
80009202:	f1 da c0 10 	bfextu	r8,r10,0x0,0x10
    else
        entry->Attr = FILE_TYPE_DIR;

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
80009206:	b1 8a       	lsr	r10,0x10
80009208:	f4 0e 16 08 	lsr	lr,r10,0x8
8000920c:	fd ea 10 8a 	or	r10,lr,r10<<0x8
80009210:	5c 7a       	castu.h	r10
80009212:	f3 6a 00 15 	st.b	r9[21],r10
80009216:	a9 8a       	lsr	r10,0x8
80009218:	f3 6a 00 14 	st.b	r9[20],r10
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
8000921c:	f0 0a 16 08 	lsr	r10,r8,0x8
80009220:	f5 e8 10 88 	or	r8,r10,r8<<0x8
80009224:	5c 78       	castu.h	r8
80009226:	f3 68 00 1b 	st.b	r9[27],r8
8000922a:	a9 88       	lsr	r8,0x8
8000922c:	f3 68 00 1a 	st.b	r9[26],r8
    entry->FileSize = FAT_HTONL(size);
80009230:	f6 08 15 18 	lsl	r8,r11,0x18
80009234:	f1 eb 13 88 	or	r8,r8,r11>>0x18

    // Unless we have a RTC we might as well set these to 1980
    entry->CrtTimeTenth = 0x00;
    entry->CrtTime[1] = entry->CrtTime[0] = 0x00;
    entry->CrtDate[1] = 0x00;
    entry->CrtDate[0] = 0x20;
80009238:	f3 6c 00 10 	st.b	r9[16],r12
    entry->LstAccDate[1] = 0x00;
    entry->LstAccDate[0] = 0x20;
8000923c:	f3 6c 00 12 	st.b	r9[18],r12
    entry->WrtTime[1] = entry->WrtTime[0] = 0x00;
    entry->WrtDate[1] = 0x00;
    entry->WrtDate[0] = 0x20;    
80009240:	f3 6c 00 18 	st.b	r9[24],r12

    entry->NTRes = 0x00;

    entry->FstClusHI = FAT_HTONS((uint16)((startCluster>>16) & 0xFFFF));
    entry->FstClusLO = FAT_HTONS((uint16)((startCluster>>0) & 0xFFFF));
    entry->FileSize = FAT_HTONL(size);
80009244:	16 9c       	mov	r12,r11
80009246:	e2 1b ff 00 	andl	r11,0xff00,COH
8000924a:	e6 1c 00 ff 	andh	r12,0xff,COH
8000924e:	f1 eb 10 8b 	or	r11,r8,r11<<0x8
80009252:	f7 ec 12 8b 	or	r11,r11,r12>>0x8
80009256:	f6 08 16 18 	lsr	r8,r11,0x18
8000925a:	f3 6b 00 1f 	st.b	r9[31],r11
8000925e:	f3 68 00 1c 	st.b	r9[28],r8
80009262:	f1 db c2 08 	bfextu	r8,r11,0x10,0x8
80009266:	f7 db c1 08 	bfextu	r11,r11,0x8,0x8
8000926a:	f3 68 00 1d 	st.b	r9[29],r8
8000926e:	f3 6b 00 1e 	st.b	r9[30],r11
}
80009272:	e3 cd 80 80 	ldm	sp++,r7,pc

80009276 <fatfs_lfn_cache_init>:
//-----------------------------------------------------------------------------
void fatfs_lfn_cache_init(struct lfn_cache *lfn, int wipeTable)
{
    int i = 0;

    lfn->no_of_strings = 0;
80009276:	30 08       	mov	r8,0
80009278:	f9 68 01 05 	st.b	r12[261],r8

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
8000927c:	58 0b       	cp.w	r11,0
8000927e:	5e 0c       	reteq	r12
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
            memset(lfn->String[i], 0x00, MAX_LFN_ENTRY_LENGTH);
80009280:	30 0a       	mov	r10,0
80009282:	14 99       	mov	r9,r10
80009284:	f8 0a 00 08 	add	r8,r12,r10
80009288:	10 c9       	st.b	r8++,r9
8000928a:	10 c9       	st.b	r8++,r9
8000928c:	10 c9       	st.b	r8++,r9
8000928e:	10 c9       	st.b	r8++,r9
80009290:	10 c9       	st.b	r8++,r9
80009292:	10 c9       	st.b	r8++,r9
80009294:	10 c9       	st.b	r8++,r9
80009296:	10 c9       	st.b	r8++,r9
80009298:	10 c9       	st.b	r8++,r9
8000929a:	10 c9       	st.b	r8++,r9
8000929c:	10 c9       	st.b	r8++,r9
8000929e:	10 c9       	st.b	r8++,r9
800092a0:	b0 89       	st.b	r8[0x0],r9
800092a2:	2f 3a       	sub	r10,-13

#if FATFS_INC_LFN_SUPPORT

    // Zero out buffer also
    if (wipeTable)
        for (i=0;i<MAX_LONGFILENAME_ENTRIES;i++)
800092a4:	e0 4a 01 04 	cp.w	r10,260
800092a8:	ce e1       	brne	80009284 <fatfs_lfn_cache_init+0xe>
800092aa:	5e fc       	retal	r12

800092ac <fatfs_lfn_generate_tail>:
// sfn_output = Output short filename with tail
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_generate_tail(char *sfn_output, char *sfn_input, uint32 tailNum)
{
800092ac:	eb cd 40 fc 	pushm	r2-r7,lr
800092b0:	20 bd       	sub	sp,44
800092b2:	18 96       	mov	r6,r12
    int tail_chars;
    char tail_str[12];

    if (tailNum > 99999)
800092b4:	e0 5a 86 9f 	cp.w	r10,99999
800092b8:	e0 88 00 05 	brls	800092c2 <fatfs_lfn_generate_tail+0x16>
800092bc:	2f 5d       	sub	sp,-44
800092be:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
800092c2:	30 09       	mov	r9,0
800092c4:	fa c7 ff e0 	sub	r7,sp,-32
800092c8:	30 08       	mov	r8,0
800092ca:	ee e9 00 00 	st.d	r7[0],r8
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
800092ce:	fe c9 ca fe 	sub	r9,pc,-13570
800092d2:	f3 3c 00 10 	ld.ub	r12,r9[16]
800092d6:	fb 6c 00 10 	st.b	sp[16],r12

    if (tailNum > 99999)
        return 0;

    // Convert to number
    memset(tail_str, 0x00, sizeof(tail_str)); 
800092da:	30 0c       	mov	r12,0
    tail_str[0] = '~';
800092dc:	8f 2c       	st.w	r7[0x8],r12
800092de:	37 ec       	mov	r12,126
800092e0:	fb 6c 00 20 	st.b	sp[32],r12
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
800092e4:	f2 e4 00 00 	ld.d	r4,r9[0]
800092e8:	fa e5 00 00 	st.d	sp[0],r4
800092ec:	f2 e4 00 08 	ld.d	r4,r9[8]
800092f0:	fa e5 00 08 	st.d	sp[8],r4
800092f4:	fa c5 ff ec 	sub	r5,sp,-20
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
800092f8:	e0 64 cc cd 	mov	r4,52429
800092fc:	ea 14 cc cc 	orh	r4,0xcccc
//-----------------------------------------------------------------------------
static void fatfs_itoa(uint32 num, char *s)
{
    char* cp;
    char outbuf[12];
    const char digits[] = "0123456789ABCDEF";
80009300:	0a 99       	mov	r9,r5
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
    } 
    while ((num /= 10) > 0);
80009302:	c0 28       	rjmp	80009306 <fatfs_lfn_generate_tail+0x5a>
   
    // Build string backwards
    cp = outbuf;
    do 
    {
        *cp++ = digits[(int)(num % 10)];
80009304:	10 99       	mov	r9,r8
80009306:	f4 04 06 42 	mulu.d	r2,r10,r4
8000930a:	e6 0c 16 03 	lsr	r12,r3,0x3
8000930e:	f8 0c 00 2e 	add	lr,r12,r12<<0x2
80009312:	12 98       	mov	r8,r9
80009314:	f4 0e 01 1a 	sub	r10,r10,lr<<0x1
80009318:	fa ce ff d4 	sub	lr,sp,-44
8000931c:	fc 0a 00 0a 	add	r10,lr,r10
80009320:	f5 3a ff d4 	ld.ub	r10,r10[-44]
    } 
    while ((num /= 10) > 0);
80009324:	10 ca       	st.b	r8++,r10
80009326:	18 9a       	mov	r10,r12
80009328:	58 0c       	cp.w	r12,0
    
    *cp-- = 0;
8000932a:	ce d1       	brne	80009304 <fatfs_lfn_generate_tail+0x58>

    // Copy in forwards
    while (cp >= outbuf)
8000932c:	b0 8c       	st.b	r8[0x0],r12
8000932e:	0a 39       	cp.w	r9,r5
80009330:	c1 c3       	brcs	80009368 <fatfs_lfn_generate_tail+0xbc>
80009332:	fa c8 ff df 	sub	r8,sp,-33
        *s++ = *cp--;
80009336:	13 8a       	ld.ub	r10,r9[0x0]
80009338:	10 ca       	st.b	r8++,r10
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
8000933a:	20 19       	sub	r9,1
8000933c:	0a 39       	cp.w	r9,r5
        *s++ = *cp--;

    *s = 0;
8000933e:	cf c2       	brcc	80009336 <fatfs_lfn_generate_tail+0x8a>
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
80009340:	30 09       	mov	r9,0

    // Copy in forwards
    while (cp >= outbuf)
        *s++ = *cp--;

    *s = 0;
80009342:	30 ba       	mov	r10,11
    memset(tail_str, 0x00, sizeof(tail_str)); 
    tail_str[0] = '~';
    fatfs_itoa(tailNum, tail_str+1);
    
    // Copy in base filename
    memcpy(sfn_output, sfn_input, FAT_SFN_SIZE_FULL);
80009344:	b0 89       	st.b	r8[0x0],r9
80009346:	0c 9c       	mov	r12,r6
80009348:	e0 a0 0a 1e 	rcall	8000a784 <memcpy>
       
    // Overwrite with tail
    tail_chars = (int)strlen(tail_str);
8000934c:	0e 9c       	mov	r12,r7
8000934e:	e0 a0 0a d9 	rcall	8000a900 <strlen>
    memcpy(sfn_output+(FAT_SFN_SIZE_PARTIAL-tail_chars), tail_str, tail_chars);
80009352:	0e 9b       	mov	r11,r7
80009354:	18 9a       	mov	r10,r12
80009356:	f8 0c 11 08 	rsub	r12,r12,8
8000935a:	ec 0c 00 0c 	add	r12,r6,r12
8000935e:	e0 a0 0a 13 	rcall	8000a784 <memcpy>
80009362:	2f 5d       	sub	sp,-44
80009364:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
    while ((num /= 10) > 0);
    
    *cp-- = 0;

    // Copy in forwards
    while (cp >= outbuf)
80009368:	fa c8 ff df 	sub	r8,sp,-33
8000936c:	ce ab       	rjmp	80009340 <fatfs_lfn_generate_tail+0x94>
8000936e:	d7 03       	nop

80009370 <fatfs_lfn_create_sfn>:
80009370:	eb cd 40 fe 	pushm	r1-r7,lr
80009374:	20 1d       	sub	sp,4
80009376:	16 97       	mov	r7,r11
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
{
80009378:	18 94       	mov	r4,r12
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
8000937a:	16 9c       	mov	r12,r11
8000937c:	e0 a0 0a c2 	rcall	8000a900 <strlen>

    // Invalid to start with .
    if (filename[0]=='.')
80009380:	32 e3       	mov	r3,46
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
80009382:	18 96       	mov	r6,r12

    // Invalid to start with .
    if (filename[0]=='.')
80009384:	0f 88       	ld.ub	r8,r7[0x0]
80009386:	e6 08 18 00 	cp.b	r8,r3
8000938a:	c7 70       	breq	80009478 <fatfs_lfn_create_sfn+0x108>
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
8000938c:	30 ba       	mov	r10,11
8000938e:	32 0b       	mov	r11,32
80009390:	08 9c       	mov	r12,r4
80009392:	e0 a0 0a 9d 	rcall	8000a8cc <memset>
    memset(ext, ' ', 3);
80009396:	1a 92       	mov	r2,sp
{
    int i;
    int dotPos = -1;
    char ext[3];
    int pos;
    int len = (int)strlen(filename);
80009398:	0c 95       	mov	r5,r6
    // Invalid to start with .
    if (filename[0]=='.')
        return 0;

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    memset(ext, ' ', 3);
8000939a:	30 3a       	mov	r10,3
8000939c:	32 0b       	mov	r11,32
8000939e:	1a 9c       	mov	r12,sp
800093a0:	e0 a0 0a 96 	rcall	8000a8cc <memset>

    // Find dot seperator
    for (i = 0; i< len; i++)
800093a4:	58 06       	cp.w	r6,0
800093a6:	e0 8a 00 52 	brle	8000944a <fatfs_lfn_create_sfn+0xda>
800093aa:	3f f9       	mov	r9,-1
800093ac:	30 08       	mov	r8,0
    {
        if (filename[i]=='.')
800093ae:	ee 08 07 0a 	ld.ub	r10,r7[r8]
800093b2:	e6 0a 18 00 	cp.b	r10,r3
800093b6:	f0 09 17 00 	moveq	r9,r8

    memset(sfn_output, ' ', FAT_SFN_SIZE_FULL);
    memset(ext, ' ', 3);

    // Find dot seperator
    for (i = 0; i< len; i++)
800093ba:	2f f8       	sub	r8,-1
800093bc:	10 36       	cp.w	r6,r8
800093be:	cf 81       	brne	800093ae <fatfs_lfn_create_sfn+0x3e>
        if (filename[i]=='.')
            dotPos = i;
    }

    // Extract extensions
    if (dotPos!=-1)
800093c0:	5b f9       	cp.w	r9,-1
800093c2:	c1 b0       	breq	800093f8 <fatfs_lfn_create_sfn+0x88>
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
800093c4:	f2 c8 ff ff 	sub	r8,r9,-1
800093c8:	f2 0b 11 ff 	rsub	r11,r9,-1
800093cc:	ee 08 00 0a 	add	r10,r7,r8
800093d0:	f0 0b 00 0b 	add	r11,r8,r11
#endif
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
800093d4:	f2 cc ff fc 	sub	r12,r9,-4

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
800093d8:	e4 0b 00 0b 	add	r11,r2,r11
            if (i<len)
                ext[i-(dotPos+1)] = filename[i];
800093dc:	10 36       	cp.w	r6,r8
800093de:	f5 fe 98 00 	ld.ubgt	lr,r10[0x0]
800093e2:	f7 fe 9e 00 	st.bgt	r11[0x0],lr

    // Extract extensions
    if (dotPos!=-1)
    {
        // Copy first three chars of extension
        for (i = (dotPos+1); i < (dotPos+1+3); i++)
800093e6:	2f fa       	sub	r10,-1
800093e8:	2f f8       	sub	r8,-1
800093ea:	2f fb       	sub	r11,-1
800093ec:	18 38       	cp.w	r8,r12
800093ee:	cf 71       	brne	800093dc <fatfs_lfn_create_sfn+0x6c>
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
800093f0:	58 09       	cp.w	r9,0
800093f2:	e0 8a 00 2c 	brle	8000944a <fatfs_lfn_create_sfn+0xda>
800093f6:	12 95       	mov	r5,r9
800093f8:	30 0a       	mov	r10,0
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
800093fa:	32 ee       	mov	lr,46
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
800093fc:	14 99       	mov	r9,r10
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
800093fe:	32 03       	mov	r3,32
80009400:	14 96       	mov	r6,r10
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
80009402:	31 91       	mov	r1,25
80009404:	c0 98       	rjmp	80009416 <fatfs_lfn_create_sfn+0xa6>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
80009406:	e8 0a 0b 0c 	st.b	r4[r10],r12
8000940a:	2f fa       	sub	r10,-1
            else
                sfn_output[pos++] = filename[i];
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
8000940c:	58 8a       	cp.w	r10,8
8000940e:	c1 e0       	breq	8000944a <fatfs_lfn_create_sfn+0xda>
        len = dotPos;
    }

    // Add filename part
    pos = 0; 
    for (i=0;i<len;i++)
80009410:	2f f9       	sub	r9,-1
80009412:	0a 39       	cp.w	r9,r5
80009414:	c1 b4       	brge	8000944a <fatfs_lfn_create_sfn+0xda>
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
80009416:	ee 09 07 08 	ld.ub	r8,r7[r9]
8000941a:	fc 08 18 00 	cp.b	r8,lr
8000941e:	5f 1c       	srne	r12
80009420:	e6 08 18 00 	cp.b	r8,r3
80009424:	5f 1b       	srne	r11
80009426:	f9 eb 00 0b 	and	r11,r12,r11
8000942a:	ec 0b 18 00 	cp.b	r11,r6
8000942e:	ce f0       	breq	8000940c <fatfs_lfn_create_sfn+0x9c>
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
                sfn_output[pos++] = filename[i] - 'a' + 'A';
80009430:	f0 cc 00 20 	sub	r12,r8,32
    pos = 0; 
    for (i=0;i<len;i++)
    {
        if ( (filename[i]!=' ') && (filename[i]!='.') )
        {
            if (filename[i] >= 'a' && filename[i] <= 'z')
80009434:	f0 cb 00 61 	sub	r11,r8,97
80009438:	e2 0b 18 00 	cp.b	r11,r1
8000943c:	fe 98 ff e5 	brls	80009406 <fatfs_lfn_create_sfn+0x96>
                sfn_output[pos++] = filename[i] - 'a' + 'A';
            else
                sfn_output[pos++] = filename[i];
80009440:	e8 0a 0b 08 	st.b	r4[r10],r8
80009444:	2f fa       	sub	r10,-1
        }
        
        // Fill upto 8 characters
        if (pos==FAT_SFN_SIZE_PARTIAL)
80009446:	58 8a       	cp.w	r10,8
80009448:	ce 41       	brne	80009410 <fatfs_lfn_create_sfn+0xa0>
8000944a:	1a 92       	mov	r2,sp
8000944c:	2f 84       	sub	r4,-8
#endif
//-----------------------------------------------------------------------------
// fatfs_lfn_create_sfn: Create a padded SFN 
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_lfn_create_sfn(char *sfn_output, char *filename)
8000944e:	fa cc ff fd 	sub	r12,sp,-3
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
80009452:	31 9b       	mov	r11,25
80009454:	05 88       	ld.ub	r8,r2[0x0]
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
80009456:	f0 ca 00 20 	sub	r10,r8,32
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
    {
        if (ext[i-FAT_SFN_SIZE_PARTIAL] >= 'a' && ext[i-FAT_SFN_SIZE_PARTIAL] <= 'z')
8000945a:	f0 c9 00 61 	sub	r9,r8,97
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL] - 'a' + 'A';
8000945e:	f6 09 18 00 	cp.b	r9,r11
80009462:	e9 fa 8e 00 	st.bls	r4[0x0],r10
        else
            sfn_output[i] = ext[i-FAT_SFN_SIZE_PARTIAL];
80009466:	e9 f8 be 00 	st.bhi	r4[0x0],r8
8000946a:	2f f2       	sub	r2,-1
8000946c:	2f f4       	sub	r4,-1
        if (pos==FAT_SFN_SIZE_PARTIAL)
            break;
    }

    // Add extension part
    for (i=FAT_SFN_SIZE_PARTIAL;i<FAT_SFN_SIZE_FULL;i++)
8000946e:	18 32       	cp.w	r2,r12
80009470:	cf 21       	brne	80009454 <fatfs_lfn_create_sfn+0xe4>
80009472:	2f fd       	sub	sp,-4
80009474:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
    char ext[3];
    int pos;
    int len = (int)strlen(filename);

    // Invalid to start with .
    if (filename[0]=='.')
80009478:	2f fd       	sub	sp,-4
8000947a:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
8000947e:	d7 03       	nop

80009480 <fatfs_lfn_entries_required>:
80009480:	d4 01       	pushm	lr
80009482:	e0 a0 0a 3f 	rcall	8000a900 <strlen>
80009486:	c0 e0       	breq	800094a2 <fatfs_lfn_entries_required+0x22>
int fatfs_lfn_entries_required(char *filename)
{
    int length = (int)strlen(filename);

    if (length)
        return (length + MAX_LFN_ENTRY_LENGTH - 1) / MAX_LFN_ENTRY_LENGTH;    
80009488:	f8 c8 ff f4 	sub	r8,r12,-12
8000948c:	e0 6b ec 4f 	mov	r11,60495
80009490:	ea 1b 4e c4 	orh	r11,0x4ec4
80009494:	f0 09 14 1f 	asr	r9,r8,0x1f
80009498:	f0 0b 04 4a 	muls.d	r10,r8,r11
8000949c:	f6 0c 14 02 	asr	r12,r11,0x2
800094a0:	12 1c       	sub	r12,r9
    else
        return 0;
}
800094a2:	d8 02       	popm	pc

800094a4 <fatfs_filename_to_lfn>:
800094a4:	d4 31       	pushm	r0-r7,lr
800094a6:	20 dd       	sub	sp,52
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
800094a8:	fe c8 cc c4 	sub	r8,pc,-13116
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
{
800094ac:	16 97       	mov	r7,r11
800094ae:	14 96       	mov	r6,r10
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
800094b0:	12 92       	mov	r2,r9
800094b2:	70 c9       	ld.w	r9,r8[0x30]
800094b4:	50 c9       	stdsp	sp[0x30],r9
800094b6:	f0 ea 00 00 	ld.d	r10,r8[0]
800094ba:	fa eb 00 00 	st.d	sp[0],r10
800094be:	f0 ea 00 08 	ld.d	r10,r8[8]
800094c2:	fa eb 00 08 	st.d	sp[8],r10
800094c6:	f0 ea 00 10 	ld.d	r10,r8[16]
800094ca:	fa eb 00 10 	st.d	sp[16],r10
800094ce:	f0 ea 00 18 	ld.d	r10,r8[24]
800094d2:	fa eb 00 18 	st.d	sp[24],r10
800094d6:	f0 ea 00 20 	ld.d	r10,r8[32]
800094da:	fa eb 00 20 	st.d	sp[32],r10
800094de:	f0 e8 00 28 	ld.d	r8,r8[40]
800094e2:	18 93       	mov	r3,r12
800094e4:	fa e9 00 28 	st.d	sp[40],r8

    // 13 characters entries
    int length = (int)strlen(filename);
800094e8:	e0 a0 0a 0c 	rcall	8000a900 <strlen>
    int entriesRequired = fatfs_lfn_entries_required(filename);
800094ec:	18 95       	mov	r5,r12
800094ee:	06 9c       	mov	r12,r3
800094f0:	cc 8f       	rcall	80009480 <fatfs_lfn_entries_required>

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
800094f2:	ec 06 00 10 	add	r0,r6,r6<<0x1
    int i;
    int nameIndexes[MAX_LFN_ENTRY_LENGTH] = {1,3,5,7,9,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};

    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);
800094f6:	18 91       	mov	r1,r12

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
800094f8:	32 0a       	mov	r10,32
800094fa:	30 0b       	mov	r11,0
800094fc:	0e 9c       	mov	r12,r7
    // 13 characters entries
    int length = (int)strlen(filename);
    int entriesRequired = fatfs_lfn_entries_required(filename);

    // Filename offset
    int start = entry * MAX_LFN_ENTRY_LENGTH;
800094fe:	ec 00 00 20 	add	r0,r6,r0<<0x2

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);
80009502:	e0 a0 09 e5 	rcall	8000a8cc <memset>

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
80009506:	20 11       	sub	r1,1
80009508:	0c 31       	cp.w	r1,r6
8000950a:	c2 e0       	breq	80009566 <fatfs_filename_to_lfn+0xc2>
8000950c:	2f f6       	sub	r6,-1
8000950e:	5c 56       	castu.b	r6

    // LFN flag
    buffer[11] = 0x0F;
80009510:	30 f8       	mov	r8,15

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
80009512:	ae 86       	st.b	r7[0x0],r6

    // LFN flag
    buffer[11] = 0x0F;

    // Checksum of short filename
    buffer[13] = sfnChk;
80009514:	ef 62 00 0d 	st.b	r7[13],r2
80009518:	1a 94       	mov	r4,sp
8000951a:	00 03       	add	r3,r0

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));

    // LFN flag
    buffer[11] = 0x0F;
8000951c:	ef 68 00 0b 	st.b	r7[11],r8
#endif
//-----------------------------------------------------------------------------
// fatfs_filename_to_lfn:
//-----------------------------------------------------------------------------
#if FATFS_INC_LFN_SUPPORT
void fatfs_filename_to_lfn(char *filename, uint8 *buffer, int entry, uint8 sfnChk)
80009520:	e0 c9 ff f3 	sub	r9,r0,-13
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
80009524:	3f fb       	mov	r11,-1
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
80009526:	30 0c       	mov	r12,0
80009528:	c0 a8       	rjmp	8000953c <fatfs_filename_to_lfn+0x98>

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
8000952a:	68 08       	ld.w	r8,r4[0x0]
8000952c:	07 8a       	ld.ub	r10,r3[0x0]
8000952e:	ee 08 0b 0a 	st.b	r7[r8],r10
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
80009532:	2f f0       	sub	r0,-1
80009534:	2f c4       	sub	r4,-4
80009536:	2f f3       	sub	r3,-1

    // Checksum of short filename
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
80009538:	12 30       	cp.w	r0,r9
8000953a:	c1 00       	breq	8000955a <fatfs_filename_to_lfn+0xb6>
    {
        if ( (start+i) < length )
8000953c:	00 35       	cp.w	r5,r0
8000953e:	fe 99 ff f6 	brgt	8000952a <fatfs_filename_to_lfn+0x86>
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
80009542:	c0 e0       	breq	8000955e <fatfs_filename_to_lfn+0xba>
            buffer[nameIndexes[i]] = 0x00;
        else
        {
            buffer[nameIndexes[i]] = 0xFF;
80009544:	68 08       	ld.w	r8,r4[0x0]
80009546:	ee 08 0b 0b 	st.b	r7[r8],r11
            buffer[nameIndexes[i]+1] = 0xFF;
8000954a:	ee 08 00 08 	add	r8,r7,r8
8000954e:	b0 9b       	st.b	r8[0x1],r11
80009550:	2f f0       	sub	r0,-1
80009552:	2f c4       	sub	r4,-4
80009554:	2f f3       	sub	r3,-1

    // Checksum of short filename
    buffer[13] = sfnChk;

    // Copy to buffer
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
80009556:	12 30       	cp.w	r0,r9
80009558:	cf 21       	brne	8000953c <fatfs_filename_to_lfn+0x98>
        {
            buffer[nameIndexes[i]] = 0xFF;
            buffer[nameIndexes[i]+1] = 0xFF;
        }
    }
}
8000955a:	2f 3d       	sub	sp,-52
8000955c:	d8 32       	popm	r0-r7,pc
    for (i=0;i<MAX_LFN_ENTRY_LENGTH;i++)
    {
        if ( (start+i) < length )
            buffer[nameIndexes[i]] = filename[start+i];
        else if ( (start+i) == length )
            buffer[nameIndexes[i]] = 0x00;
8000955e:	68 08       	ld.w	r8,r4[0x0]
80009560:	ee 08 0b 0c 	st.b	r7[r8],r12
80009564:	ce 7b       	rjmp	80009532 <fatfs_filename_to_lfn+0x8e>

    // Initialise to zeros
    memset(buffer, 0x00, FAT_DIR_ENTRY_SIZE);

    // LFN entry number
    buffer[0] = (uint8)(((entriesRequired-1)==entry)?(0x40|(entry+1)):(entry+1));
80009566:	e2 c6 ff ff 	sub	r6,r1,-1
8000956a:	a7 a6       	sbr	r6,0x6
8000956c:	5c 56       	castu.b	r6
8000956e:	cd 1b       	rjmp	80009510 <fatfs_filename_to_lfn+0x6c>

80009570 <fatfs_total_path_levels>:
int fatfs_total_path_levels(char *path)
{
    int levels = 0;
    char expectedchar;

    if (!path)
80009570:	58 0c       	cp.w	r12,0
80009572:	c2 b0       	breq	800095c8 <fatfs_total_path_levels+0x58>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
80009574:	19 89       	ld.ub	r9,r12[0x0]
80009576:	32 f8       	mov	r8,47
80009578:	f0 09 18 00 	cp.b	r9,r8
8000957c:	c1 d0       	breq	800095b6 <fatfs_total_path_levels+0x46>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
8000957e:	19 99       	ld.ub	r9,r12[0x1]
80009580:	33 a8       	mov	r8,58
80009582:	f0 09 18 00 	cp.b	r9,r8
80009586:	c1 c1       	brne	800095be <fatfs_total_path_levels+0x4e>
    {
        expectedchar = '\\';
        path += 3;
80009588:	f8 c8 ff fd 	sub	r8,r12,-3
8000958c:	35 ca       	mov	r10,92
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
8000958e:	11 89       	ld.ub	r9,r8[0x0]
80009590:	58 09       	cp.w	r9,0
80009592:	c1 c0       	breq	800095ca <fatfs_total_path_levels+0x5a>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
80009594:	30 0c       	mov	r12,0
80009596:	c0 58       	rjmp	800095a0 <fatfs_total_path_levels+0x30>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
            path++;
80009598:	2f f8       	sub	r8,-1

    // Count levels in path string
    while (*path)
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
8000959a:	11 89       	ld.ub	r9,r8[0x0]
8000959c:	58 09       	cp.w	r9,0
8000959e:	c0 b0       	breq	800095b4 <fatfs_total_path_levels+0x44>
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
800095a0:	f2 0a 18 00 	cp.b	r10,r9
800095a4:	cf a1       	brne	80009598 <fatfs_total_path_levels+0x28>
800095a6:	2f f8       	sub	r8,-1
            path++;
        }
    
        // Increase number of subdirs founds
        levels++;
800095a8:	2f fc       	sub	r12,-1
    }
    else
        return -1;

    // Count levels in path string
    while (*path)
800095aa:	11 89       	ld.ub	r9,r8[0x0]
800095ac:	58 09       	cp.w	r9,0
800095ae:	cf 91       	brne	800095a0 <fatfs_total_path_levels+0x30>
800095b0:	20 1c       	sub	r12,1
800095b2:	5e fc       	retal	r12
800095b4:	5e fc       	retal	r12
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
800095b6:	f8 c8 ff ff 	sub	r8,r12,-1
800095ba:	32 fa       	mov	r10,47
800095bc:	ce 9b       	rjmp	8000958e <fatfs_total_path_levels+0x1e>
    }
    else if (path[1] == ':' || path[2] == '\\')
800095be:	19 a9       	ld.ub	r9,r12[0x2]
800095c0:	35 c8       	mov	r8,92
800095c2:	f0 09 18 00 	cp.b	r9,r8
800095c6:	ce 10       	breq	80009588 <fatfs_total_path_levels+0x18>
    {
        // Fast forward through actual subdir text to next slash
        for (; *path; )
        {
            // If slash detected escape from for loop
            if (*path == expectedchar) { path++; break; }
800095c8:	5e fe       	retal	-1
800095ca:	5e fe       	retal	-1

800095cc <fatfs_compare_names>:
//-----------------------------------------------------------------------------
// fatfs_compare_names: Compare two filenames (without copying or changing origonals)
// Returns 1 if match, 0 if not
//-----------------------------------------------------------------------------
int fatfs_compare_names(char* strA, char* strB)
{
800095cc:	d4 31       	pushm	r0-r7,lr
800095ce:	20 4d       	sub	sp,16
800095d0:	18 97       	mov	r7,r12
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
800095d2:	19 84       	ld.ub	r4,r12[0x0]
800095d4:	58 04       	cp.w	r4,0
800095d6:	e0 80 00 e9 	breq	800097a8 <fatfs_compare_names+0x1dc>
800095da:	18 99       	mov	r9,r12
800095dc:	08 9a       	mov	r10,r4
800095de:	30 08       	mov	r8,0
800095e0:	3f f6       	mov	r6,-1
    {
        if (*strSrc=='.')
800095e2:	32 ec       	mov	r12,46
800095e4:	f4 0c 18 00 	cp.b	r12,r10
800095e8:	f0 06 17 00 	moveq	r6,r8
            dotPos = (int)(strSrc-str);

        strSrc++;
800095ec:	2f f9       	sub	r9,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
800095ee:	2f f8       	sub	r8,-1
800095f0:	13 8a       	ld.ub	r10,r9[0x0]
800095f2:	58 0a       	cp.w	r10,0
800095f4:	cf 81       	brne	800095e4 <fatfs_compare_names+0x18>
800095f6:	17 83       	ld.ub	r3,r11[0x0]
800095f8:	58 03       	cp.w	r3,0
800095fa:	e0 80 00 d9 	breq	800097ac <fatfs_compare_names+0x1e0>
800095fe:	06 98       	mov	r8,r3
80009600:	16 9a       	mov	r10,r11
80009602:	30 09       	mov	r9,0
80009604:	3f f5       	mov	r5,-1
    {
        if (*strSrc=='.')
80009606:	32 ec       	mov	r12,46
80009608:	f0 0c 18 00 	cp.b	r12,r8
8000960c:	f2 05 17 00 	moveq	r5,r9
            dotPos = (int)(strSrc-str);

        strSrc++;
80009610:	2f fa       	sub	r10,-1
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
80009612:	2f f9       	sub	r9,-1
80009614:	15 88       	ld.ub	r8,r10[0x0]
80009616:	58 08       	cp.w	r8,0
80009618:	cf 81       	brne	80009608 <fatfs_compare_names+0x3c>
    ext2Pos = FileString_GetExtension(strB);

    // NOTE: Extension position can be different for matching 
    // filename if trailing space are present before it!
    // Check that if one has an extension, so does the other
    if ((ext1Pos==-1) && (ext2Pos!=-1))
8000961a:	5b f5       	cp.w	r5,-1
8000961c:	5f 1a       	srne	r10
8000961e:	5b f6       	cp.w	r6,-1
80009620:	5f 09       	sreq	r9
80009622:	f5 e9 00 09 	and	r9,r10,r9
80009626:	f0 09 18 00 	cp.b	r9,r8
8000962a:	c1 e1       	brne	80009666 <fatfs_compare_names+0x9a>
8000962c:	5b f5       	cp.w	r5,-1
8000962e:	5f 09       	sreq	r9
        return 0;
    if ((ext2Pos==-1) && (ext1Pos!=-1))
80009630:	5b f6       	cp.w	r6,-1
80009632:	5f 18       	srne	r8
80009634:	10 69       	and	r9,r8
80009636:	c1 81       	brne	80009666 <fatfs_compare_names+0x9a>
        return 0;

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
80009638:	58 08       	cp.w	r8,0
8000963a:	c4 c0       	breq	800096d2 <fatfs_compare_names+0x106>
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
8000963c:	ea c8 ff ff 	sub	r8,r5,-1

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
80009640:	50 0b       	stdsp	sp[0x0],r11
    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
        ext2 = strB+ext2Pos+1;
80009642:	f6 08 00 00 	add	r0,r11,r8

    // If they both have extensions, compare them
    if (ext1Pos!=-1)
    {
        // Set pointer to start of extension
        ext1 = strA+ext1Pos+1;
80009646:	ec c1 ff ff 	sub	r1,r6,-1
8000964a:	50 16       	stdsp	sp[0x4],r6
8000964c:	ee 01 00 01 	add	r1,r7,r1
        ext2 = strB+ext2Pos+1;
80009650:	50 25       	stdsp	sp[0x8],r5

        // Verify that the file extension lengths match!
        if (strlen(ext1) != strlen(ext2))
80009652:	02 9c       	mov	r12,r1
80009654:	e0 a0 09 56 	rcall	8000a900 <strlen>
80009658:	18 92       	mov	r2,r12
8000965a:	00 9c       	mov	r12,r0
8000965c:	e0 a0 09 52 	rcall	8000a900 <strlen>
80009660:	40 0b       	lddsp	r11,sp[0x0]
80009662:	18 32       	cp.w	r2,r12
80009664:	c0 40       	breq	8000966c <fatfs_compare_names+0xa0>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
80009666:	30 0c       	mov	r12,0
    // Compare main part of filenames
    if (FileString_StrCmpNoCase(strA, strB, file1Len)!=0)
        return 0;
    else
        return 1;
}
80009668:	2f cd       	sub	sp,-16
8000966a:	d8 32       	popm	r0-r7,pc
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000966c:	58 02       	cp.w	r2,0
8000966e:	e0 80 00 a3 	breq	800097b4 <fatfs_compare_names+0x1e8>
80009672:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
80009674:	31 9c       	mov	r12,25
80009676:	50 34       	stdsp	sp[0xc],r4
80009678:	c1 68       	rjmp	800096a4 <fatfs_compare_names+0xd8>
8000967a:	12 94       	mov	r4,r9
            a+= 32;
        if ((b>='A') && (b<='Z'))
8000967c:	f4 ce 00 41 	sub	lr,r10,65
80009680:	f8 0e 18 00 	cp.b	lr,r12
80009684:	e0 88 00 23 	brls	800096ca <fatfs_compare_names+0xfe>
80009688:	14 9e       	mov	lr,r10
            b+= 32;

        diff = a - b;
8000968a:	e8 0e 01 0e 	sub	lr,r4,lr

        // If different
        if (diff)
8000968e:	ce c1       	brne	80009666 <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
80009690:	58 09       	cp.w	r9,0
80009692:	e0 80 00 90 	breq	800097b2 <fatfs_compare_names+0x1e6>
80009696:	58 0a       	cp.w	r10,0
80009698:	e0 80 00 8d 	breq	800097b2 <fatfs_compare_names+0x1e6>
8000969c:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000969e:	10 32       	cp.w	r2,r8
800096a0:	e0 80 00 89 	breq	800097b2 <fatfs_compare_names+0x1e6>
    {
        a = *s1;
800096a4:	e2 08 07 09 	ld.ub	r9,r1[r8]
        b = *s2;
800096a8:	e0 08 07 0a 	ld.ub	r10,r0[r8]

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
800096ac:	f2 ce 00 41 	sub	lr,r9,65
800096b0:	f8 0e 18 00 	cp.b	lr,r12
800096b4:	fe 9b ff e3 	brhi	8000967a <fatfs_compare_names+0xae>
            a+= 32;
800096b8:	f2 c4 ff e0 	sub	r4,r9,-32
        if ((b>='A') && (b<='Z'))
800096bc:	f4 ce 00 41 	sub	lr,r10,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
800096c0:	5c 54       	castu.b	r4
        if ((b>='A') && (b<='Z'))
800096c2:	f8 0e 18 00 	cp.b	lr,r12
800096c6:	fe 9b ff e1 	brhi	80009688 <fatfs_compare_names+0xbc>
            b+= 32;
800096ca:	f4 ce ff e0 	sub	lr,r10,-32
800096ce:	5c 5e       	castu.b	lr
800096d0:	cd db       	rjmp	8000968a <fatfs_compare_names+0xbe>
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
800096d2:	50 0b       	stdsp	sp[0x0],r11
800096d4:	0e 9c       	mov	r12,r7
800096d6:	e0 a0 09 15 	rcall	8000a900 <strlen>
        file2Len = (int)strlen(strB);
800096da:	40 0b       	lddsp	r11,sp[0x0]
    }
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
800096dc:	18 96       	mov	r6,r12
        file2Len = (int)strlen(strB);
800096de:	16 9c       	mov	r12,r11
800096e0:	50 16       	stdsp	sp[0x4],r6
800096e2:	e0 a0 09 0f 	rcall	8000a900 <strlen>
800096e6:	40 0b       	lddsp	r11,sp[0x0]
800096e8:	50 2c       	stdsp	sp[0x8],r12
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
800096ea:	58 06       	cp.w	r6,0
800096ec:	c1 60       	breq	80009718 <fatfs_compare_names+0x14c>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
800096ee:	40 19       	lddsp	r9,sp[0x4]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
800096f0:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
800096f2:	20 19       	sub	r9,1
800096f4:	ee 09 00 09 	add	r9,r7,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
800096f8:	13 85       	ld.ub	r5,r9[0x0]
800096fa:	f0 05 18 00 	cp.b	r5,r8
800096fe:	c0 d1       	brne	80009718 <fatfs_compare_names+0x14c>
80009700:	f2 07 01 08 	sub	r8,r9,r7
80009704:	c0 68       	rjmp	80009710 <fatfs_compare_names+0x144>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
80009706:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
80009708:	13 7a       	ld.ub	r10,--r9
8000970a:	ea 0a 18 00 	cp.b	r10,r5
8000970e:	c0 41       	brne	80009716 <fatfs_compare_names+0x14a>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
80009710:	20 16       	sub	r6,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
80009712:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
80009714:	cf 91       	brne	80009706 <fatfs_compare_names+0x13a>
80009716:	1c 96       	mov	r6,lr
80009718:	58 0c       	cp.w	r12,0
8000971a:	c1 60       	breq	80009746 <fatfs_compare_names+0x17a>
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
8000971c:	40 29       	lddsp	r9,sp[0x8]
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
8000971e:	32 08       	mov	r8,32
// Returns -1 if not found or index otherwise
//-----------------------------------------------------------------------------
static int FileString_TrimLength(char *str, int strLen)
{
    int length = strLen;
    char *strSrc = str+strLen-1;
80009720:	20 19       	sub	r9,1
80009722:	f6 09 00 09 	add	r9,r11,r9
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
80009726:	13 85       	ld.ub	r5,r9[0x0]
80009728:	f0 05 18 00 	cp.b	r5,r8
8000972c:	c0 d1       	brne	80009746 <fatfs_compare_names+0x17a>
8000972e:	f2 0b 01 08 	sub	r8,r9,r11
80009732:	c0 68       	rjmp	8000973e <fatfs_compare_names+0x172>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
80009734:	20 18       	sub	r8,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
80009736:	13 7a       	ld.ub	r10,--r9
80009738:	ea 0a 18 00 	cp.b	r10,r5
8000973c:	c0 41       	brne	80009744 <fatfs_compare_names+0x178>
            length = (int)(strSrc - str);
        else
            break;

        strSrc--;
        strLen--;
8000973e:	20 1c       	sub	r12,1
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
    {
        if (*strSrc == ' ')
80009740:	10 9e       	mov	lr,r8
{
    int length = strLen;
    char *strSrc = str+strLen-1;
    
    // Find last non white space
    while (strLen != 0)
80009742:	cf 91       	brne	80009734 <fatfs_compare_names+0x168>
80009744:	1c 9c       	mov	r12,lr
    // Find length without trailing spaces (before ext)
    file1Len = FileString_TrimLength(strA, file1Len);
    file2Len = FileString_TrimLength(strB, file2Len);

    // Check the file lengths match
    if (file1Len!=file2Len)
80009746:	18 36       	cp.w	r6,r12
80009748:	c8 f1       	brne	80009666 <fatfs_compare_names+0x9a>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
8000974a:	58 06       	cp.w	r6,0
8000974c:	c3 60       	breq	800097b8 <fatfs_compare_names+0x1ec>
8000974e:	30 08       	mov	r8,0
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
80009750:	31 99       	mov	r9,25
80009752:	c1 88       	rjmp	80009782 <fatfs_compare_names+0x1b6>
80009754:	08 9c       	mov	r12,r4
            a+= 32;
        if ((b>='A') && (b<='Z'))
80009756:	e6 ca 00 41 	sub	r10,r3,65
8000975a:	f2 0a 18 00 	cp.b	r10,r9
8000975e:	e0 88 00 21 	brls	800097a0 <fatfs_compare_names+0x1d4>
80009762:	06 9a       	mov	r10,r3
            b+= 32;

        diff = a - b;

        // If different
        if (diff)
80009764:	f4 0c 18 00 	cp.b	r12,r10
80009768:	fe 91 ff 7f 	brne	80009666 <fatfs_compare_names+0x9a>
            return diff;
        
        // If run out of strings
        if ( (*s1 == 0) || (*s2 == 0) )
8000976c:	58 04       	cp.w	r4,0
8000976e:	c2 50       	breq	800097b8 <fatfs_compare_names+0x1ec>
80009770:	58 03       	cp.w	r3,0
80009772:	c2 30       	breq	800097b8 <fatfs_compare_names+0x1ec>
80009774:	2f f8       	sub	r8,-1
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
80009776:	10 36       	cp.w	r6,r8
80009778:	c2 00       	breq	800097b8 <fatfs_compare_names+0x1ec>
8000977a:	ee 08 07 04 	ld.ub	r4,r7[r8]
8000977e:	f6 08 07 03 	ld.ub	r3,r11[r8]
    {
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
80009782:	08 9a       	mov	r10,r4
80009784:	24 1a       	sub	r10,65
80009786:	f2 0a 18 00 	cp.b	r10,r9
8000978a:	fe 9b ff e5 	brhi	80009754 <fatfs_compare_names+0x188>
            a+= 32;
8000978e:	08 9c       	mov	r12,r4
        if ((b>='A') && (b<='Z'))
80009790:	e6 ca 00 41 	sub	r10,r3,65
        a = *s1;
        b = *s2;

        // Make lower case if uppercase
        if ((a>='A') && (a<='Z'))
            a+= 32;
80009794:	2e 0c       	sub	r12,-32
80009796:	5c 5c       	castu.b	r12
        if ((b>='A') && (b<='Z'))
80009798:	f2 0a 18 00 	cp.b	r10,r9
8000979c:	fe 9b ff e3 	brhi	80009762 <fatfs_compare_names+0x196>
            b+= 32;
800097a0:	e6 ca ff e0 	sub	r10,r3,-32
800097a4:	5c 5a       	castu.b	r10
800097a6:	cd fb       	rjmp	80009764 <fatfs_compare_names+0x198>
{
    int dotPos = -1;
    char *strSrc = str;
    
    // Find last '.' in string (if at all)
    while (*strSrc)
800097a8:	3f f6       	mov	r6,-1
800097aa:	c2 6b       	rjmp	800095f6 <fatfs_compare_names+0x2a>
800097ac:	30 19       	mov	r9,1
800097ae:	3f f5       	mov	r5,-1
800097b0:	c4 0b       	rjmp	80009630 <fatfs_compare_names+0x64>
800097b2:	40 34       	lddsp	r4,sp[0xc]
    // No extensions
    else
    {
        // Filelength is actual filelength
        file1Len = (int)strlen(strA);
        file2Len = (int)strlen(strB);
800097b4:	0a 9c       	mov	r12,r5
800097b6:	c9 ab       	rjmp	800096ea <fatfs_compare_names+0x11e>
static int FileString_StrCmpNoCase(char *s1, char *s2, int n)
{
    int diff;
    char a,b;

    while (n--)
800097b8:	30 1c       	mov	r12,1
800097ba:	c5 7b       	rjmp	80009668 <fatfs_compare_names+0x9c>

800097bc <fatfs_get_substring>:
800097bc:	eb cd 40 f8 	pushm	r3-r7,lr
// (or file) at the specified level.
// E.g. C:\folder\file.zip : Level 0 = C:\folder, Level 1 = file.zip
// Returns: -1 = Error, 0 = Ok
//-----------------------------------------------------------------------------
int fatfs_get_substring(char *path, int levelreq, char *output, int max_len)
{
800097c0:	20 3d       	sub	sp,12
    int pathlen=0;
    int levels=0;
    int copypnt=0;
    char expectedchar;

    if (!path || max_len <= 0)
800097c2:	58 0c       	cp.w	r12,0
800097c4:	5f 08       	sreq	r8
800097c6:	58 09       	cp.w	r9,0
800097c8:	5f a7       	srle	r7
800097ca:	ef e8 10 08 	or	r8,r7,r8
800097ce:	c4 61       	brne	8000985a <fatfs_get_substring+0x9e>
        return -1;

    // Acceptable formats:
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
800097d0:	19 8e       	ld.ub	lr,r12[0x0]
800097d2:	32 f8       	mov	r8,47
800097d4:	f0 0e 18 00 	cp.b	lr,r8
800097d8:	c4 40       	breq	80009860 <fatfs_get_substring+0xa4>
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
800097da:	19 9e       	ld.ub	lr,r12[0x1]
800097dc:	33 a8       	mov	r8,58
800097de:	f0 0e 18 00 	cp.b	lr,r8
800097e2:	c3 71       	brne	80009850 <fatfs_get_substring+0x94>
    {
        expectedchar = '\\';
        path += 3;
800097e4:	f8 c6 ff fd 	sub	r6,r12,-3
800097e8:	35 c7       	mov	r7,92
    }
    else
        return -1;

    // Get string length of path
    pathlen = (int)strlen (path);
800097ea:	50 2b       	stdsp	sp[0x8],r11
800097ec:	50 1a       	stdsp	sp[0x4],r10
800097ee:	50 09       	stdsp	sp[0x0],r9
800097f0:	0c 9c       	mov	r12,r6
800097f2:	e0 a0 08 87 	rcall	8000a900 <strlen>

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
800097f6:	40 2b       	lddsp	r11,sp[0x8]
800097f8:	40 1a       	lddsp	r10,sp[0x4]
800097fa:	40 09       	lddsp	r9,sp[0x0]
800097fc:	e0 8a 00 36 	brle	80009868 <fatfs_get_substring+0xac>
80009800:	30 04       	mov	r4,0
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
80009802:	20 19       	sub	r9,1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
80009804:	08 95       	mov	r5,r4
80009806:	08 98       	mov	r8,r4
80009808:	c0 48       	rjmp	80009810 <fatfs_get_substring+0x54>
8000980a:	2f f8       	sub	r8,-1
8000980c:	10 3c       	cp.w	r12,r8
8000980e:	c1 70       	breq	8000983c <fatfs_get_substring+0x80>
    {
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;
80009810:	ec 08 07 0e 	ld.ub	lr,r6[r8]
80009814:	0e 93       	mov	r3,r7
80009816:	ee 0e 18 00 	cp.b	lr,r7
8000981a:	f7 b5 00 ff 	subeq	r5,-1

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
8000981e:	16 35       	cp.w	r5,r11
80009820:	cf 51       	brne	8000980a <fatfs_get_substring+0x4e>
80009822:	0e 93       	mov	r3,r7
80009824:	fc 07 18 00 	cp.b	r7,lr
80009828:	cf 10       	breq	8000980a <fatfs_get_substring+0x4e>
8000982a:	08 39       	cp.w	r9,r4
8000982c:	fe 9a ff ef 	brle	8000980a <fatfs_get_substring+0x4e>
            output[copypnt++] = *path;
80009830:	f4 04 0b 0e 	st.b	r10[r4],lr

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
80009834:	2f f8       	sub	r8,-1
        // If a '\' is found then increase level
        if (*path == expectedchar) levels++;

        // If correct level and the character is not a '\' or '/' then copy text to 'output'
        if ( (levels == levelreq) && (*path != expectedchar) && (copypnt < (max_len-1))) 
            output[copypnt++] = *path;
80009836:	2f f4       	sub	r4,-1

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
80009838:	10 3c       	cp.w	r12,r8
8000983a:	ce b1       	brne	80009810 <fatfs_get_substring+0x54>
        // Increment through path string
        path++;
    }

    // Null Terminate
    output[copypnt] = '\0';
8000983c:	30 08       	mov	r8,0
8000983e:	f4 04 0b 08 	st.b	r10[r4],r8

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
80009842:	15 89       	ld.ub	r9,r10[0x0]
80009844:	f0 09 18 00 	cp.b	r9,r8
80009848:	c0 90       	breq	8000985a <fatfs_get_substring+0x9e>
8000984a:	2f dd       	sub	sp,-12
8000984c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
    }
    else if (path[1] == ':' || path[2] == '\\')
80009850:	19 ae       	ld.ub	lr,r12[0x2]
80009852:	35 c8       	mov	r8,92
80009854:	f0 0e 18 00 	cp.b	lr,r8
80009858:	cc 60       	breq	800097e4 <fatfs_get_substring+0x28>

    // Null Terminate
    output[copypnt] = '\0';

    // If a string was copied return 0 else return 1
    if (output[0] != '\0') 
8000985a:	2f dd       	sub	sp,-12
8000985c:	e3 cf c0 f8 	ldm	sp++,r3-r7,pc,r12=-1
    //  c:\folder\file.zip
    //  /dev/etc/samba.conf
    if (*path == '/')
    {
        expectedchar = '/';
        path++;
80009860:	f8 c6 ff ff 	sub	r6,r12,-1
80009864:	32 f7       	mov	r7,47
80009866:	cc 2b       	rjmp	800097ea <fatfs_get_substring+0x2e>

    // Get string length of path
    pathlen = (int)strlen (path);

    // Loop through the number of times as characters in 'path'
    for (i = 0; i<pathlen; i++)
80009868:	30 04       	mov	r4,0
8000986a:	ce 9b       	rjmp	8000983c <fatfs_get_substring+0x80>

8000986c <fatfs_split_path>:
8000986c:	eb cd 40 fc 	pushm	r2-r7,lr
// Returned is the path string and file Name string
// E.g. C:\folder\file.zip -> path = C:\folder  filename = file.zip
// E.g. C:\file.zip -> path = [blank]  filename = file.zip
//-----------------------------------------------------------------------------
int fatfs_split_path(char *full_path, char *path, int max_path, char *filename, int max_filename)
{
80009870:	16 96       	mov	r6,r11
80009872:	14 93       	mov	r3,r10
80009874:	12 97       	mov	r7,r9
80009876:	10 92       	mov	r2,r8
80009878:	18 94       	mov	r4,r12
    int strindex;

    // Count the levels to the filepath
    int levels = fatfs_total_path_levels(full_path);
8000987a:	c7 be       	rcall	80009570 <fatfs_total_path_levels>
8000987c:	18 95       	mov	r5,r12
8000987e:	5b fc       	cp.w	r12,-1
    if (levels == -1)
80009880:	c0 31       	brne	80009886 <fatfs_split_path+0x1a>
80009882:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
        strindex = (int)strlen(full_path) - (int)strlen(filename);
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
        path[strindex-1] = '\0';
80009886:	04 99       	mov	r9,r2
    int levels = fatfs_total_path_levels(full_path);
    if (levels == -1)
        return -1;

    // Get filename part of string
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
80009888:	18 9b       	mov	r11,r12
8000988a:	0e 9a       	mov	r10,r7
8000988c:	08 9c       	mov	r12,r4
8000988e:	c9 7f       	rcall	800097bc <fatfs_get_substring>
80009890:	18 92       	mov	r2,r12
80009892:	cf 81       	brne	80009882 <fatfs_split_path+0x16>
80009894:	58 05       	cp.w	r5,0
80009896:	c1 70       	breq	800098c4 <fatfs_split_path+0x58>
        return -1;

    // If root file
    if (levels == 0)
80009898:	08 9c       	mov	r12,r4
8000989a:	e0 a0 08 33 	rcall	8000a900 <strlen>
        path[0] = '\0';
    else
    {
        strindex = (int)strlen(full_path) - (int)strlen(filename);
8000989e:	18 95       	mov	r5,r12
800098a0:	0e 9c       	mov	r12,r7
800098a2:	e0 a0 08 2f 	rcall	8000a900 <strlen>
800098a6:	ea 0c 01 0c 	sub	r12,r5,r12
800098aa:	08 9b       	mov	r11,r4
800098ac:	f8 03 0d 43 	min	r3,r12,r3
        if (strindex > max_path)
            strindex = max_path;

        memcpy(path, full_path, strindex);
800098b0:	0c 9c       	mov	r12,r6
800098b2:	06 9a       	mov	r10,r3
800098b4:	e0 a0 07 68 	rcall	8000a784 <memcpy>
800098b8:	06 06       	add	r6,r3
800098ba:	04 9c       	mov	r12,r2
        path[strindex-1] = '\0';
800098bc:	ed 62 ff ff 	st.b	r6[-1],r2
800098c0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800098c4:	ac 85       	st.b	r6[0x0],r5
800098c6:	0a 9c       	mov	r12,r5
    if (fatfs_get_substring(full_path, levels, filename, max_filename) != 0)
        return -1;

    // If root file
    if (levels == 0)
        path[0] = '\0';
800098c8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

800098cc <fatfs_fat_writeback>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_writeback: Writeback 'dirty' FAT sectors to disk
//-----------------------------------------------------------------------------
static int fatfs_fat_writeback(struct fatfs *fs, struct fat_buffer *pcur)
{
800098cc:	eb cd 40 80 	pushm	r7,lr
800098d0:	16 97       	mov	r7,r11
    if (pcur)
800098d2:	58 0b       	cp.w	r11,0
800098d4:	c1 e0       	breq	80009910 <fatfs_fat_writeback+0x44>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
800098d6:	f6 f8 02 04 	ld.w	r8,r11[516]
800098da:	58 08       	cp.w	r8,0
800098dc:	c1 80       	breq	8000990c <fatfs_fat_writeback+0x40>
        {
            if (fs->disk_io.write_media)
800098de:	78 e8       	ld.w	r8,r12[0x38]
800098e0:	58 08       	cp.w	r8,0
800098e2:	c1 20       	breq	80009906 <fatfs_fat_writeback+0x3a>
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
800098e4:	78 8b       	ld.w	r11,r12[0x20]
        if (pcur->dirty) 
        {
            if (fs->disk_io.write_media)
            {
                uint32 sectors = FAT_BUFFER_SECTORS;
                uint32 offset = pcur->address - fs->fat_begin_lba;
800098e6:	ee f9 02 00 	ld.w	r9,r7[512]
800098ea:	78 5a       	ld.w	r10,r12[0x14]
800098ec:	f2 0a 01 0a 	sub	r10,r9,r10

                // Limit to sectors used for the FAT
                if ((offset + FAT_BUFFER_SECTORS) <= fs->fat_sectors)
800098f0:	f4 cc ff ff 	sub	r12,r10,-1
800098f4:	16 3c       	cp.w	r12,r11
800098f6:	f9 ba 08 01 	movls	r10,1
                    sectors = FAT_BUFFER_SECTORS;
                else
                    sectors = fs->fat_sectors - offset;
800098fa:	f7 da eb 1a 	subhi	r10,r11,r10

                if (!fs->disk_io.write_media(pcur->address, pcur->sector, sectors))
800098fe:	12 9c       	mov	r12,r9
80009900:	0e 9b       	mov	r11,r7
80009902:	5d 18       	icall	r8
80009904:	c0 60       	breq	80009910 <fatfs_fat_writeback+0x44>
                    return 0;
            }
                
            pcur->dirty = 0;
80009906:	30 08       	mov	r8,0
80009908:	ef 48 02 04 	st.w	r7[516],r8
8000990c:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80009910:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80009914 <fatfs_fat_read_sector>:
}
//-----------------------------------------------------------------------------
// fatfs_fat_read_sector: Read a FAT sector
//-----------------------------------------------------------------------------
static struct fat_buffer *fatfs_fat_read_sector(struct fatfs *fs, uint32 sector)
{
80009914:	eb cd 40 e0 	pushm	r5-r7,lr
80009918:	18 95       	mov	r5,r12
8000991a:	16 96       	mov	r6,r11
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;
8000991c:	f8 f7 02 54 	ld.w	r7,r12[596]

    // Itterate through sector buffer list
    while (pcur)
80009920:	58 07       	cp.w	r7,0
80009922:	c4 10       	breq	800099a4 <fatfs_fat_read_sector+0x90>
80009924:	30 09       	mov	r9,0
80009926:	c0 38       	rjmp	8000992c <fatfs_fat_read_sector+0x18>
80009928:	0e 99       	mov	r9,r7
8000992a:	10 97       	mov	r7,r8
    {
        // Sector within this buffer?
        if ((sector >= pcur->address) && (sector < (pcur->address + FAT_BUFFER_SECTORS)))
8000992c:	ee f8 02 00 	ld.w	r8,r7[512]
80009930:	0c 38       	cp.w	r8,r6
80009932:	e0 8b 00 06 	brhi	8000993e <fatfs_fat_read_sector+0x2a>
80009936:	f0 ca ff ff 	sub	r10,r8,-1
8000993a:	14 36       	cp.w	r6,r10
8000993c:	c2 53       	brcs	80009986 <fatfs_fat_read_sector+0x72>
            break;

        // End of list?
        if (pcur->next == NULL)
8000993e:	ee f8 02 0c 	ld.w	r8,r7[524]
80009942:	58 08       	cp.w	r8,0
80009944:	cf 21       	brne	80009928 <fatfs_fat_read_sector+0x14>
        {
            // Remove buffer from list
            if (last)
                last->next = NULL;
80009946:	58 09       	cp.w	r9,0
80009948:	f3 f8 1a 83 	st.wne	r9[0x20c],r8
            // We the first and last buffer in the chain?
            else
                fs->fat_buffer_head = NULL;
8000994c:	eb f9 0a 95 	st.weq	r5[0x254],r9
        }

        last = pcur;
        pcur = pcur->next;
80009950:	ee f8 02 0c 	ld.w	r8,r7[524]
{
    struct fat_buffer *last = NULL;
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
80009954:	58 08       	cp.w	r8,0
80009956:	ce 91       	brne	80009928 <fatfs_fat_read_sector+0x14>
80009958:	ea f8 02 54 	ld.w	r8,r5[596]

    // Else, we removed the last item from the list
    pcur = last;

    // Add to start of sector buffer list (now newest sector)
    pcur->next = fs->fat_buffer_head;
8000995c:	ef 48 02 0c 	st.w	r7[524],r8
    fs->fat_buffer_head = pcur;
80009960:	eb 47 02 54 	st.w	r5[596],r7

    // Writeback sector if changed
    if (pcur->dirty)
80009964:	ee f8 02 04 	ld.w	r8,r7[516]
80009968:	58 08       	cp.w	r8,0
8000996a:	c1 f1       	brne	800099a8 <fatfs_fat_read_sector+0x94>
        if (!fatfs_fat_writeback(fs, pcur))
            return 0;

    // Address is now new sector
    pcur->address = sector;
8000996c:	ef 46 02 00 	st.w	r7[512],r6

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
80009970:	0c 9c       	mov	r12,r6
80009972:	6a d8       	ld.w	r8,r5[0x34]
80009974:	30 1a       	mov	r10,1
80009976:	0e 9b       	mov	r11,r7
80009978:	5d 18       	icall	r8
8000997a:	c1 00       	breq	8000999a <fatfs_fat_read_sector+0x86>
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
        return NULL;
    }

    pcur->ptr = pcur->sector;
8000997c:	ef 47 02 08 	st.w	r7[520],r7
    return pcur;
}
80009980:	0e 9c       	mov	r12,r7
80009982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
    }

    // We found the sector already in FAT buffer chain
    if (pcur)
    {
        pcur->ptr = (uint8 *)(pcur->sector + ((sector - pcur->address) * FAT_SECTOR_SIZE));
80009986:	ec 08 01 08 	sub	r8,r6,r8
8000998a:	a9 78       	lsl	r8,0x9
8000998c:	ee 08 00 08 	add	r8,r7,r8
80009990:	ef 48 02 08 	st.w	r7[520],r8
        return NULL;
    }

    pcur->ptr = pcur->sector;
    return pcur;
}
80009994:	0e 9c       	mov	r12,r7
80009996:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
8000999a:	3f f8       	mov	r8,-1
8000999c:	ef 48 02 00 	st.w	r7[512],r8
800099a0:	18 97       	mov	r7,r12
        return NULL;
800099a2:	cf 9b       	rjmp	80009994 <fatfs_fat_read_sector+0x80>
    }

    pcur->ptr = pcur->sector;
    return pcur;
800099a4:	0e 98       	mov	r8,r7
800099a6:	cd bb       	rjmp	8000995c <fatfs_fat_read_sector+0x48>
    pcur->next = fs->fat_buffer_head;
    fs->fat_buffer_head = pcur;

    // Writeback sector if changed
    if (pcur->dirty)
        if (!fatfs_fat_writeback(fs, pcur))
800099a8:	0e 9b       	mov	r11,r7
800099aa:	0a 9c       	mov	r12,r5
800099ac:	c9 0f       	rcall	800098cc <fatfs_fat_writeback>
800099ae:	cd f1       	brne	8000996c <fatfs_fat_read_sector+0x58>
800099b0:	18 97       	mov	r7,r12

    // Read next sector
    if (!fs->disk_io.read_media(pcur->address, pcur->sector, FAT_BUFFER_SECTORS))
    {
        // Read failed, invalidate buffer address
        pcur->address = FAT32_INVALID_CLUSTER;
800099b2:	cf 1b       	rjmp	80009994 <fatfs_fat_read_sector+0x80>

800099b4 <fatfs_fat_purge>:
800099b4:	eb cd 40 c0 	pushm	r6-r7,lr
800099b8:	18 96       	mov	r6,r12
800099ba:	f8 f7 02 54 	ld.w	r7,r12[596]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
800099be:	58 07       	cp.w	r7,0
800099c0:	c0 61       	brne	800099cc <fatfs_fat_purge+0x18>
800099c2:	c0 f8       	rjmp	800099e0 <fatfs_fat_purge+0x2c>
        // Writeback sector if changed
        if (pcur->dirty) 
            if (!fatfs_fat_writeback(fs, pcur))
                return 0;
        
        pcur = pcur->next;
800099c4:	ee f7 02 0c 	ld.w	r7,r7[524]
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
800099c8:	58 07       	cp.w	r7,0
800099ca:	c0 b0       	breq	800099e0 <fatfs_fat_purge+0x2c>
    {
        // Writeback sector if changed
        if (pcur->dirty) 
800099cc:	ee f8 02 04 	ld.w	r8,r7[516]
800099d0:	58 08       	cp.w	r8,0
800099d2:	cf 90       	breq	800099c4 <fatfs_fat_purge+0x10>
            if (!fatfs_fat_writeback(fs, pcur))
800099d4:	0e 9b       	mov	r11,r7
800099d6:	0c 9c       	mov	r12,r6
800099d8:	c7 af       	rcall	800098cc <fatfs_fat_writeback>
800099da:	cf 51       	brne	800099c4 <fatfs_fat_purge+0x10>
800099dc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
        
        pcur = pcur->next;
    }

    return 1;
}
800099e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1

800099e4 <fatfs_find_next_cluster>:
int fatfs_fat_purge(struct fatfs *fs)
{
    struct fat_buffer *pcur = fs->fat_buffer_head;

    // Itterate through sector buffer list
    while (pcur)
800099e4:	eb cd 40 e0 	pushm	r5-r7,lr
800099e8:	18 97       	mov	r7,r12
800099ea:	58 0b       	cp.w	r11,0
    uint32 fat_sector_offset, position;
    uint32 nextcluster;
    struct fat_buffer *pbuf;

    // Why is '..' labelled with cluster 0 when it should be 2 ??
    if (current_cluster == 0) 
800099ec:	f6 06 17 10 	movne	r6,r11
800099f0:	f9 b6 00 02 	moveq	r6,2
        current_cluster = 2;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
800099f4:	78 c8       	ld.w	r8,r12[0x30]
800099f6:	58 08       	cp.w	r8,0
800099f8:	c2 b1       	brne	80009a4e <fatfs_find_next_cluster+0x6a>
        fat_sector_offset = current_cluster / 256;
800099fa:	ec 05 16 08 	lsr	r5,r6,0x8
    else
        fat_sector_offset = current_cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
800099fe:	6e 5b       	ld.w	r11,r7[0x14]
80009a00:	0e 9c       	mov	r12,r7
80009a02:	ea 0b 00 0b 	add	r11,r5,r11
80009a06:	c8 7f       	rcall	80009914 <fatfs_fat_read_sector>
80009a08:	c3 a0       	breq	80009a7c <fatfs_find_next_cluster+0x98>
    if (!pbuf)
80009a0a:	6e c8       	ld.w	r8,r7[0x30]
        return (FAT32_LAST_CLUSTER); 

    if (fs->fat_type == FAT_TYPE_16)
80009a0c:	58 08       	cp.w	r8,0
80009a0e:	c2 30       	breq	80009a54 <fatfs_find_next_cluster+0x70>
80009a10:	f8 f8 02 08 	ld.w	r8,r12[520]
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 128)) * 4; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009a14:	a7 75       	lsl	r5,0x7
80009a16:	0a 16       	sub	r6,r5
80009a18:	a3 66       	lsl	r6,0x2
80009a1a:	5c 76       	castu.h	r6
80009a1c:	f0 06 07 09 	ld.ub	r9,r8[r6]
80009a20:	f0 06 00 06 	add	r6,r8,r6
80009a24:	0d 98       	ld.ub	r8,r6[0x1]
80009a26:	a9 68       	lsl	r8,0x8
80009a28:	0d bc       	ld.ub	r12,r6[0x3]
80009a2a:	0d aa       	ld.ub	r10,r6[0x2]
80009a2c:	b9 6c       	lsl	r12,0x18
80009a2e:	b1 6a       	lsl	r10,0x10
80009a30:	14 0c       	add	r12,r10
80009a32:	12 0c       	add	r12,r9
80009a34:	10 0c       	add	r12,r8
80009a36:	30 88       	mov	r8,8

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
80009a38:	ea 18 f0 00 	orh	r8,0xf000
80009a3c:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        
80009a40:	f8 08 00 08 	add	r8,r12,r8

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
80009a44:	58 78       	cp.w	r8,7
80009a46:	e0 88 00 1b 	brls	80009a7c <fatfs_find_next_cluster+0x98>
80009a4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
            return (FAT32_LAST_CLUSTER); 
    }

    // Else return next cluster
    return (nextcluster);                         
} 
80009a4e:	ec 05 16 07 	lsr	r5,r6,0x7

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = current_cluster / 256;
    else
        fat_sector_offset = current_cluster / 128;
80009a52:	cd 6b       	rjmp	800099fe <fatfs_find_next_cluster+0x1a>
80009a54:	f8 f8 02 08 	ld.w	r8,r12[520]
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (current_cluster - (fat_sector_offset * 256)) * 2; 

        // Read Next Clusters value from Sector Buffer
        nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009a58:	a9 65       	lsl	r5,0x8
80009a5a:	0a 16       	sub	r6,r5
80009a5c:	a1 76       	lsl	r6,0x1
80009a5e:	5c 76       	castu.h	r6
80009a60:	f0 06 07 09 	ld.ub	r9,r8[r6]
80009a64:	f0 06 00 06 	add	r6,r8,r6
80009a68:	0d 9c       	ld.ub	r12,r6[0x1]
80009a6a:	a9 6c       	lsl	r12,0x8
80009a6c:	12 0c       	add	r12,r9
80009a6e:	fe 79 00 08 	mov	r9,-65528

        // If end of chain found
        if (nextcluster >= 0xFFF8 && nextcluster <= 0xFFFF) 
80009a72:	f8 09 00 08 	add	r8,r12,r9
80009a76:	58 78       	cp.w	r8,7
80009a78:	fe 9b ff e9 	brhi	80009a4a <fatfs_find_next_cluster+0x66>
80009a7c:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1

80009a80 <fatfs_set_fs_info_next_free_cluster>:

        // Mask out MS 4 bits (its 28bit addressing)
        nextcluster = nextcluster & 0x0FFFFFFF;        

        // If end of chain found
        if (nextcluster >= 0x0FFFFFF8 && nextcluster <= 0x0FFFFFFF) 
80009a80:	eb cd 40 e0 	pushm	r5-r7,lr
80009a84:	16 95       	mov	r5,r11
80009a86:	18 96       	mov	r6,r12
//-----------------------------------------------------------------------------
// fatfs_set_fs_info_next_free_cluster: Write the next free cluster to the FSINFO table
//-----------------------------------------------------------------------------
void fatfs_set_fs_info_next_free_cluster(struct fatfs *fs, uint32 newValue)
{
    if (fs->fat_type == FAT_TYPE_16)
80009a88:	78 c8       	ld.w	r8,r12[0x30]
80009a8a:	58 08       	cp.w	r8,0
80009a8c:	c0 31       	brne	80009a92 <fatfs_set_fs_info_next_free_cluster+0x12>
80009a8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        ;
    else
    {
        // Load sector to change it
        struct fat_buffer *pbuf = fatfs_fat_read_sector(fs, fs->lba_begin+fs->fs_info_sector);
80009a92:	78 78       	ld.w	r8,r12[0x1c]
80009a94:	f9 1b 00 18 	ld.uh	r11,r12[24]
80009a98:	10 0b       	add	r11,r8
80009a9a:	c3 df       	rcall	80009914 <fatfs_fat_read_sector>
80009a9c:	18 97       	mov	r7,r12
80009a9e:	cf 80       	breq	80009a8e <fatfs_set_fs_info_next_free_cluster+0xe>
        if (!pbuf)
80009aa0:	f8 f8 02 08 	ld.w	r8,r12[520]
            return ;

        // Change 
        FAT32_SET_32BIT_WORD(pbuf, 492, newValue);
80009aa4:	ea 09 16 08 	lsr	r9,r5,0x8
80009aa8:	f1 65 01 ec 	st.b	r8[492],r5
80009aac:	f8 f8 02 08 	ld.w	r8,r12[520]
80009ab0:	f1 69 01 ed 	st.b	r8[493],r9
80009ab4:	ea 09 16 10 	lsr	r9,r5,0x10
80009ab8:	f8 f8 02 08 	ld.w	r8,r12[520]
80009abc:	f1 69 01 ee 	st.b	r8[494],r9
80009ac0:	ea 09 16 18 	lsr	r9,r5,0x18
80009ac4:	f8 f8 02 08 	ld.w	r8,r12[520]
80009ac8:	f1 69 01 ef 	st.b	r8[495],r9
80009acc:	30 1a       	mov	r10,1
80009ace:	f9 4a 02 04 	st.w	r12[516],r10
80009ad2:	8d 95       	st.w	r6[0x24],r5
        fs->next_free_cluster = newValue;
80009ad4:	6c e8       	ld.w	r8,r6[0x38]

        // Write back FSINFO sector to disk
        if (fs->disk_io.write_media)
80009ad6:	58 08       	cp.w	r8,0
80009ad8:	c0 50       	breq	80009ae2 <fatfs_set_fs_info_next_free_cluster+0x62>
80009ada:	18 9b       	mov	r11,r12
            fs->disk_io.write_media(pbuf->address, pbuf->sector, 1);    
80009adc:	f8 fc 02 00 	ld.w	r12,r12[512]
80009ae0:	5d 18       	icall	r8
80009ae2:	3f f8       	mov	r8,-1

        // Invalidate cache entry
        pbuf->address = FAT32_INVALID_CLUSTER;
80009ae4:	ef 48 02 00 	st.w	r7[512],r8
80009ae8:	30 08       	mov	r8,0
        pbuf->dirty = 0;
80009aea:	ef 48 02 04 	st.w	r7[516],r8
80009aee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009af2:	d7 03       	nop

80009af4 <fatfs_find_blank_cluster>:
80009af4:	d4 21       	pushm	r4-r7,lr
80009af6:	18 97       	mov	r7,r12
//-----------------------------------------------------------------------------
// fatfs_find_blank_cluster: Find a free cluster entry by reading the FAT
//-----------------------------------------------------------------------------
#if FATFS_INC_WRITE_SUPPORT
int fatfs_find_blank_cluster(struct fatfs *fs, uint32 start_cluster, uint32 *free_cluster)
{
80009af8:	14 94       	mov	r4,r10
80009afa:	16 95       	mov	r5,r11
80009afc:	78 c8       	ld.w	r8,r12[0x30]
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
80009afe:	58 08       	cp.w	r8,0
80009b00:	c2 91       	brne	80009b52 <fatfs_find_blank_cluster+0x5e>
            fat_sector_offset = current_cluster / 256;
80009b02:	ea 06 16 08 	lsr	r6,r5,0x8
        else
            fat_sector_offset = current_cluster / 128;

        if ( fat_sector_offset < fs->fat_sectors)
80009b06:	6e 88       	ld.w	r8,r7[0x20]
80009b08:	10 36       	cp.w	r6,r8
80009b0a:	c2 92       	brcc	80009b5c <fatfs_find_blank_cluster+0x68>
        {
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
80009b0c:	6e 5b       	ld.w	r11,r7[0x14]
80009b0e:	0e 9c       	mov	r12,r7
80009b10:	ec 0b 00 0b 	add	r11,r6,r11
80009b14:	c0 0f       	rcall	80009914 <fatfs_fat_read_sector>
80009b16:	c2 30       	breq	80009b5c <fatfs_find_blank_cluster+0x68>
            if (!pbuf)
80009b18:	ec 0b 15 08 	lsl	r11,r6,0x8
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009b1c:	ec 0a 15 07 	lsl	r10,r6,0x7
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009b20:	ea 0b 01 0b 	sub	r11,r5,r11
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009b24:	ea 0a 01 0a 	sub	r10,r5,r10
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009b28:	a1 7b       	lsl	r11,0x1
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009b2a:	a3 6a       	lsl	r10,0x2
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009b2c:	5c 7b       	castu.h	r11
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009b2e:	5c 7a       	castu.h	r10
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009b30:	6e c8       	ld.w	r8,r7[0x30]
            // Read FAT sector into buffer
            pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
            if (!pbuf)
                return 0;

            if (fs->fat_type == FAT_TYPE_16)
80009b32:	58 08       	cp.w	r8,0
80009b34:	c1 71       	brne	80009b62 <fatfs_find_blank_cluster+0x6e>
80009b36:	f8 fa 02 08 	ld.w	r10,r12[520]
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 256)) * 2; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT16_GET_16BIT_WORD(pbuf, (uint16)position);     
80009b3a:	f4 0b 07 0c 	ld.ub	r12,r10[r11]
80009b3e:	f4 0b 00 0b 	add	r11,r10,r11
80009b42:	17 99       	ld.ub	r9,r11[0x1]
80009b44:	a9 69       	lsl	r9,0x8
80009b46:	18 09       	add	r9,r12
80009b48:	58 09       	cp.w	r9,0

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
80009b4a:	c0 a0       	breq	80009b5e <fatfs_find_blank_cluster+0x6a>
80009b4c:	2f f5       	sub	r5,-1
                current_cluster++;
80009b4e:	58 08       	cp.w	r8,0
    struct fat_buffer *pbuf;

    do
    {
        // Find which sector of FAT table to read
        if (fs->fat_type == FAT_TYPE_16)
80009b50:	cd 90       	breq	80009b02 <fatfs_find_blank_cluster+0xe>
80009b52:	ea 06 16 07 	lsr	r6,r5,0x7
            fat_sector_offset = current_cluster / 256;
        else
            fat_sector_offset = current_cluster / 128;
80009b56:	6e 88       	ld.w	r8,r7[0x20]

        if ( fat_sector_offset < fs->fat_sectors)
80009b58:	10 36       	cp.w	r6,r8
80009b5a:	cd 93       	brcs	80009b0c <fatfs_find_blank_cluster+0x18>
80009b5c:	d8 2a       	popm	r4-r7,pc,r12=0
                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
            }

            if (nextcluster !=0 )
                current_cluster++;
80009b5e:	89 05       	st.w	r4[0x0],r5
            return 0;
    }
    while (nextcluster != 0x0);

    // Found blank entry
    *free_cluster = current_cluster;
80009b60:	da 2a       	popm	r4-r7,pc,r12=1
80009b62:	f8 fb 02 08 	ld.w	r11,r12[520]
            {
                // Find 32 bit entry of current sector relating to cluster number 
                position = (current_cluster - (fat_sector_offset * 128)) * 4; 

                // Read Next Clusters value from Sector Buffer
                nextcluster = FAT32_GET_32BIT_WORD(pbuf, (uint16)position);     
80009b66:	f6 0a 07 0c 	ld.ub	r12,r11[r10]
80009b6a:	f6 0a 00 0a 	add	r10,r11,r10
80009b6e:	15 9b       	ld.ub	r11,r10[0x1]
80009b70:	15 b6       	ld.ub	r6,r10[0x3]
80009b72:	a9 6b       	lsl	r11,0x8
80009b74:	b9 66       	lsl	r6,0x18
80009b76:	15 a9       	ld.ub	r9,r10[0x2]
80009b78:	b1 69       	lsl	r9,0x10
80009b7a:	ec 09 00 09 	add	r9,r6,r9
80009b7e:	18 09       	add	r9,r12
80009b80:	16 09       	add	r9,r11
80009b82:	f3 d9 c0 1c 	bfextu	r9,r9,0x0,0x1c

                // Mask out MS 4 bits (its 28bit addressing)
                nextcluster = nextcluster & 0x0FFFFFFF;        
80009b86:	ce 1b       	rjmp	80009b48 <fatfs_find_blank_cluster+0x54>

80009b88 <fatfs_fat_set_cluster>:
80009b88:	d4 21       	pushm	r4-r7,lr
80009b8a:	18 97       	mov	r7,r12
80009b8c:	16 96       	mov	r6,r11
80009b8e:	14 95       	mov	r5,r10
{
    struct fat_buffer *pbuf;
    uint32 fat_sector_offset, position;

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
80009b90:	78 c8       	ld.w	r8,r12[0x30]
80009b92:	58 08       	cp.w	r8,0
80009b94:	c2 b1       	brne	80009bea <fatfs_fat_set_cluster+0x62>
        fat_sector_offset = cluster / 256;
80009b96:	f6 04 16 08 	lsr	r4,r11,0x8
    else
        fat_sector_offset = cluster / 128;

    // Read FAT sector into buffer
    pbuf = fatfs_fat_read_sector(fs, fs->fat_begin_lba+fat_sector_offset);
80009b9a:	6e 5b       	ld.w	r11,r7[0x14]
80009b9c:	0e 9c       	mov	r12,r7
80009b9e:	e8 0b 00 0b 	add	r11,r4,r11
80009ba2:	cb 9e       	rcall	80009914 <fatfs_fat_read_sector>
80009ba4:	c2 20       	breq	80009be8 <fatfs_fat_set_cluster+0x60>
    if (!pbuf)
80009ba6:	6e c8       	ld.w	r8,r7[0x30]
        return 0;

    if (fs->fat_type == FAT_TYPE_16)
80009ba8:	58 08       	cp.w	r8,0
80009baa:	c2 30       	breq	80009bf0 <fatfs_fat_set_cluster+0x68>
80009bac:	f8 f8 02 08 	ld.w	r8,r12[520]
    {
        // Find 32 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 128)) * 4; 

        // Write Next Clusters value to Sector Buffer
        FAT32_SET_32BIT_WORD(pbuf, (uint16)position, next_cluster);     
80009bb0:	ea 09 16 08 	lsr	r9,r5,0x8
80009bb4:	a7 74       	lsl	r4,0x7
80009bb6:	08 16       	sub	r6,r4
80009bb8:	a3 66       	lsl	r6,0x2
80009bba:	5c 76       	castu.h	r6
80009bbc:	f0 06 0b 05 	st.b	r8[r6],r5
80009bc0:	f8 f8 02 08 	ld.w	r8,r12[520]
80009bc4:	0c 08       	add	r8,r6
80009bc6:	b0 99       	st.b	r8[0x1],r9
80009bc8:	ea 09 16 10 	lsr	r9,r5,0x10
80009bcc:	f8 f8 02 08 	ld.w	r8,r12[520]
80009bd0:	0c 08       	add	r8,r6
80009bd2:	b0 a9       	st.b	r8[0x2],r9
80009bd4:	b9 85       	lsr	r5,0x18
80009bd6:	f8 f8 02 08 	ld.w	r8,r12[520]
80009bda:	f0 06 00 06 	add	r6,r8,r6
80009bde:	ac b5       	st.b	r6[0x3],r5
80009be0:	30 18       	mov	r8,1
80009be2:	f9 48 02 04 	st.w	r12[516],r8
80009be6:	10 9c       	mov	r12,r8
80009be8:	d8 22       	popm	r4-r7,pc
    }

    return 1;                     
} 
80009bea:	f6 04 16 07 	lsr	r4,r11,0x7

    // Find which sector of FAT table to read
    if (fs->fat_type == FAT_TYPE_16)
        fat_sector_offset = cluster / 256;
    else
        fat_sector_offset = cluster / 128;
80009bee:	cd 6b       	rjmp	80009b9a <fatfs_fat_set_cluster+0x12>
80009bf0:	f8 f8 02 08 	ld.w	r8,r12[520]
    {
        // Find 16 bit entry of current sector relating to cluster number 
        position = (cluster - (fat_sector_offset * 256)) * 2; 

        // Write Next Clusters value to Sector Buffer
        FAT16_SET_16BIT_WORD(pbuf, (uint16)position, ((uint16)next_cluster));     
80009bf4:	a9 64       	lsl	r4,0x8
80009bf6:	08 16       	sub	r6,r4
80009bf8:	a1 76       	lsl	r6,0x1
80009bfa:	5c 76       	castu.h	r6
80009bfc:	f0 06 0b 05 	st.b	r8[r6],r5
80009c00:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
80009c04:	f8 f8 02 08 	ld.w	r8,r12[520]
80009c08:	f0 06 00 06 	add	r6,r8,r6
80009c0c:	ac 95       	st.b	r6[0x1],r5
80009c0e:	30 18       	mov	r8,1
80009c10:	f9 48 02 04 	st.w	r12[516],r8
80009c14:	10 9c       	mov	r12,r8
80009c16:	d8 22       	popm	r4-r7,pc

80009c18 <fatfs_free_cluster_chain>:
80009c18:	eb cd 40 e0 	pushm	r5-r7,lr
80009c1c:	18 95       	mov	r5,r12
80009c1e:	f6 c8 00 01 	sub	r8,r11,1
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
80009c22:	5b d8       	cp.w	r8,-3
80009c24:	e0 8b 00 10 	brhi	80009c44 <fatfs_free_cluster_chain+0x2c>
80009c28:	16 97       	mov	r7,r11
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
80009c2a:	0e 9b       	mov	r11,r7
80009c2c:	0a 9c       	mov	r12,r5
80009c2e:	cd be       	rcall	800099e4 <fatfs_find_next_cluster>
80009c30:	0e 9b       	mov	r11,r7

        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
80009c32:	18 96       	mov	r6,r12
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
80009c34:	18 97       	mov	r7,r12
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
80009c36:	30 0a       	mov	r10,0

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);

        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
80009c38:	0a 9c       	mov	r12,r5
80009c3a:	20 16       	sub	r6,1
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
80009c3c:	ca 6f       	rcall	80009b88 <fatfs_fat_set_cluster>

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);

        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
80009c3e:	5b d6       	cp.w	r6,-3
80009c40:	fe 98 ff f5 	brls	80009c2a <fatfs_free_cluster_chain+0x12>
{
    uint32 last_cluster;
    uint32 next_cluster = start_cluster;
    
    // Loop until end of chain
    while ( (next_cluster != FAT32_LAST_CLUSTER) && (next_cluster != 0x00000000) )
80009c44:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1

80009c48 <fatfs_fat_add_cluster_to_chain>:
        // Clear last link
        fatfs_fat_set_cluster(fs, last_cluster, 0x00000000);
    }

    return 1;
} 
80009c48:	d4 21       	pushm	r4-r7,lr
80009c4a:	18 96       	mov	r6,r12
80009c4c:	14 95       	mov	r5,r10
80009c4e:	5b fb       	cp.w	r11,-1
80009c50:	c0 b0       	breq	80009c66 <fatfs_fat_add_cluster_to_chain+0x1e>
80009c52:	16 94       	mov	r4,r11
int fatfs_fat_add_cluster_to_chain(struct fatfs *fs, uint32 start_cluster, uint32 newEntry)
{
    uint32 last_cluster = FAT32_LAST_CLUSTER;
    uint32 next_cluster = start_cluster;

    if (start_cluster == FAT32_LAST_CLUSTER)
80009c54:	c0 48       	rjmp	80009c5c <fatfs_fat_add_cluster_to_chain+0x14>
        return 0;
    
    // Loop until end of chain
    while ( next_cluster != FAT32_LAST_CLUSTER )
80009c56:	5b fc       	cp.w	r12,-1
80009c58:	c0 80       	breq	80009c68 <fatfs_fat_add_cluster_to_chain+0x20>
80009c5a:	18 94       	mov	r4,r12
    {
        last_cluster = next_cluster;

        // Find next link
        next_cluster = fatfs_find_next_cluster(fs, next_cluster);
80009c5c:	08 9b       	mov	r11,r4
80009c5e:	0c 9c       	mov	r12,r6
80009c60:	cc 2e       	rcall	800099e4 <fatfs_find_next_cluster>
80009c62:	18 97       	mov	r7,r12
80009c64:	cf 91       	brne	80009c56 <fatfs_fat_add_cluster_to_chain+0xe>
        if (!next_cluster)
80009c66:	d8 2a       	popm	r4-r7,pc,r12=0
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);

    return 1;
80009c68:	08 9b       	mov	r11,r4
        if (!next_cluster)
            return 0;
    }

    // Add link in for new cluster
    fatfs_fat_set_cluster(fs, last_cluster, newEntry);
80009c6a:	0a 9a       	mov	r10,r5
80009c6c:	0c 9c       	mov	r12,r6
80009c6e:	c8 df       	rcall	80009b88 <fatfs_fat_set_cluster>
80009c70:	0e 9a       	mov	r10,r7
80009c72:	0a 9b       	mov	r11,r5

    // Mark new cluster as end of chain
    fatfs_fat_set_cluster(fs, newEntry, FAT32_LAST_CLUSTER);
80009c74:	0c 9c       	mov	r12,r6
80009c76:	c8 9f       	rcall	80009b88 <fatfs_fat_set_cluster>
80009c78:	da 2a       	popm	r4-r7,pc,r12=1
80009c7a:	d7 03       	nop

80009c7c <fatfs_fat_init>:
80009c7c:	eb cd 40 e0 	pushm	r5-r7,lr
80009c80:	3f f8       	mov	r8,-1
80009c82:	18 97       	mov	r7,r12
80009c84:	30 06       	mov	r6,0
80009c86:	f9 48 04 58 	st.w	r12[1112],r8
void fatfs_fat_init(struct fatfs *fs)
{
    int i;

    // FAT buffer chain head
    fs->fat_buffer_head = NULL;
80009c8a:	f9 46 02 54 	st.w	r12[596],r6

    for (i=0;i<FAT_BUFFERS;i++)
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
80009c8e:	f9 46 04 5c 	st.w	r12[1116],r6
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
80009c92:	f8 c5 fd a8 	sub	r5,r12,-600
80009c96:	e0 6a 02 00 	mov	r10,512
80009c9a:	0c 9b       	mov	r11,r6
80009c9c:	0a 9c       	mov	r12,r5
80009c9e:	e0 a0 06 17 	rcall	8000a8cc <memset>
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
80009ca2:	ee f8 02 54 	ld.w	r8,r7[596]
    {
        // Initialise buffers to invalid
        fs->fat_buffers[i].address = FAT32_INVALID_CLUSTER;
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;
80009ca6:	ef 46 04 60 	st.w	r7[1120],r6

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
        fs->fat_buffer_head = &fs->fat_buffers[i];
80009caa:	ef 45 02 54 	st.w	r7[596],r5
        fs->fat_buffers[i].dirty = 0;
        memset(fs->fat_buffers[i].sector, 0x00, sizeof(fs->fat_buffers[i].sector));
        fs->fat_buffers[i].ptr = NULL;

        // Add to head of queue
        fs->fat_buffers[i].next = fs->fat_buffer_head;
80009cae:	ef 48 04 64 	st.w	r7[1124],r8
        fs->fat_buffer_head = &fs->fat_buffers[i];
    }
}
80009cb2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009cb6:	d7 03       	nop

80009cb8 <fatfs_add_file_entry>:
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
{
80009cb8:	d4 31       	pushm	r0-r7,lr
80009cba:	21 5d       	sub	sp,84
80009cbc:	50 1c       	stdsp	sp[0x4],r12
80009cbe:	50 6b       	stdsp	sp[0x18],r11
80009cc0:	50 3a       	stdsp	sp[0xc],r10
80009cc2:	50 79       	stdsp	sp[0x1c],r9
80009cc4:	50 88       	stdsp	sp[0x20],r8
80009cc6:	fa c4 ff 88 	sub	r4,sp,-120
80009cca:	68 19       	ld.w	r9,r4[0x4]
80009ccc:	50 a9       	stdsp	sp[0x28],r9
80009cce:	68 04       	ld.w	r4,r4[0x0]
80009cd0:	50 94       	stdsp	sp[0x24],r4

    uint8 checksum;
    uint8 *pSname;

    // No write access?
    if (!fs->disk_io.write_media)
80009cd2:	78 e8       	ld.w	r8,r12[0x38]
80009cd4:	58 08       	cp.w	r8,0
80009cd6:	c0 60       	breq	80009ce2 <fatfs_add_file_entry+0x2a>
        return 0;

#if FATFS_INC_LFN_SUPPORT
    // How many LFN entries are required?
    // NOTE: We always request one LFN even if it would fit in a SFN!
    entryCount = fatfs_lfn_entries_required(filename);
80009cd8:	14 9c       	mov	r12,r10
80009cda:	fe b0 fb d3 	rcall	80009480 <fatfs_lfn_entries_required>
80009cde:	18 91       	mov	r1,r12
    if (!entryCount)
80009ce0:	c0 31       	brne	80009ce6 <fatfs_add_file_entry+0x2e>
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
80009ce2:	2e bd       	sub	sp,-84
80009ce4:	d8 3a       	popm	r0-r7,pc,r12=0
    entryCount = 0;    
#endif

    // Find space in the directory for this filename (or allocate some more)
    // NOTE: We need to find space for at least the LFN + SFN (or just the SFN if LFNs not supported).
    if (!fatfs_find_free_dir_offset(fs, dirCluster, entryCount + 1, &dirSector, &dirOffset))
80009ce6:	f8 c8 ff ff 	sub	r8,r12,-1
80009cea:	50 28       	stdsp	sp[0x8],r8
    int x=0;
    int possible_spaces = 0;
    int start_recorded = 0;

    // No entries required?
    if (entryCount == 0)
80009cec:	cf b0       	breq	80009ce2 <fatfs_add_file_entry+0x2a>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
80009cee:	30 04       	mov	r4,0
80009cf0:	40 19       	lddsp	r9,sp[0x4]
80009cf2:	08 95       	mov	r5,r4
80009cf4:	2b c9       	sub	r9,-68
80009cf6:	08 96       	mov	r6,r4
80009cf8:	50 59       	stdsp	sp[0x14],r9
80009cfa:	08 97       	mov	r7,r4
80009cfc:	50 44       	stdsp	sp[0x10],r4
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009cfe:	31 03       	mov	r3,16
80009d00:	50 bc       	stdsp	sp[0x2c],r12
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);
80009d02:	40 42       	lddsp	r2,sp[0x10]

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
80009d04:	04 98       	mov	r8,r2
80009d06:	2f f8       	sub	r8,-1
80009d08:	30 09       	mov	r9,0
80009d0a:	50 48       	stdsp	sp[0x10],r8
80009d0c:	04 9a       	mov	r10,r2
80009d0e:	40 6b       	lddsp	r11,sp[0x18]
80009d10:	40 1c       	lddsp	r12,sp[0x4]
80009d12:	fe b0 f1 11 	rcall	80007f34 <fatfs_sector_reader>
80009d16:	e0 80 00 b6 	breq	80009e82 <fatfs_add_file_entry+0x1ca>
80009d1a:	40 58       	lddsp	r8,sp[0x14]
80009d1c:	50 02       	stdsp	sp[0x0],r2
80009d1e:	0c 91       	mov	r1,r6
80009d20:	30 00       	mov	r0,0
80009d22:	10 92       	mov	r2,r8
80009d24:	10 96       	mov	r6,r8
80009d26:	c1 18       	rjmp	80009d48 <fatfs_add_file_entry+0x90>

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
                {
                    // First entry?
                    if (possible_spaces == 0)
80009d28:	58 07       	cp.w	r7,0
80009d2a:	e0 04 17 00 	moveq	r4,r0
80009d2e:	40 09       	lddsp	r9,sp[0x0]
80009d30:	f9 b1 00 01 	moveq	r1,1
80009d34:	f2 05 17 00 	moveq	r5,r9
                        start_recorded = 1;
                    }

                    // Increment the count in-case the file turns 
                    // out to be deleted...
                    possible_spaces++;
80009d38:	2f f7       	sub	r7,-1
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009d3a:	2f f0       	sub	r0,-1
80009d3c:	2e 02       	sub	r2,-32
80009d3e:	5c 50       	castu.b	r0
80009d40:	2e 06       	sub	r6,-32
80009d42:	e6 00 18 00 	cp.b	r0,r3
80009d46:	c1 50       	breq	80009d70 <fatfs_add_file_entry+0xb8>

                // Overlay directory entry over buffer
                directoryEntry = (struct fat_dir_entry*)(fs->currentsector.sector+recordoffset);

                // LFN Entry
                if (fatfs_entry_lfn_text(directoryEntry))
80009d48:	04 9c       	mov	r12,r2
80009d4a:	fe b0 f9 db 	rcall	80009100 <fatfs_entry_lfn_text>
80009d4e:	ce d1       	brne	80009d28 <fatfs_add_file_entry+0x70>
                }
                // SFN Entry
                else 
                {
                    // Has file been deleted?
                    if (fs->currentsector.sector[recordoffset] == FILE_HEADER_DELETED)
80009d50:	0d 88       	ld.ub	r8,r6[0x0]
80009d52:	3e 59       	mov	r9,-27
80009d54:	f2 08 18 00 	cp.b	r8,r9
80009d58:	c0 e0       	breq	80009d74 <fatfs_add_file_entry+0xbc>
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
80009d5a:	58 08       	cp.w	r8,0
80009d5c:	c0 c0       	breq	80009d74 <fatfs_add_file_entry+0xbc>
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009d5e:	2f f0       	sub	r0,-1
                            return 1;

                        // Else continue counting until we find a valid entry!
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
80009d60:	18 91       	mov	r1,r12
80009d62:	18 97       	mov	r7,r12
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009d64:	2e 02       	sub	r2,-32
80009d66:	5c 50       	castu.b	r0
80009d68:	2e 06       	sub	r6,-32
80009d6a:	e6 00 18 00 	cp.b	r0,r3
80009d6e:	ce d1       	brne	80009d48 <fatfs_add_file_entry+0x90>
80009d70:	02 96       	mov	r6,r1
80009d72:	cc 8b       	rjmp	80009d02 <fatfs_add_file_entry+0x4a>
                    }
                    // Is the file entry empty?
                    else if (fs->currentsector.sector[recordoffset] == FILE_HEADER_BLANK)
                    {
                        // First entry?
                        if (possible_spaces == 0)
80009d74:	58 07       	cp.w	r7,0
80009d76:	e0 04 17 00 	moveq	r4,r0
80009d7a:	40 08       	lddsp	r8,sp[0x0]
80009d7c:	f9 b1 00 01 	moveq	r1,1
80009d80:	f0 05 17 00 	moveq	r5,r8

                        // Increment the blank entries count
                        possible_spaces++;

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
80009d84:	40 29       	lddsp	r9,sp[0x8]
                            *pOffset = item;
                            start_recorded = 1;
                        }

                        // Increment the blank entries count
                        possible_spaces++;
80009d86:	2f f7       	sub	r7,-1

                        // We have found enough space?
                        if (possible_spaces >= entryCount)
80009d88:	0e 39       	cp.w	r9,r7
80009d8a:	fe 99 ff d8 	brgt	80009d3a <fatfs_add_file_entry+0x82>
80009d8e:	40 b1       	lddsp	r1,sp[0x2c]
    return 0;
}
//-----------------------------------------------------------------------------
// fatfs_add_file_entry: Add a directory entry to a location found by FindFreeOffset
//-----------------------------------------------------------------------------
int fatfs_add_file_entry(struct fatfs *fs, uint32 dirCluster, char *filename, char *shortfilename, uint32 startCluster, uint32 size, int dir)
80009d90:	30 03       	mov	r3,0
80009d92:	40 7a       	lddsp	r10,sp[0x1c]
80009d94:	40 78       	lddsp	r8,sp[0x1c]
80009d96:	2f 5a       	sub	r10,-11
80009d98:	06 99       	mov	r9,r3
        return 0;

    // Generate checksum of short filename
    pSname = (uint8*)shortfilename;
    checksum = 0;
    for (i=11; i!=0; i--) checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *pSname++;
80009d9a:	e0 6b 00 80 	mov	r11,128
80009d9e:	c0 58       	rjmp	80009da8 <fatfs_add_file_entry+0xf0>
80009da0:	f3 d3 c0 01 	bfextu	r9,r3,0x0,0x1
80009da4:	f6 09 17 10 	movne	r9,r11
80009da8:	e6 0c 16 01 	lsr	r12,r3,0x1
80009dac:	11 37       	ld.ub	r7,r8++
80009dae:	12 07       	add	r7,r9
80009db0:	ee 0c 00 0c 	add	r12,r7,r12
80009db4:	e7 dc c0 08 	bfextu	r3,r12,0x0,0x8
80009db8:	14 38       	cp.w	r8,r10
80009dba:	cf 31       	brne	80009da0 <fatfs_add_file_entry+0xe8>
80009dbc:	50 04       	stdsp	sp[0x0],r4
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
80009dbe:	30 00       	mov	r0,0
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009dc0:	31 02       	mov	r2,16
80009dc2:	0a 94       	mov	r4,r5

    // Main cluster following loop
    while (1)
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
80009dc4:	30 09       	mov	r9,0
80009dc6:	0a 9a       	mov	r10,r5
80009dc8:	40 6b       	lddsp	r11,sp[0x18]
80009dca:	40 1c       	lddsp	r12,sp[0x4]
80009dcc:	fe b0 f0 b4 	rcall	80007f34 <fatfs_sector_reader>
80009dd0:	c8 90       	breq	80009ce2 <fatfs_add_file_entry+0x2a>
80009dd2:	30 07       	mov	r7,0
80009dd4:	0e 98       	mov	r8,r7
80009dd6:	0e 96       	mov	r6,r7
80009dd8:	c0 98       	rjmp	80009dea <fatfs_add_file_entry+0x132>
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
80009dda:	08 35       	cp.w	r5,r4
80009ddc:	c2 30       	breq	80009e22 <fatfs_add_file_entry+0x16a>
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009dde:	2f f6       	sub	r6,-1
80009de0:	2e 07       	sub	r7,-32
80009de2:	5c 56       	castu.b	r6
80009de4:	e4 06 18 00 	cp.b	r6,r2
80009de8:	c1 90       	breq	80009e1a <fatfs_add_file_entry+0x162>
            {
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
80009dea:	58 00       	cp.w	r0,0
80009dec:	cf 70       	breq	80009dda <fatfs_add_file_entry+0x122>
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
80009dee:	0e 98       	mov	r8,r7
80009df0:	5c 88       	casts.h	r8
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
80009df2:	58 01       	cp.w	r1,0
80009df4:	c2 00       	breq	80009e34 <fatfs_add_file_entry+0x17c>
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
80009df6:	40 18       	lddsp	r8,sp[0x4]
80009df8:	ee cb ff bc 	sub	r11,r7,-68
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
                    }
#if FATFS_INC_LFN_SUPPORT
                    else
                    {
                        entryCount--;
80009dfc:	20 11       	sub	r1,1

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
80009dfe:	f0 0b 00 0b 	add	r11,r8,r11
80009e02:	06 99       	mov	r9,r3
80009e04:	02 9a       	mov	r10,r1
80009e06:	40 3c       	lddsp	r12,sp[0xc]
80009e08:	fe b0 fb 4e 	rcall	800094a4 <fatfs_filename_to_lfn>
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009e0c:	2f f6       	sub	r6,-1
                    else
                    {
                        entryCount--;

                        // Copy entry to directory buffer
                        fatfs_filename_to_lfn(filename, &fs->currentsector.sector[recordoffset], entryCount, checksum); 
80009e0e:	30 18       	mov	r8,1
    {
        // Read sector
        if (fatfs_sector_reader(fs, dirCluster, x++, 0)) 
        {
            // Analyse Sector
            for (item = 0; item < FAT_DIR_ENTRIES_PER_SECTOR; item++)
80009e10:	2e 07       	sub	r7,-32
80009e12:	5c 56       	castu.b	r6
80009e14:	e4 06 18 00 	cp.b	r6,r2
80009e18:	ce 91       	brne	80009dea <fatfs_add_file_entry+0x132>
#endif
                }
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
80009e1a:	58 08       	cp.w	r8,0
80009e1c:	c2 81       	brne	80009e6c <fatfs_add_file_entry+0x1b4>
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
80009e1e:	2f f5       	sub	r5,-1
80009e20:	cd 2b       	rjmp	80009dc4 <fatfs_add_file_entry+0x10c>
                // Create the multiplier for sector access
                recordoffset = FAT_DIR_ENTRY_SIZE * item;

                // If the start position for the entry has been found
                if (foundEnd==0)
                    if ( (dirSector==(x-1)) && (dirOffset==item) )
80009e22:	40 09       	lddsp	r9,sp[0x0]
80009e24:	f2 06 18 00 	cp.b	r6,r9
80009e28:	cd b1       	brne	80009dde <fatfs_add_file_entry+0x126>
80009e2a:	0e 98       	mov	r8,r7
80009e2c:	30 10       	mov	r0,1
80009e2e:	5c 88       	casts.h	r8
                        foundEnd = 1;

                // Start adding filename
                if (foundEnd)
                {                
                    if (entryCount==0)
80009e30:	58 01       	cp.w	r1,0
80009e32:	ce 21       	brne	80009df6 <fatfs_add_file_entry+0x13e>
                    {
                        // Short filename
                        fatfs_sfn_create_entry(shortfilename, size, startCluster, &shortEntry, dir);
80009e34:	fa c7 ff d0 	sub	r7,sp,-48
80009e38:	10 96       	mov	r6,r8
80009e3a:	0e 99       	mov	r9,r7
80009e3c:	40 a8       	lddsp	r8,sp[0x28]
80009e3e:	40 8a       	lddsp	r10,sp[0x20]
80009e40:	40 9b       	lddsp	r11,sp[0x24]
80009e42:	40 7c       	lddsp	r12,sp[0x1c]
80009e44:	fe b0 f9 b9 	rcall	800091b6 <fatfs_sfn_create_entry>
                        memcpy(&fs->currentsector.sector[recordoffset], &shortEntry, sizeof(shortEntry));
80009e48:	40 58       	lddsp	r8,sp[0x14]
80009e4a:	0e 9b       	mov	r11,r7
80009e4c:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
80009e50:	32 0a       	mov	r10,32
80009e52:	f0 0c 00 0c 	add	r12,r8,r12
80009e56:	e0 a0 04 97 	rcall	8000a784 <memcpy>

                        // Writeback
                        return fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1);
80009e5a:	40 19       	lddsp	r9,sp[0x4]
80009e5c:	40 5b       	lddsp	r11,sp[0x14]
80009e5e:	f2 fc 02 44 	ld.w	r12,r9[580]
80009e62:	72 e8       	ld.w	r8,r9[0x38]
80009e64:	30 1a       	mov	r10,1
80009e66:	5d 18       	icall	r8
        else
            return 0;
    } // End of while loop

    return 0;
}
80009e68:	2e bd       	sub	sp,-84
80009e6a:	d8 32       	popm	r0-r7,pc
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
80009e6c:	40 19       	lddsp	r9,sp[0x4]
80009e6e:	30 1a       	mov	r10,1
80009e70:	72 e8       	ld.w	r8,r9[0x38]
80009e72:	40 5b       	lddsp	r11,sp[0x14]
80009e74:	f2 fc 02 44 	ld.w	r12,r9[580]
80009e78:	5d 18       	icall	r8
80009e7a:	fe 90 ff 34 	breq	80009ce2 <fatfs_add_file_entry+0x2a>
80009e7e:	2f f5       	sub	r5,-1
80009e80:	ca 2b       	rjmp	80009dc4 <fatfs_add_file_entry+0x10c>
        else
        {
            uint32 newCluster;

            // Get a new cluster for directory
            if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &newCluster))
80009e82:	40 18       	lddsp	r8,sp[0x4]
80009e84:	18 90       	mov	r0,r12
80009e86:	40 b1       	lddsp	r1,sp[0x2c]
80009e88:	fa ca ff b0 	sub	r10,sp,-80
80009e8c:	70 2b       	ld.w	r11,r8[0x8]
80009e8e:	10 9c       	mov	r12,r8
80009e90:	c3 2e       	rcall	80009af4 <fatfs_find_blank_cluster>
80009e92:	fe 90 ff 28 	breq	80009ce2 <fatfs_add_file_entry+0x2a>
80009e96:	41 4a       	lddsp	r10,sp[0x50]
                return 0;

            // Add cluster to end of directory tree
            if (!fatfs_fat_add_cluster_to_chain(fs, dirCluster, newCluster))
80009e98:	40 6b       	lddsp	r11,sp[0x18]
80009e9a:	40 1c       	lddsp	r12,sp[0x4]
80009e9c:	cd 6e       	rcall	80009c48 <fatfs_fat_add_cluster_to_chain>
80009e9e:	fe 90 ff 22 	breq	80009ce2 <fatfs_add_file_entry+0x2a>
80009ea2:	e0 6a 02 00 	mov	r10,512
                return 0;

            // Erase new directory cluster
            memset(fs->currentsector.sector, 0x00, FAT_SECTOR_SIZE);
80009ea6:	00 9b       	mov	r11,r0
80009ea8:	40 5c       	lddsp	r12,sp[0x14]
80009eaa:	e0 a0 05 11 	rcall	8000a8cc <memset>
80009eae:	40 18       	lddsp	r8,sp[0x4]
80009eb0:	11 89       	ld.ub	r9,r8[0x0]
            for (i=0;i<fs->sectors_per_cluster;i++)
80009eb2:	e0 09 18 00 	cp.b	r9,r0
80009eb6:	c1 20       	breq	80009eda <fatfs_add_file_entry+0x222>
80009eb8:	40 17       	lddsp	r7,sp[0x4]
80009eba:	c0 88       	rjmp	80009eca <fatfs_add_file_entry+0x212>
80009ebc:	2f f0       	sub	r0,-1
80009ebe:	0f 88       	ld.ub	r8,r7[0x0]
80009ec0:	5c 50       	castu.b	r0
80009ec2:	e0 08 18 00 	cp.b	r8,r0
80009ec6:	e0 88 00 0a 	brls	80009eda <fatfs_add_file_entry+0x222>
80009eca:	00 9a       	mov	r10,r0
80009ecc:	30 09       	mov	r9,0
            {
                if (!fatfs_write_sector(fs, newCluster, i, 0))
80009ece:	41 4b       	lddsp	r11,sp[0x50]
80009ed0:	0e 9c       	mov	r12,r7
80009ed2:	fe b0 ef f3 	rcall	80007eb8 <fatfs_write_sector>
80009ed6:	cf 31       	brne	80009ebc <fatfs_add_file_entry+0x204>
80009ed8:	c0 5b       	rjmp	80009ce2 <fatfs_add_file_entry+0x2a>
80009eda:	58 06       	cp.w	r6,0
80009edc:	e4 05 17 00 	moveq	r5,r2
            } // End of if

            // Write back to disk before loading another sector
            if (dirtySector)
            {
                if (!fs->disk_io.write_media(fs->currentsector.address, fs->currentsector.sector, 1))
80009ee0:	ec 04 17 00 	moveq	r4,r6
80009ee4:	c5 6b       	rjmp	80009d90 <fatfs_add_file_entry+0xd8>
80009ee6:	d7 03       	nop

80009ee8 <fatfs_add_free_space>:
80009ee8:	eb cd 40 fc 	pushm	r2-r7,lr
80009eec:	20 1d       	sub	sp,4
80009eee:	16 92       	mov	r2,r11
80009ef0:	14 94       	mov	r4,r10
80009ef2:	18 97       	mov	r7,r12
80009ef4:	76 05       	ld.w	r5,r11[0x0]
80009ef6:	78 98       	ld.w	r8,r12[0x24]
80009ef8:	5b f8       	cp.w	r8,-1
80009efa:	c0 40       	breq	80009f02 <fatfs_add_free_space+0x1a>
80009efc:	3f fb       	mov	r11,-1
80009efe:	fe b0 fd c1 	rcall	80009a80 <fatfs_set_fs_info_next_free_cluster>
80009f02:	58 04       	cp.w	r4,0
80009f04:	c2 00       	breq	80009f44 <fatfs_add_free_space+0x5c>
80009f06:	30 06       	mov	r6,0
80009f08:	1a 93       	mov	r3,sp
80009f0a:	c0 f8       	rjmp	80009f28 <fatfs_add_free_space+0x40>
80009f0c:	40 0a       	lddsp	r10,sp[0x0]
80009f0e:	c3 de       	rcall	80009b88 <fatfs_fat_set_cluster>
80009f10:	3f fa       	mov	r10,-1
80009f12:	40 0b       	lddsp	r11,sp[0x0]
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
            
            // Point this to end of file
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
80009f14:	0e 9c       	mov	r12,r7
80009f16:	c3 9e       	rcall	80009b88 <fatfs_fat_set_cluster>
80009f18:	40 05       	lddsp	r5,sp[0x0]
80009f1a:	58 06       	cp.w	r6,0

            // Adjust argument reference
            start = nextcluster;
80009f1c:	e5 f5 0a 00 	st.weq	r2[0x0],r5
            if (i == 0)
                *startCluster = nextcluster;
80009f20:	2f f6       	sub	r6,-1
80009f22:	0c 34       	cp.w	r4,r6

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
80009f24:	e0 88 00 10 	brls	80009f44 <fatfs_add_free_space+0x5c>
80009f28:	6e 2b       	ld.w	r11,r7[0x8]
80009f2a:	1a 9a       	mov	r10,sp
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
80009f2c:	0e 9c       	mov	r12,r7
80009f2e:	fe b0 fd e3 	rcall	80009af4 <fatfs_find_blank_cluster>
80009f32:	0a 9b       	mov	r11,r5
80009f34:	18 98       	mov	r8,r12
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
80009f36:	0e 9c       	mov	r12,r7
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
80009f38:	58 08       	cp.w	r8,0
        {
            // Point last to this
            fatfs_fat_set_cluster(fs, start, nextcluster);
80009f3a:	ce 91       	brne	80009f0c <fatfs_add_free_space+0x24>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
    {
        // Start looking for free clusters from the beginning
        if (fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
80009f3c:	10 9c       	mov	r12,r8
80009f3e:	2f fd       	sub	sp,-4
80009f40:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
        else
            return 0;
    }

    return 1;
}
80009f44:	2f fd       	sub	sp,-4
80009f46:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 

    for (i=0;i<clusters;i++)
80009f4a:	d7 03       	nop

80009f4c <fatfs_allocate_free_space>:
80009f4c:	d4 21       	pushm	r4-r7,lr
80009f4e:	20 2d       	sub	sp,8
80009f50:	16 97       	mov	r7,r11
80009f52:	14 96       	mov	r6,r10
80009f54:	18 95       	mov	r5,r12
80009f56:	58 09       	cp.w	r9,0
80009f58:	c2 00       	breq	80009f98 <fatfs_allocate_free_space+0x4c>
80009f5a:	78 98       	ld.w	r8,r12[0x24]

    if (size==0)
        return 0;

    // Set the next free cluster hint to unknown
    if (fs->next_free_cluster != FAT32_LAST_CLUSTER)
80009f5c:	5b f8       	cp.w	r8,-1
80009f5e:	c0 60       	breq	80009f6a <fatfs_allocate_free_space+0x1e>
        fatfs_set_fs_info_next_free_cluster(fs, FAT32_LAST_CLUSTER); 
80009f60:	50 09       	stdsp	sp[0x0],r9
80009f62:	3f fb       	mov	r11,-1
80009f64:	fe b0 fd 8e 	rcall	80009a80 <fatfs_set_fs_info_next_free_cluster>
80009f68:	40 09       	lddsp	r9,sp[0x0]

    // Work out size and clusters
    clusterSize = fs->sectors_per_cluster * FAT_SECTOR_SIZE;
80009f6a:	0b 88       	ld.ub	r8,r5[0x0]
80009f6c:	a9 78       	lsl	r8,0x9
    clusterCount = (size / clusterSize);
80009f6e:	f2 08 0d 0a 	divu	r10,r9,r8
80009f72:	14 94       	mov	r4,r10

    // If any left over
    if (size-(clusterSize*clusterCount))
80009f74:	f4 08 02 48 	mul	r8,r10,r8
        clusterCount++;
80009f78:	12 38       	cp.w	r8,r9
80009f7a:	f7 b4 01 ff 	subne	r4,-1

    // Allocated first link in the chain if a new file
    if (newFile)
80009f7e:	58 07       	cp.w	r7,0
80009f80:	c0 e1       	brne	80009f9c <fatfs_allocate_free_space+0x50>
            return 1;
        }
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;
80009f82:	6c 08       	ld.w	r8,r6[0x0]
80009f84:	fa c7 ff f8 	sub	r7,sp,-8
80009f88:	0e d8       	st.w	--r7,r8

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
80009f8a:	08 9a       	mov	r10,r4
80009f8c:	0e 9b       	mov	r11,r7
80009f8e:	0a 9c       	mov	r12,r5
80009f90:	ca cf       	rcall	80009ee8 <fatfs_add_free_space>
80009f92:	5f 1c       	srne	r12
80009f94:	2f ed       	sub	sp,-8
            return 0;

    return 1;
}
80009f96:	d8 22       	popm	r4-r7,pc
80009f98:	2f ed       	sub	sp,-8
    }
    // Allocate from end of current chain (startCluster is end of chain)
    else
        nextcluster = *startCluster;

    if (!fatfs_add_free_space(fs, &nextcluster, clusterCount))
80009f9a:	d8 2a       	popm	r4-r7,pc,r12=0
80009f9c:	fa c7 ff fc 	sub	r7,sp,-4
        clusterCount++;

    // Allocated first link in the chain if a new file
    if (newFile)
    {
        if (!fatfs_find_blank_cluster(fs, fs->rootdir_first_cluster, &nextcluster))
80009fa0:	6a 2b       	ld.w	r11,r5[0x8]
80009fa2:	0e 9a       	mov	r10,r7
80009fa4:	0a 9c       	mov	r12,r5
80009fa6:	fe b0 fd a7 	rcall	80009af4 <fatfs_find_blank_cluster>
80009faa:	cf 70       	breq	80009f98 <fatfs_allocate_free_space+0x4c>
80009fac:	58 14       	cp.w	r4,1
            return 0;

        // If this is all that is needed then all done
        if (clusterCount==1)
80009fae:	ce e1       	brne	80009f8a <fatfs_allocate_free_space+0x3e>
80009fb0:	0a 9c       	mov	r12,r5
        {
            fatfs_fat_set_cluster(fs, nextcluster, FAT32_LAST_CLUSTER);
80009fb2:	3f fa       	mov	r10,-1
80009fb4:	40 1b       	lddsp	r11,sp[0x4]
80009fb6:	fe b0 fd e9 	rcall	80009b88 <fatfs_fat_set_cluster>
80009fba:	40 18       	lddsp	r8,sp[0x4]
            *startCluster = nextcluster;
80009fbc:	08 9c       	mov	r12,r4
80009fbe:	8d 08       	st.w	r6[0x0],r8
80009fc0:	ce ab       	rjmp	80009f94 <fatfs_allocate_free_space+0x48>
            return 1;
80009fc2:	d7 03       	nop

80009fc4 <files_search_dsp>:
    n++;
    dst++;
  }
}

u8 files_search_dsp(void) {
80009fc4:	eb cd 40 f8 	pushm	r3-r7,lr
  void* fp;
  //  FL_DIR dirstat;
  u32 size;
  // open file pointer
  print_dbg("\r\n opening dsp file at path: ");
80009fc8:	fe cc d7 b0 	sub	r12,pc,-10320
80009fcc:	fe b0 c6 f6 	rcall	80002db8 <print_dbg>
  print_dbg(LPPR_LDR_PATH);
80009fd0:	fe cc d7 98 	sub	r12,pc,-10344

  // we don't want to be handling UI interrupts while working with the filesystem
  app_pause();
80009fd4:	fe b0 c6 f2 	rcall	80002db8 <print_dbg>

  fp = fl_fopen(LPPR_LDR_PATH, "r");
80009fd8:	fe b0 da bc 	rcall	80005550 <app_pause>
80009fdc:	fe cb db 0c 	sub	r11,pc,-9460
80009fe0:	fe cc d7 a8 	sub	r12,pc,-10328
  if( fp != NULL) {
    size = ((FL_FILE*)(fp))->filelength;
80009fe4:	fe b0 f6 b2 	rcall	80008d48 <fl_fopen>
    print_dbg("\r\n opened .ldr file, size: ");
80009fe8:	18 95       	mov	r5,r12
80009fea:	c3 80       	breq	8000a05a <files_search_dsp+0x96>
    print_dbg_ulong(size);
80009fec:	78 34       	ld.w	r4,r12[0xc]
80009fee:	fe cc d7 a2 	sub	r12,pc,-10334
    print_dbg(" ; pointer: ");
80009ff2:	fe b0 c6 e3 	rcall	80002db8 <print_dbg>
80009ff6:	08 9c       	mov	r12,r4
    print_dbg_hex((u32)fp);
80009ff8:	fe b0 c6 da 	rcall	80002dac <print_dbg_ulong>
80009ffc:	fe cc d7 94 	sub	r12,pc,-10348
    //    render_status("loading sdcard -> RAM...     ");
    //    render_update();

    // read .ldr data to RAM buffer
    //    fl_fread((void*)bfinLdrData, 1, size, fp);
    print_dbg("\r\n reading .ldr to RAM");
8000a000:	fe b0 c6 dc 	rcall	80002db8 <print_dbg>
    fake_fread((void*)bfinLdrData, size, fp);
8000a004:	0a 9c       	mov	r12,r5
8000a006:	fe b0 c6 ab 	rcall	80002d5c <print_dbg_hex>

// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
8000a00a:	fe cc d7 92 	sub	r12,pc,-10350
    n++;
    dst++;
  }
}

u8 files_search_dsp(void) {
8000a00e:	fe b0 c6 d5 	rcall	80002db8 <print_dbg>
// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
    *dst = fl_fgetc(fp);
8000a012:	e0 68 30 b4 	mov	r8,12468
8000a016:	70 03       	ld.w	r3,r8[0x0]
8000a018:	58 04       	cp.w	r4,0
    /* print_dbg_ulong(n); */
    /* print_dbg(","); */
    /* print_dbg_hex( ((u32)dst) & 0xff ); */
    /* print_dbg(" \r\n"); */
    n++;
8000a01a:	c0 c0       	breq	8000a032 <files_search_dsp+0x6e>

// fread: no size arg
static void fake_fread(volatile u8* dst, u32 size, void* fp) {
  u32 n = 0;
  //  print_dbg("\r\n\r\n read: \r\n");
  while(n < size) {
8000a01c:	30 07       	mov	r7,0
8000a01e:	e6 07 00 06 	add	r6,r3,r7
    // read .ldr data to RAM buffer
    //    fl_fread((void*)bfinLdrData, 1, size, fp);
    print_dbg("\r\n reading .ldr to RAM");
    fake_fread((void*)bfinLdrData, size, fp);

    fl_fclose(fp);
8000a022:	0a 9c       	mov	r12,r5
8000a024:	fe b0 f5 b6 	rcall	80008b90 <fl_fgetc>

    print_dbg("\r\n finished reading .ldr file to RAM");
8000a028:	ac 8c       	st.b	r6[0x0],r12
8000a02a:	2f f7       	sub	r7,-1
8000a02c:	0e 34       	cp.w	r4,r7

    // write buf to flash
    //    flash_write_ldr();
    //    print_dbg("\r\n finished writing .ldr file to flash");
    // reboot the DSP from RAM
    print_dbg("\r\n booting DSP from RAM");
8000a02e:	fe 9b ff f8 	brhi	8000a01e <files_search_dsp+0x5a>
    fake_fread((void*)bfinLdrData, size, fp);

    fl_fclose(fp);

    print_dbg("\r\n finished reading .ldr file to RAM");
    bfinLdrSize = size;
8000a032:	0a 9c       	mov	r12,r5

    // write buf to flash
    //    flash_write_ldr();
    //    print_dbg("\r\n finished writing .ldr file to flash");
    // reboot the DSP from RAM
    print_dbg("\r\n booting DSP from RAM");
8000a034:	fe b0 f5 be 	rcall	80008bb0 <fl_fclose>


    //    render_status("booting DSP from RAM...     ");
    //    render_update();

    bfin_load_buf();
8000a038:	fe cc d7 a8 	sub	r12,pc,-10328
    app_resume();
8000a03c:	fe b0 c6 be 	rcall	80002db8 <print_dbg>
8000a040:	fe cc d7 88 	sub	r12,pc,-10360

    return 1; // ok
  } else {
    print_dbg("\r\n encountered an error opening .ldr file.");
8000a044:	e0 68 0b 94 	mov	r8,2964
8000a048:	91 04       	st.w	r8[0x0],r4

    app_resume();
8000a04a:	fe b0 c6 b7 	rcall	80002db8 <print_dbg>
8000a04e:	fe b0 db b3 	rcall	800057b4 <bfin_load_buf>
    return 0; // error opening
  }
}
8000a052:	fe b0 da 7b 	rcall	80005548 <app_resume>
8000a056:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
8000a05a:	fe cc d7 8a 	sub	r12,pc,-10358
8000a05e:	fe b0 c6 ad 	rcall	80002db8 <print_dbg>
8000a062:	fe b0 da 73 	rcall	80005548 <app_resume>
8000a066:	0a 9c       	mov	r12,r5
8000a068:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

8000a06c <_stext>:
8000a06c:	e0 7d 00 00 	mov	sp,65536
8000a070:	fe c0 f4 70 	sub	r0,pc,-2960
8000a074:	e3 b0 00 01 	mtsr	0x4,r0
8000a078:	d5 53       	csrf	0x15
8000a07a:	30 80       	mov	r0,8
8000a07c:	e0 61 05 30 	mov	r1,1328
8000a080:	02 30       	cp.w	r0,r1
8000a082:	c0 72       	brcc	8000a090 <idata_load_loop_end>
8000a084:	fe c2 d7 24 	sub	r2,pc,-10460

8000a088 <idata_load_loop>:
8000a088:	a5 05       	ld.d	r4,r2++
8000a08a:	a1 24       	st.d	r0++,r4
8000a08c:	02 30       	cp.w	r0,r1
8000a08e:	cf d3       	brcs	8000a088 <idata_load_loop>

8000a090 <idata_load_loop_end>:
8000a090:	e0 60 05 30 	mov	r0,1328
8000a094:	e0 61 32 90 	mov	r1,12944
8000a098:	02 30       	cp.w	r0,r1
8000a09a:	c0 62       	brcc	8000a0a6 <udata_clear_loop_end>
8000a09c:	30 02       	mov	r2,0
8000a09e:	30 03       	mov	r3,0

8000a0a0 <udata_clear_loop>:
8000a0a0:	a1 22       	st.d	r0++,r2
8000a0a2:	02 30       	cp.w	r0,r1
8000a0a4:	cf e3       	brcs	8000a0a0 <udata_clear_loop>

8000a0a6 <udata_clear_loop_end>:
8000a0a6:	fe cf 30 26 	sub	pc,pc,12326
8000a0aa:	d7 03       	nop

8000a0ac <__avr32_udiv64>:
8000a0ac:	d4 31       	pushm	r0-r7,lr
8000a0ae:	1a 97       	mov	r7,sp
8000a0b0:	20 2d       	sub	sp,8
8000a0b2:	10 9e       	mov	lr,r8
8000a0b4:	12 95       	mov	r5,r9
8000a0b6:	14 96       	mov	r6,r10
8000a0b8:	58 09       	cp.w	r9,0
8000a0ba:	c4 91       	brne	8000a14c <__avr32_udiv64+0xa0>
8000a0bc:	16 38       	cp.w	r8,r11
8000a0be:	e0 88 00 57 	brls	8000a16c <__avr32_udiv64+0xc0>
8000a0c2:	f0 08 12 00 	clz	r8,r8
8000a0c6:	c0 d0       	breq	8000a0e0 <__avr32_udiv64+0x34>
8000a0c8:	f6 08 09 4b 	lsl	r11,r11,r8
8000a0cc:	f0 09 11 20 	rsub	r9,r8,32
8000a0d0:	fc 08 09 4e 	lsl	lr,lr,r8
8000a0d4:	f4 09 0a 49 	lsr	r9,r10,r9
8000a0d8:	f4 08 09 46 	lsl	r6,r10,r8
8000a0dc:	f3 eb 10 0b 	or	r11,r9,r11
8000a0e0:	fc 05 16 10 	lsr	r5,lr,0x10
8000a0e4:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
8000a0e8:	f6 05 0d 0a 	divu	r10,r11,r5
8000a0ec:	ec 08 16 10 	lsr	r8,r6,0x10
8000a0f0:	14 99       	mov	r9,r10
8000a0f2:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000a0f6:	b9 3a       	mul	r10,r12
8000a0f8:	10 3a       	cp.w	r10,r8
8000a0fa:	e0 88 00 0c 	brls	8000a112 <__avr32_udiv64+0x66>
8000a0fe:	20 19       	sub	r9,1
8000a100:	1c 08       	add	r8,lr
8000a102:	10 3e       	cp.w	lr,r8
8000a104:	e0 8b 00 07 	brhi	8000a112 <__avr32_udiv64+0x66>
8000a108:	10 3a       	cp.w	r10,r8
8000a10a:	f7 b9 0b 01 	subhi	r9,1
8000a10e:	f1 de eb 08 	addhi	r8,r8,lr
8000a112:	f0 0a 01 0b 	sub	r11,r8,r10
8000a116:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000a11a:	f6 05 0d 0a 	divu	r10,r11,r5
8000a11e:	ed eb 11 06 	or	r6,r6,r11<<0x10
8000a122:	14 98       	mov	r8,r10
8000a124:	f4 0c 02 4c 	mul	r12,r10,r12
8000a128:	0c 3c       	cp.w	r12,r6
8000a12a:	e0 88 00 0a 	brls	8000a13e <__avr32_udiv64+0x92>
8000a12e:	20 18       	sub	r8,1
8000a130:	1c 06       	add	r6,lr
8000a132:	0c 3e       	cp.w	lr,r6
8000a134:	e0 8b 00 05 	brhi	8000a13e <__avr32_udiv64+0x92>
8000a138:	0c 3c       	cp.w	r12,r6
8000a13a:	f7 b8 0b 01 	subhi	r8,1
8000a13e:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
8000a142:	30 0c       	mov	r12,0
8000a144:	16 9a       	mov	r10,r11
8000a146:	18 9b       	mov	r11,r12
8000a148:	2f ed       	sub	sp,-8
8000a14a:	d8 32       	popm	r0-r7,pc
8000a14c:	16 39       	cp.w	r9,r11
8000a14e:	e0 8b 00 51 	brhi	8000a1f0 <__avr32_udiv64+0x144>
8000a152:	f2 0c 12 00 	clz	r12,r9
8000a156:	c5 31       	brne	8000a1fc <__avr32_udiv64+0x150>
8000a158:	14 38       	cp.w	r8,r10
8000a15a:	5f 89       	srls	r9
8000a15c:	16 35       	cp.w	r5,r11
8000a15e:	5f 38       	srlo	r8
8000a160:	10 49       	or	r9,r8
8000a162:	f8 09 18 00 	cp.b	r9,r12
8000a166:	c4 50       	breq	8000a1f0 <__avr32_udiv64+0x144>
8000a168:	30 1b       	mov	r11,1
8000a16a:	c4 58       	rjmp	8000a1f4 <__avr32_udiv64+0x148>
8000a16c:	58 08       	cp.w	r8,0
8000a16e:	c0 51       	brne	8000a178 <__avr32_udiv64+0xcc>
8000a170:	30 19       	mov	r9,1
8000a172:	f2 08 0d 08 	divu	r8,r9,r8
8000a176:	10 9e       	mov	lr,r8
8000a178:	fc 08 12 00 	clz	r8,lr
8000a17c:	e0 81 00 91 	brne	8000a29e <__avr32_udiv64+0x1f2>
8000a180:	1c 1b       	sub	r11,lr
8000a182:	fc 05 16 10 	lsr	r5,lr,0x10
8000a186:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000a18a:	30 1c       	mov	r12,1
8000a18c:	f6 05 0d 0a 	divu	r10,r11,r5
8000a190:	ec 08 16 10 	lsr	r8,r6,0x10
8000a194:	f4 09 02 43 	mul	r3,r10,r9
8000a198:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000a19c:	14 9b       	mov	r11,r10
8000a19e:	10 33       	cp.w	r3,r8
8000a1a0:	e0 88 00 0c 	brls	8000a1b8 <__avr32_udiv64+0x10c>
8000a1a4:	20 1b       	sub	r11,1
8000a1a6:	1c 08       	add	r8,lr
8000a1a8:	10 3e       	cp.w	lr,r8
8000a1aa:	e0 8b 00 07 	brhi	8000a1b8 <__avr32_udiv64+0x10c>
8000a1ae:	10 33       	cp.w	r3,r8
8000a1b0:	f7 bb 0b 01 	subhi	r11,1
8000a1b4:	f1 de eb 08 	addhi	r8,r8,lr
8000a1b8:	f0 03 01 03 	sub	r3,r8,r3
8000a1bc:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000a1c0:	e6 05 0d 02 	divu	r2,r3,r5
8000a1c4:	ed e3 11 06 	or	r6,r6,r3<<0x10
8000a1c8:	04 98       	mov	r8,r2
8000a1ca:	e4 09 02 49 	mul	r9,r2,r9
8000a1ce:	0c 39       	cp.w	r9,r6
8000a1d0:	e0 88 00 0a 	brls	8000a1e4 <__avr32_udiv64+0x138>
8000a1d4:	20 18       	sub	r8,1
8000a1d6:	1c 06       	add	r6,lr
8000a1d8:	0c 3e       	cp.w	lr,r6
8000a1da:	e0 8b 00 05 	brhi	8000a1e4 <__avr32_udiv64+0x138>
8000a1de:	0c 39       	cp.w	r9,r6
8000a1e0:	f7 b8 0b 01 	subhi	r8,1
8000a1e4:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
8000a1e8:	16 9a       	mov	r10,r11
8000a1ea:	18 9b       	mov	r11,r12
8000a1ec:	2f ed       	sub	sp,-8
8000a1ee:	d8 32       	popm	r0-r7,pc
8000a1f0:	30 0b       	mov	r11,0
8000a1f2:	16 9c       	mov	r12,r11
8000a1f4:	16 9a       	mov	r10,r11
8000a1f6:	18 9b       	mov	r11,r12
8000a1f8:	2f ed       	sub	sp,-8
8000a1fa:	d8 32       	popm	r0-r7,pc
8000a1fc:	f2 0c 09 45 	lsl	r5,r9,r12
8000a200:	f8 0e 11 20 	rsub	lr,r12,32
8000a204:	f0 0c 09 43 	lsl	r3,r8,r12
8000a208:	f4 0e 0a 46 	lsr	r6,r10,lr
8000a20c:	f0 0e 0a 48 	lsr	r8,r8,lr
8000a210:	f6 0e 0a 4e 	lsr	lr,r11,lr
8000a214:	0a 48       	or	r8,r5
8000a216:	f0 01 16 10 	lsr	r1,r8,0x10
8000a21a:	fc 01 0d 04 	divu	r4,lr,r1
8000a21e:	ee e5 ff f8 	st.d	r7[-8],r4
8000a222:	f6 0c 09 49 	lsl	r9,r11,r12
8000a226:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
8000a22a:	ed e9 10 09 	or	r9,r6,r9
8000a22e:	08 96       	mov	r6,r4
8000a230:	f2 0e 16 10 	lsr	lr,r9,0x10
8000a234:	ee f4 ff f8 	ld.w	r4,r7[-8]
8000a238:	ec 05 02 4b 	mul	r11,r6,r5
8000a23c:	fd e4 11 0e 	or	lr,lr,r4<<0x10
8000a240:	1c 3b       	cp.w	r11,lr
8000a242:	e0 88 00 07 	brls	8000a250 <__avr32_udiv64+0x1a4>
8000a246:	20 16       	sub	r6,1
8000a248:	10 0e       	add	lr,r8
8000a24a:	1c 38       	cp.w	r8,lr
8000a24c:	e0 88 00 6d 	brls	8000a326 <__avr32_udiv64+0x27a>
8000a250:	16 1e       	sub	lr,r11
8000a252:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000a256:	fc 01 0d 00 	divu	r0,lr,r1
8000a25a:	f3 e1 11 09 	or	r9,r9,r1<<0x10
8000a25e:	00 9b       	mov	r11,r0
8000a260:	e0 05 02 4e 	mul	lr,r0,r5
8000a264:	12 3e       	cp.w	lr,r9
8000a266:	e0 88 00 07 	brls	8000a274 <__avr32_udiv64+0x1c8>
8000a26a:	20 1b       	sub	r11,1
8000a26c:	10 09       	add	r9,r8
8000a26e:	12 38       	cp.w	r8,r9
8000a270:	e0 88 00 55 	brls	8000a31a <__avr32_udiv64+0x26e>
8000a274:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
8000a278:	1c 19       	sub	r9,lr
8000a27a:	f6 03 06 42 	mulu.d	r2,r11,r3
8000a27e:	06 39       	cp.w	r9,r3
8000a280:	c0 93       	brcs	8000a292 <__avr32_udiv64+0x1e6>
8000a282:	5f 09       	sreq	r9
8000a284:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a288:	04 3c       	cp.w	r12,r2
8000a28a:	5f 38       	srlo	r8
8000a28c:	f3 e8 00 08 	and	r8,r9,r8
8000a290:	c0 20       	breq	8000a294 <__avr32_udiv64+0x1e8>
8000a292:	20 1b       	sub	r11,1
8000a294:	30 0c       	mov	r12,0
8000a296:	16 9a       	mov	r10,r11
8000a298:	18 9b       	mov	r11,r12
8000a29a:	2f ed       	sub	sp,-8
8000a29c:	d8 32       	popm	r0-r7,pc
8000a29e:	f6 08 09 49 	lsl	r9,r11,r8
8000a2a2:	fc 08 09 4e 	lsl	lr,lr,r8
8000a2a6:	f0 01 11 20 	rsub	r1,r8,32
8000a2aa:	fc 05 16 10 	lsr	r5,lr,0x10
8000a2ae:	f4 01 0a 42 	lsr	r2,r10,r1
8000a2b2:	f6 01 0a 41 	lsr	r1,r11,r1
8000a2b6:	12 42       	or	r2,r9
8000a2b8:	e2 05 0d 00 	divu	r0,r1,r5
8000a2bc:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000a2c0:	e4 06 16 10 	lsr	r6,r2,0x10
8000a2c4:	00 93       	mov	r3,r0
8000a2c6:	ed e1 11 06 	or	r6,r6,r1<<0x10
8000a2ca:	e0 09 02 4c 	mul	r12,r0,r9
8000a2ce:	0c 3c       	cp.w	r12,r6
8000a2d0:	e0 88 00 07 	brls	8000a2de <__avr32_udiv64+0x232>
8000a2d4:	20 13       	sub	r3,1
8000a2d6:	1c 06       	add	r6,lr
8000a2d8:	0c 3e       	cp.w	lr,r6
8000a2da:	e0 88 00 2c 	brls	8000a332 <__avr32_udiv64+0x286>
8000a2de:	ec 0c 01 01 	sub	r1,r6,r12
8000a2e2:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000a2e6:	e2 05 0d 00 	divu	r0,r1,r5
8000a2ea:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000a2ee:	00 9c       	mov	r12,r0
8000a2f0:	e0 09 02 41 	mul	r1,r0,r9
8000a2f4:	16 31       	cp.w	r1,r11
8000a2f6:	e0 88 00 0c 	brls	8000a30e <__avr32_udiv64+0x262>
8000a2fa:	20 1c       	sub	r12,1
8000a2fc:	1c 0b       	add	r11,lr
8000a2fe:	16 3e       	cp.w	lr,r11
8000a300:	e0 8b 00 07 	brhi	8000a30e <__avr32_udiv64+0x262>
8000a304:	16 31       	cp.w	r1,r11
8000a306:	f7 bc 0b 01 	subhi	r12,1
8000a30a:	f7 de eb 0b 	addhi	r11,r11,lr
8000a30e:	f4 08 09 46 	lsl	r6,r10,r8
8000a312:	02 1b       	sub	r11,r1
8000a314:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
8000a318:	c3 ab       	rjmp	8000a18c <__avr32_udiv64+0xe0>
8000a31a:	12 3e       	cp.w	lr,r9
8000a31c:	f3 d8 eb 09 	addhi	r9,r9,r8
8000a320:	f7 bb 0b 01 	subhi	r11,1
8000a324:	ca 8b       	rjmp	8000a274 <__avr32_udiv64+0x1c8>
8000a326:	1c 3b       	cp.w	r11,lr
8000a328:	f7 b6 0b 01 	subhi	r6,1
8000a32c:	fd d8 eb 0e 	addhi	lr,lr,r8
8000a330:	c9 0b       	rjmp	8000a250 <__avr32_udiv64+0x1a4>
8000a332:	0c 3c       	cp.w	r12,r6
8000a334:	f7 b3 0b 01 	subhi	r3,1
8000a338:	ed de eb 06 	addhi	r6,r6,lr
8000a33c:	cd 1b       	rjmp	8000a2de <__avr32_udiv64+0x232>
8000a33e:	d7 03       	nop

8000a340 <free>:
8000a340:	d4 01       	pushm	lr
8000a342:	e0 68 05 28 	mov	r8,1320
8000a346:	18 9b       	mov	r11,r12
8000a348:	70 0c       	ld.w	r12,r8[0x0]
8000a34a:	e0 a0 03 5f 	rcall	8000aa08 <_free_r>
8000a34e:	d8 02       	popm	pc

8000a350 <malloc>:
8000a350:	d4 01       	pushm	lr
8000a352:	e0 68 05 28 	mov	r8,1320
8000a356:	18 9b       	mov	r11,r12
8000a358:	70 0c       	ld.w	r12,r8[0x0]
8000a35a:	c0 3c       	rcall	8000a360 <_malloc_r>
8000a35c:	d8 02       	popm	pc
8000a35e:	d7 03       	nop

8000a360 <_malloc_r>:
8000a360:	d4 31       	pushm	r0-r7,lr
8000a362:	f6 c7 ff f5 	sub	r7,r11,-11
8000a366:	18 95       	mov	r5,r12
8000a368:	59 67       	cp.w	r7,22
8000a36a:	f9 b7 08 10 	movls	r7,16
8000a36e:	f9 b8 0b f8 	movhi	r8,-8
8000a372:	ef d8 eb 27 	andhi	r7,r7,r8
8000a376:	16 37       	cp.w	r7,r11
8000a378:	5f 38       	srlo	r8
8000a37a:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a37e:	c0 50       	breq	8000a388 <_malloc_r+0x28>
8000a380:	30 c8       	mov	r8,12
8000a382:	99 38       	st.w	r12[0xc],r8
8000a384:	e0 8f 01 f1 	bral	8000a766 <_malloc_r+0x406>
8000a388:	e0 a0 02 a9 	rcall	8000a8da <__malloc_lock>
8000a38c:	e0 47 01 f7 	cp.w	r7,503
8000a390:	e0 8b 00 1c 	brhi	8000a3c8 <_malloc_r+0x68>
8000a394:	ee 03 16 03 	lsr	r3,r7,0x3
8000a398:	32 88       	mov	r8,40
8000a39a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a39e:	70 36       	ld.w	r6,r8[0xc]
8000a3a0:	10 36       	cp.w	r6,r8
8000a3a2:	c0 61       	brne	8000a3ae <_malloc_r+0x4e>
8000a3a4:	ec c8 ff f8 	sub	r8,r6,-8
8000a3a8:	70 36       	ld.w	r6,r8[0xc]
8000a3aa:	10 36       	cp.w	r6,r8
8000a3ac:	c0 c0       	breq	8000a3c4 <_malloc_r+0x64>
8000a3ae:	6c 18       	ld.w	r8,r6[0x4]
8000a3b0:	e0 18 ff fc 	andl	r8,0xfffc
8000a3b4:	6c 3a       	ld.w	r10,r6[0xc]
8000a3b6:	ec 08 00 09 	add	r9,r6,r8
8000a3ba:	0a 9c       	mov	r12,r5
8000a3bc:	6c 28       	ld.w	r8,r6[0x8]
8000a3be:	95 28       	st.w	r10[0x8],r8
8000a3c0:	91 3a       	st.w	r8[0xc],r10
8000a3c2:	c4 78       	rjmp	8000a450 <_malloc_r+0xf0>
8000a3c4:	2f e3       	sub	r3,-2
8000a3c6:	c4 d8       	rjmp	8000a460 <_malloc_r+0x100>
8000a3c8:	ee 08 16 09 	lsr	r8,r7,0x9
8000a3cc:	c0 41       	brne	8000a3d4 <_malloc_r+0x74>
8000a3ce:	ee 03 16 03 	lsr	r3,r7,0x3
8000a3d2:	c2 78       	rjmp	8000a420 <_malloc_r+0xc0>
8000a3d4:	58 48       	cp.w	r8,4
8000a3d6:	e0 8b 00 06 	brhi	8000a3e2 <_malloc_r+0x82>
8000a3da:	ee 03 16 06 	lsr	r3,r7,0x6
8000a3de:	2c 83       	sub	r3,-56
8000a3e0:	c2 08       	rjmp	8000a420 <_malloc_r+0xc0>
8000a3e2:	59 48       	cp.w	r8,20
8000a3e4:	e0 8b 00 05 	brhi	8000a3ee <_malloc_r+0x8e>
8000a3e8:	f0 c3 ff a5 	sub	r3,r8,-91
8000a3ec:	c1 a8       	rjmp	8000a420 <_malloc_r+0xc0>
8000a3ee:	e0 48 00 54 	cp.w	r8,84
8000a3f2:	e0 8b 00 06 	brhi	8000a3fe <_malloc_r+0x9e>
8000a3f6:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a3fa:	29 23       	sub	r3,-110
8000a3fc:	c1 28       	rjmp	8000a420 <_malloc_r+0xc0>
8000a3fe:	e0 48 01 54 	cp.w	r8,340
8000a402:	e0 8b 00 06 	brhi	8000a40e <_malloc_r+0xae>
8000a406:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a40a:	28 93       	sub	r3,-119
8000a40c:	c0 a8       	rjmp	8000a420 <_malloc_r+0xc0>
8000a40e:	ee 03 16 12 	lsr	r3,r7,0x12
8000a412:	e0 48 05 54 	cp.w	r8,1364
8000a416:	e0 88 00 04 	brls	8000a41e <_malloc_r+0xbe>
8000a41a:	37 e3       	mov	r3,126
8000a41c:	c0 28       	rjmp	8000a420 <_malloc_r+0xc0>
8000a41e:	28 43       	sub	r3,-124
8000a420:	32 8a       	mov	r10,40
8000a422:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a426:	74 36       	ld.w	r6,r10[0xc]
8000a428:	c1 98       	rjmp	8000a45a <_malloc_r+0xfa>
8000a42a:	6c 19       	ld.w	r9,r6[0x4]
8000a42c:	e0 19 ff fc 	andl	r9,0xfffc
8000a430:	f2 07 01 0b 	sub	r11,r9,r7
8000a434:	58 fb       	cp.w	r11,15
8000a436:	e0 8a 00 04 	brle	8000a43e <_malloc_r+0xde>
8000a43a:	20 13       	sub	r3,1
8000a43c:	c1 18       	rjmp	8000a45e <_malloc_r+0xfe>
8000a43e:	6c 38       	ld.w	r8,r6[0xc]
8000a440:	58 0b       	cp.w	r11,0
8000a442:	c0 b5       	brlt	8000a458 <_malloc_r+0xf8>
8000a444:	6c 2a       	ld.w	r10,r6[0x8]
8000a446:	ec 09 00 09 	add	r9,r6,r9
8000a44a:	0a 9c       	mov	r12,r5
8000a44c:	91 2a       	st.w	r8[0x8],r10
8000a44e:	95 38       	st.w	r10[0xc],r8
8000a450:	72 18       	ld.w	r8,r9[0x4]
8000a452:	a1 a8       	sbr	r8,0x0
8000a454:	93 18       	st.w	r9[0x4],r8
8000a456:	cb 98       	rjmp	8000a5c8 <_malloc_r+0x268>
8000a458:	10 96       	mov	r6,r8
8000a45a:	14 36       	cp.w	r6,r10
8000a45c:	ce 71       	brne	8000a42a <_malloc_r+0xca>
8000a45e:	2f f3       	sub	r3,-1
8000a460:	32 8a       	mov	r10,40
8000a462:	f4 cc ff f8 	sub	r12,r10,-8
8000a466:	78 26       	ld.w	r6,r12[0x8]
8000a468:	18 36       	cp.w	r6,r12
8000a46a:	c6 b0       	breq	8000a540 <_malloc_r+0x1e0>
8000a46c:	6c 19       	ld.w	r9,r6[0x4]
8000a46e:	e0 19 ff fc 	andl	r9,0xfffc
8000a472:	f2 07 01 08 	sub	r8,r9,r7
8000a476:	58 f8       	cp.w	r8,15
8000a478:	e0 89 00 8d 	brgt	8000a592 <_malloc_r+0x232>
8000a47c:	99 3c       	st.w	r12[0xc],r12
8000a47e:	99 2c       	st.w	r12[0x8],r12
8000a480:	58 08       	cp.w	r8,0
8000a482:	c0 55       	brlt	8000a48c <_malloc_r+0x12c>
8000a484:	ec 09 00 09 	add	r9,r6,r9
8000a488:	0a 9c       	mov	r12,r5
8000a48a:	ce 3b       	rjmp	8000a450 <_malloc_r+0xf0>
8000a48c:	e0 49 01 ff 	cp.w	r9,511
8000a490:	e0 8b 00 13 	brhi	8000a4b6 <_malloc_r+0x156>
8000a494:	a3 99       	lsr	r9,0x3
8000a496:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a49a:	70 2b       	ld.w	r11,r8[0x8]
8000a49c:	8d 38       	st.w	r6[0xc],r8
8000a49e:	8d 2b       	st.w	r6[0x8],r11
8000a4a0:	97 36       	st.w	r11[0xc],r6
8000a4a2:	91 26       	st.w	r8[0x8],r6
8000a4a4:	a3 49       	asr	r9,0x2
8000a4a6:	74 18       	ld.w	r8,r10[0x4]
8000a4a8:	30 1b       	mov	r11,1
8000a4aa:	f6 09 09 49 	lsl	r9,r11,r9
8000a4ae:	f1 e9 10 09 	or	r9,r8,r9
8000a4b2:	95 19       	st.w	r10[0x4],r9
8000a4b4:	c4 68       	rjmp	8000a540 <_malloc_r+0x1e0>
8000a4b6:	f2 08 16 09 	lsr	r8,r9,0x9
8000a4ba:	58 48       	cp.w	r8,4
8000a4bc:	e0 8b 00 06 	brhi	8000a4c8 <_malloc_r+0x168>
8000a4c0:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a4c4:	2c 8a       	sub	r10,-56
8000a4c6:	c2 08       	rjmp	8000a506 <_malloc_r+0x1a6>
8000a4c8:	59 48       	cp.w	r8,20
8000a4ca:	e0 8b 00 05 	brhi	8000a4d4 <_malloc_r+0x174>
8000a4ce:	f0 ca ff a5 	sub	r10,r8,-91
8000a4d2:	c1 a8       	rjmp	8000a506 <_malloc_r+0x1a6>
8000a4d4:	e0 48 00 54 	cp.w	r8,84
8000a4d8:	e0 8b 00 06 	brhi	8000a4e4 <_malloc_r+0x184>
8000a4dc:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a4e0:	29 2a       	sub	r10,-110
8000a4e2:	c1 28       	rjmp	8000a506 <_malloc_r+0x1a6>
8000a4e4:	e0 48 01 54 	cp.w	r8,340
8000a4e8:	e0 8b 00 06 	brhi	8000a4f4 <_malloc_r+0x194>
8000a4ec:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a4f0:	28 9a       	sub	r10,-119
8000a4f2:	c0 a8       	rjmp	8000a506 <_malloc_r+0x1a6>
8000a4f4:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a4f8:	e0 48 05 54 	cp.w	r8,1364
8000a4fc:	e0 88 00 04 	brls	8000a504 <_malloc_r+0x1a4>
8000a500:	37 ea       	mov	r10,126
8000a502:	c0 28       	rjmp	8000a506 <_malloc_r+0x1a6>
8000a504:	28 4a       	sub	r10,-124
8000a506:	32 8b       	mov	r11,40
8000a508:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a50c:	68 28       	ld.w	r8,r4[0x8]
8000a50e:	08 38       	cp.w	r8,r4
8000a510:	c0 e1       	brne	8000a52c <_malloc_r+0x1cc>
8000a512:	76 19       	ld.w	r9,r11[0x4]
8000a514:	a3 4a       	asr	r10,0x2
8000a516:	30 1e       	mov	lr,1
8000a518:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a51c:	f3 ea 10 0a 	or	r10,r9,r10
8000a520:	10 99       	mov	r9,r8
8000a522:	97 1a       	st.w	r11[0x4],r10
8000a524:	c0 a8       	rjmp	8000a538 <_malloc_r+0x1d8>
8000a526:	70 28       	ld.w	r8,r8[0x8]
8000a528:	08 38       	cp.w	r8,r4
8000a52a:	c0 60       	breq	8000a536 <_malloc_r+0x1d6>
8000a52c:	70 1a       	ld.w	r10,r8[0x4]
8000a52e:	e0 1a ff fc 	andl	r10,0xfffc
8000a532:	14 39       	cp.w	r9,r10
8000a534:	cf 93       	brcs	8000a526 <_malloc_r+0x1c6>
8000a536:	70 39       	ld.w	r9,r8[0xc]
8000a538:	8d 39       	st.w	r6[0xc],r9
8000a53a:	8d 28       	st.w	r6[0x8],r8
8000a53c:	91 36       	st.w	r8[0xc],r6
8000a53e:	93 26       	st.w	r9[0x8],r6
8000a540:	e6 08 14 02 	asr	r8,r3,0x2
8000a544:	30 1b       	mov	r11,1
8000a546:	32 84       	mov	r4,40
8000a548:	f6 08 09 4b 	lsl	r11,r11,r8
8000a54c:	68 18       	ld.w	r8,r4[0x4]
8000a54e:	10 3b       	cp.w	r11,r8
8000a550:	e0 8b 00 6a 	brhi	8000a624 <_malloc_r+0x2c4>
8000a554:	f7 e8 00 09 	and	r9,r11,r8
8000a558:	c0 b1       	brne	8000a56e <_malloc_r+0x20e>
8000a55a:	e0 13 ff fc 	andl	r3,0xfffc
8000a55e:	a1 7b       	lsl	r11,0x1
8000a560:	2f c3       	sub	r3,-4
8000a562:	c0 38       	rjmp	8000a568 <_malloc_r+0x208>
8000a564:	2f c3       	sub	r3,-4
8000a566:	a1 7b       	lsl	r11,0x1
8000a568:	f7 e8 00 09 	and	r9,r11,r8
8000a56c:	cf c0       	breq	8000a564 <_malloc_r+0x204>
8000a56e:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a572:	06 92       	mov	r2,r3
8000a574:	1c 91       	mov	r1,lr
8000a576:	62 36       	ld.w	r6,r1[0xc]
8000a578:	c2 d8       	rjmp	8000a5d2 <_malloc_r+0x272>
8000a57a:	6c 1a       	ld.w	r10,r6[0x4]
8000a57c:	e0 1a ff fc 	andl	r10,0xfffc
8000a580:	f4 07 01 08 	sub	r8,r10,r7
8000a584:	58 f8       	cp.w	r8,15
8000a586:	e0 8a 00 15 	brle	8000a5b0 <_malloc_r+0x250>
8000a58a:	6c 3a       	ld.w	r10,r6[0xc]
8000a58c:	6c 29       	ld.w	r9,r6[0x8]
8000a58e:	95 29       	st.w	r10[0x8],r9
8000a590:	93 3a       	st.w	r9[0xc],r10
8000a592:	0e 99       	mov	r9,r7
8000a594:	ec 07 00 07 	add	r7,r6,r7
8000a598:	a1 a9       	sbr	r9,0x0
8000a59a:	99 37       	st.w	r12[0xc],r7
8000a59c:	99 27       	st.w	r12[0x8],r7
8000a59e:	8d 19       	st.w	r6[0x4],r9
8000a5a0:	ee 08 09 08 	st.w	r7[r8],r8
8000a5a4:	8f 2c       	st.w	r7[0x8],r12
8000a5a6:	8f 3c       	st.w	r7[0xc],r12
8000a5a8:	a1 a8       	sbr	r8,0x0
8000a5aa:	0a 9c       	mov	r12,r5
8000a5ac:	8f 18       	st.w	r7[0x4],r8
8000a5ae:	c0 d8       	rjmp	8000a5c8 <_malloc_r+0x268>
8000a5b0:	6c 39       	ld.w	r9,r6[0xc]
8000a5b2:	58 08       	cp.w	r8,0
8000a5b4:	c0 e5       	brlt	8000a5d0 <_malloc_r+0x270>
8000a5b6:	ec 0a 00 0a 	add	r10,r6,r10
8000a5ba:	74 18       	ld.w	r8,r10[0x4]
8000a5bc:	a1 a8       	sbr	r8,0x0
8000a5be:	0a 9c       	mov	r12,r5
8000a5c0:	95 18       	st.w	r10[0x4],r8
8000a5c2:	6c 28       	ld.w	r8,r6[0x8]
8000a5c4:	93 28       	st.w	r9[0x8],r8
8000a5c6:	91 39       	st.w	r8[0xc],r9
8000a5c8:	c8 ad       	rcall	8000a8dc <__malloc_unlock>
8000a5ca:	ec cc ff f8 	sub	r12,r6,-8
8000a5ce:	d8 32       	popm	r0-r7,pc
8000a5d0:	12 96       	mov	r6,r9
8000a5d2:	02 36       	cp.w	r6,r1
8000a5d4:	cd 31       	brne	8000a57a <_malloc_r+0x21a>
8000a5d6:	2f f2       	sub	r2,-1
8000a5d8:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a5dc:	c0 30       	breq	8000a5e2 <_malloc_r+0x282>
8000a5de:	2f 81       	sub	r1,-8
8000a5e0:	cc bb       	rjmp	8000a576 <_malloc_r+0x216>
8000a5e2:	1c 98       	mov	r8,lr
8000a5e4:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a5e8:	c0 81       	brne	8000a5f8 <_malloc_r+0x298>
8000a5ea:	68 19       	ld.w	r9,r4[0x4]
8000a5ec:	f6 08 11 ff 	rsub	r8,r11,-1
8000a5f0:	f3 e8 00 08 	and	r8,r9,r8
8000a5f4:	89 18       	st.w	r4[0x4],r8
8000a5f6:	c0 78       	rjmp	8000a604 <_malloc_r+0x2a4>
8000a5f8:	f0 c9 00 08 	sub	r9,r8,8
8000a5fc:	20 13       	sub	r3,1
8000a5fe:	70 08       	ld.w	r8,r8[0x0]
8000a600:	12 38       	cp.w	r8,r9
8000a602:	cf 10       	breq	8000a5e4 <_malloc_r+0x284>
8000a604:	a1 7b       	lsl	r11,0x1
8000a606:	68 18       	ld.w	r8,r4[0x4]
8000a608:	10 3b       	cp.w	r11,r8
8000a60a:	e0 8b 00 0d 	brhi	8000a624 <_malloc_r+0x2c4>
8000a60e:	58 0b       	cp.w	r11,0
8000a610:	c0 a0       	breq	8000a624 <_malloc_r+0x2c4>
8000a612:	04 93       	mov	r3,r2
8000a614:	c0 38       	rjmp	8000a61a <_malloc_r+0x2ba>
8000a616:	2f c3       	sub	r3,-4
8000a618:	a1 7b       	lsl	r11,0x1
8000a61a:	f7 e8 00 09 	and	r9,r11,r8
8000a61e:	ca 81       	brne	8000a56e <_malloc_r+0x20e>
8000a620:	cf bb       	rjmp	8000a616 <_malloc_r+0x2b6>
8000a622:	d7 03       	nop
8000a624:	68 23       	ld.w	r3,r4[0x8]
8000a626:	66 12       	ld.w	r2,r3[0x4]
8000a628:	e0 12 ff fc 	andl	r2,0xfffc
8000a62c:	0e 32       	cp.w	r2,r7
8000a62e:	5f 39       	srlo	r9
8000a630:	e4 07 01 08 	sub	r8,r2,r7
8000a634:	58 f8       	cp.w	r8,15
8000a636:	5f aa       	srle	r10
8000a638:	f5 e9 10 09 	or	r9,r10,r9
8000a63c:	e0 80 00 96 	breq	8000a768 <_malloc_r+0x408>
8000a640:	e0 68 2a 08 	mov	r8,10760
8000a644:	70 01       	ld.w	r1,r8[0x0]
8000a646:	e0 68 04 34 	mov	r8,1076
8000a64a:	2f 01       	sub	r1,-16
8000a64c:	70 08       	ld.w	r8,r8[0x0]
8000a64e:	0e 01       	add	r1,r7
8000a650:	5b f8       	cp.w	r8,-1
8000a652:	c0 40       	breq	8000a65a <_malloc_r+0x2fa>
8000a654:	28 11       	sub	r1,-127
8000a656:	e0 11 ff 80 	andl	r1,0xff80
8000a65a:	02 9b       	mov	r11,r1
8000a65c:	0a 9c       	mov	r12,r5
8000a65e:	c4 1d       	rcall	8000a8e0 <_sbrk_r>
8000a660:	18 96       	mov	r6,r12
8000a662:	5b fc       	cp.w	r12,-1
8000a664:	c7 30       	breq	8000a74a <_malloc_r+0x3ea>
8000a666:	e6 02 00 08 	add	r8,r3,r2
8000a66a:	10 3c       	cp.w	r12,r8
8000a66c:	c0 32       	brcc	8000a672 <_malloc_r+0x312>
8000a66e:	08 33       	cp.w	r3,r4
8000a670:	c6 d1       	brne	8000a74a <_malloc_r+0x3ea>
8000a672:	e0 6a 2a 0c 	mov	r10,10764
8000a676:	74 09       	ld.w	r9,r10[0x0]
8000a678:	e2 09 00 09 	add	r9,r1,r9
8000a67c:	95 09       	st.w	r10[0x0],r9
8000a67e:	10 36       	cp.w	r6,r8
8000a680:	c0 a1       	brne	8000a694 <_malloc_r+0x334>
8000a682:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a686:	c0 71       	brne	8000a694 <_malloc_r+0x334>
8000a688:	e2 02 00 02 	add	r2,r1,r2
8000a68c:	68 28       	ld.w	r8,r4[0x8]
8000a68e:	a1 a2       	sbr	r2,0x0
8000a690:	91 12       	st.w	r8[0x4],r2
8000a692:	c4 d8       	rjmp	8000a72c <_malloc_r+0x3cc>
8000a694:	e0 6a 04 34 	mov	r10,1076
8000a698:	74 0b       	ld.w	r11,r10[0x0]
8000a69a:	5b fb       	cp.w	r11,-1
8000a69c:	c0 31       	brne	8000a6a2 <_malloc_r+0x342>
8000a69e:	95 06       	st.w	r10[0x0],r6
8000a6a0:	c0 78       	rjmp	8000a6ae <_malloc_r+0x34e>
8000a6a2:	ec 09 00 09 	add	r9,r6,r9
8000a6a6:	e0 6a 2a 0c 	mov	r10,10764
8000a6aa:	10 19       	sub	r9,r8
8000a6ac:	95 09       	st.w	r10[0x0],r9
8000a6ae:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a6b2:	f0 09 11 08 	rsub	r9,r8,8
8000a6b6:	58 08       	cp.w	r8,0
8000a6b8:	f2 08 17 10 	movne	r8,r9
8000a6bc:	ed d8 e1 06 	addne	r6,r6,r8
8000a6c0:	28 08       	sub	r8,-128
8000a6c2:	ec 01 00 01 	add	r1,r6,r1
8000a6c6:	0a 9c       	mov	r12,r5
8000a6c8:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a6cc:	f0 01 01 01 	sub	r1,r8,r1
8000a6d0:	02 9b       	mov	r11,r1
8000a6d2:	c0 7d       	rcall	8000a8e0 <_sbrk_r>
8000a6d4:	e0 68 2a 0c 	mov	r8,10764
8000a6d8:	5b fc       	cp.w	r12,-1
8000a6da:	ec 0c 17 00 	moveq	r12,r6
8000a6de:	f9 b1 00 00 	moveq	r1,0
8000a6e2:	70 09       	ld.w	r9,r8[0x0]
8000a6e4:	0c 1c       	sub	r12,r6
8000a6e6:	89 26       	st.w	r4[0x8],r6
8000a6e8:	02 0c       	add	r12,r1
8000a6ea:	12 01       	add	r1,r9
8000a6ec:	a1 ac       	sbr	r12,0x0
8000a6ee:	91 01       	st.w	r8[0x0],r1
8000a6f0:	8d 1c       	st.w	r6[0x4],r12
8000a6f2:	08 33       	cp.w	r3,r4
8000a6f4:	c1 c0       	breq	8000a72c <_malloc_r+0x3cc>
8000a6f6:	58 f2       	cp.w	r2,15
8000a6f8:	e0 8b 00 05 	brhi	8000a702 <_malloc_r+0x3a2>
8000a6fc:	30 18       	mov	r8,1
8000a6fe:	8d 18       	st.w	r6[0x4],r8
8000a700:	c2 58       	rjmp	8000a74a <_malloc_r+0x3ea>
8000a702:	30 59       	mov	r9,5
8000a704:	20 c2       	sub	r2,12
8000a706:	e0 12 ff f8 	andl	r2,0xfff8
8000a70a:	e6 02 00 08 	add	r8,r3,r2
8000a70e:	91 29       	st.w	r8[0x8],r9
8000a710:	91 19       	st.w	r8[0x4],r9
8000a712:	66 18       	ld.w	r8,r3[0x4]
8000a714:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a718:	e5 e8 10 08 	or	r8,r2,r8
8000a71c:	87 18       	st.w	r3[0x4],r8
8000a71e:	58 f2       	cp.w	r2,15
8000a720:	e0 88 00 06 	brls	8000a72c <_malloc_r+0x3cc>
8000a724:	e6 cb ff f8 	sub	r11,r3,-8
8000a728:	0a 9c       	mov	r12,r5
8000a72a:	c6 fd       	rcall	8000aa08 <_free_r>
8000a72c:	e0 69 2a 04 	mov	r9,10756
8000a730:	72 0a       	ld.w	r10,r9[0x0]
8000a732:	e0 68 2a 0c 	mov	r8,10764
8000a736:	70 08       	ld.w	r8,r8[0x0]
8000a738:	14 38       	cp.w	r8,r10
8000a73a:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a73e:	e0 69 2a 00 	mov	r9,10752
8000a742:	72 0a       	ld.w	r10,r9[0x0]
8000a744:	14 38       	cp.w	r8,r10
8000a746:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a74a:	68 28       	ld.w	r8,r4[0x8]
8000a74c:	70 18       	ld.w	r8,r8[0x4]
8000a74e:	e0 18 ff fc 	andl	r8,0xfffc
8000a752:	0e 38       	cp.w	r8,r7
8000a754:	5f 39       	srlo	r9
8000a756:	0e 18       	sub	r8,r7
8000a758:	58 f8       	cp.w	r8,15
8000a75a:	5f aa       	srle	r10
8000a75c:	f5 e9 10 09 	or	r9,r10,r9
8000a760:	c0 40       	breq	8000a768 <_malloc_r+0x408>
8000a762:	0a 9c       	mov	r12,r5
8000a764:	cb cc       	rcall	8000a8dc <__malloc_unlock>
8000a766:	d8 3a       	popm	r0-r7,pc,r12=0
8000a768:	68 26       	ld.w	r6,r4[0x8]
8000a76a:	a1 a8       	sbr	r8,0x0
8000a76c:	0e 99       	mov	r9,r7
8000a76e:	a1 a9       	sbr	r9,0x0
8000a770:	8d 19       	st.w	r6[0x4],r9
8000a772:	ec 07 00 07 	add	r7,r6,r7
8000a776:	0a 9c       	mov	r12,r5
8000a778:	89 27       	st.w	r4[0x8],r7
8000a77a:	8f 18       	st.w	r7[0x4],r8
8000a77c:	cb 0c       	rcall	8000a8dc <__malloc_unlock>
8000a77e:	ec cc ff f8 	sub	r12,r6,-8
8000a782:	d8 32       	popm	r0-r7,pc

8000a784 <memcpy>:
8000a784:	58 8a       	cp.w	r10,8
8000a786:	c2 f5       	brlt	8000a7e4 <memcpy+0x60>
8000a788:	f9 eb 10 09 	or	r9,r12,r11
8000a78c:	e2 19 00 03 	andl	r9,0x3,COH
8000a790:	e0 81 00 97 	brne	8000a8be <memcpy+0x13a>
8000a794:	e0 4a 00 20 	cp.w	r10,32
8000a798:	c3 b4       	brge	8000a80e <memcpy+0x8a>
8000a79a:	f4 08 14 02 	asr	r8,r10,0x2
8000a79e:	f0 09 11 08 	rsub	r9,r8,8
8000a7a2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a7a6:	76 69       	ld.w	r9,r11[0x18]
8000a7a8:	99 69       	st.w	r12[0x18],r9
8000a7aa:	76 59       	ld.w	r9,r11[0x14]
8000a7ac:	99 59       	st.w	r12[0x14],r9
8000a7ae:	76 49       	ld.w	r9,r11[0x10]
8000a7b0:	99 49       	st.w	r12[0x10],r9
8000a7b2:	76 39       	ld.w	r9,r11[0xc]
8000a7b4:	99 39       	st.w	r12[0xc],r9
8000a7b6:	76 29       	ld.w	r9,r11[0x8]
8000a7b8:	99 29       	st.w	r12[0x8],r9
8000a7ba:	76 19       	ld.w	r9,r11[0x4]
8000a7bc:	99 19       	st.w	r12[0x4],r9
8000a7be:	76 09       	ld.w	r9,r11[0x0]
8000a7c0:	99 09       	st.w	r12[0x0],r9
8000a7c2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a7c6:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a7ca:	e0 1a 00 03 	andl	r10,0x3
8000a7ce:	f4 0a 11 04 	rsub	r10,r10,4
8000a7d2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a7d6:	17 a9       	ld.ub	r9,r11[0x2]
8000a7d8:	b0 a9       	st.b	r8[0x2],r9
8000a7da:	17 99       	ld.ub	r9,r11[0x1]
8000a7dc:	b0 99       	st.b	r8[0x1],r9
8000a7de:	17 89       	ld.ub	r9,r11[0x0]
8000a7e0:	b0 89       	st.b	r8[0x0],r9
8000a7e2:	5e fc       	retal	r12
8000a7e4:	f4 0a 11 09 	rsub	r10,r10,9
8000a7e8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a7ec:	17 f9       	ld.ub	r9,r11[0x7]
8000a7ee:	b8 f9       	st.b	r12[0x7],r9
8000a7f0:	17 e9       	ld.ub	r9,r11[0x6]
8000a7f2:	b8 e9       	st.b	r12[0x6],r9
8000a7f4:	17 d9       	ld.ub	r9,r11[0x5]
8000a7f6:	b8 d9       	st.b	r12[0x5],r9
8000a7f8:	17 c9       	ld.ub	r9,r11[0x4]
8000a7fa:	b8 c9       	st.b	r12[0x4],r9
8000a7fc:	17 b9       	ld.ub	r9,r11[0x3]
8000a7fe:	b8 b9       	st.b	r12[0x3],r9
8000a800:	17 a9       	ld.ub	r9,r11[0x2]
8000a802:	b8 a9       	st.b	r12[0x2],r9
8000a804:	17 99       	ld.ub	r9,r11[0x1]
8000a806:	b8 99       	st.b	r12[0x1],r9
8000a808:	17 89       	ld.ub	r9,r11[0x0]
8000a80a:	b8 89       	st.b	r12[0x0],r9
8000a80c:	5e fc       	retal	r12
8000a80e:	eb cd 40 c0 	pushm	r6-r7,lr
8000a812:	18 99       	mov	r9,r12
8000a814:	22 0a       	sub	r10,32
8000a816:	b7 07       	ld.d	r6,r11++
8000a818:	b3 26       	st.d	r9++,r6
8000a81a:	b7 07       	ld.d	r6,r11++
8000a81c:	b3 26       	st.d	r9++,r6
8000a81e:	b7 07       	ld.d	r6,r11++
8000a820:	b3 26       	st.d	r9++,r6
8000a822:	b7 07       	ld.d	r6,r11++
8000a824:	b3 26       	st.d	r9++,r6
8000a826:	22 0a       	sub	r10,32
8000a828:	cf 74       	brge	8000a816 <memcpy+0x92>
8000a82a:	2f 0a       	sub	r10,-16
8000a82c:	c0 65       	brlt	8000a838 <memcpy+0xb4>
8000a82e:	b7 07       	ld.d	r6,r11++
8000a830:	b3 26       	st.d	r9++,r6
8000a832:	b7 07       	ld.d	r6,r11++
8000a834:	b3 26       	st.d	r9++,r6
8000a836:	21 0a       	sub	r10,16
8000a838:	5c 3a       	neg	r10
8000a83a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a83e:	d7 03       	nop
8000a840:	d7 03       	nop
8000a842:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a846:	f3 66 00 0e 	st.b	r9[14],r6
8000a84a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a84e:	f3 66 00 0d 	st.b	r9[13],r6
8000a852:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a856:	f3 66 00 0c 	st.b	r9[12],r6
8000a85a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a85e:	f3 66 00 0b 	st.b	r9[11],r6
8000a862:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a866:	f3 66 00 0a 	st.b	r9[10],r6
8000a86a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a86e:	f3 66 00 09 	st.b	r9[9],r6
8000a872:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a876:	f3 66 00 08 	st.b	r9[8],r6
8000a87a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a87e:	f3 66 00 07 	st.b	r9[7],r6
8000a882:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a886:	f3 66 00 06 	st.b	r9[6],r6
8000a88a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a88e:	f3 66 00 05 	st.b	r9[5],r6
8000a892:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a896:	f3 66 00 04 	st.b	r9[4],r6
8000a89a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a89e:	f3 66 00 03 	st.b	r9[3],r6
8000a8a2:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a8a6:	f3 66 00 02 	st.b	r9[2],r6
8000a8aa:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a8ae:	f3 66 00 01 	st.b	r9[1],r6
8000a8b2:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a8b6:	f3 66 00 00 	st.b	r9[0],r6
8000a8ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a8be:	20 1a       	sub	r10,1
8000a8c0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a8c4:	f8 0a 0b 09 	st.b	r12[r10],r9
8000a8c8:	cf b1       	brne	8000a8be <memcpy+0x13a>
8000a8ca:	5e fc       	retal	r12

8000a8cc <memset>:
8000a8cc:	18 98       	mov	r8,r12
8000a8ce:	c0 38       	rjmp	8000a8d4 <memset+0x8>
8000a8d0:	10 cb       	st.b	r8++,r11
8000a8d2:	20 1a       	sub	r10,1
8000a8d4:	58 0a       	cp.w	r10,0
8000a8d6:	cf d1       	brne	8000a8d0 <memset+0x4>
8000a8d8:	5e fc       	retal	r12

8000a8da <__malloc_lock>:
8000a8da:	5e fc       	retal	r12

8000a8dc <__malloc_unlock>:
8000a8dc:	5e fc       	retal	r12
8000a8de:	d7 03       	nop

8000a8e0 <_sbrk_r>:
8000a8e0:	d4 21       	pushm	r4-r7,lr
8000a8e2:	30 08       	mov	r8,0
8000a8e4:	18 97       	mov	r7,r12
8000a8e6:	e0 66 32 88 	mov	r6,12936
8000a8ea:	16 9c       	mov	r12,r11
8000a8ec:	8d 08       	st.w	r6[0x0],r8
8000a8ee:	c2 7c       	rcall	8000a93c <_sbrk>
8000a8f0:	5b fc       	cp.w	r12,-1
8000a8f2:	c0 51       	brne	8000a8fc <_sbrk_r+0x1c>
8000a8f4:	6c 08       	ld.w	r8,r6[0x0]
8000a8f6:	58 08       	cp.w	r8,0
8000a8f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a8fc:	d8 22       	popm	r4-r7,pc
8000a8fe:	d7 03       	nop

8000a900 <strlen>:
8000a900:	30 09       	mov	r9,0
8000a902:	18 98       	mov	r8,r12
8000a904:	c0 28       	rjmp	8000a908 <strlen+0x8>
8000a906:	2f f8       	sub	r8,-1
8000a908:	11 8a       	ld.ub	r10,r8[0x0]
8000a90a:	f2 0a 18 00 	cp.b	r10,r9
8000a90e:	cf c1       	brne	8000a906 <strlen+0x6>
8000a910:	f0 0c 01 0c 	sub	r12,r8,r12
8000a914:	5e fc       	retal	r12

8000a916 <strncmp>:
8000a916:	58 0a       	cp.w	r10,0
8000a918:	c0 81       	brne	8000a928 <strncmp+0x12>
8000a91a:	5e fa       	retal	r10
8000a91c:	58 0a       	cp.w	r10,0
8000a91e:	c0 b0       	breq	8000a934 <strncmp+0x1e>
8000a920:	58 08       	cp.w	r8,0
8000a922:	c0 90       	breq	8000a934 <strncmp+0x1e>
8000a924:	2f fc       	sub	r12,-1
8000a926:	2f fb       	sub	r11,-1
8000a928:	20 1a       	sub	r10,1
8000a92a:	19 88       	ld.ub	r8,r12[0x0]
8000a92c:	17 89       	ld.ub	r9,r11[0x0]
8000a92e:	f0 09 18 00 	cp.b	r9,r8
8000a932:	cf 50       	breq	8000a91c <strncmp+0x6>
8000a934:	19 8c       	ld.ub	r12,r12[0x0]
8000a936:	17 88       	ld.ub	r8,r11[0x0]
8000a938:	10 1c       	sub	r12,r8
8000a93a:	5e fc       	retal	r12

8000a93c <_sbrk>:
8000a93c:	d4 01       	pushm	lr
8000a93e:	e0 68 2a 34 	mov	r8,10804
8000a942:	70 09       	ld.w	r9,r8[0x0]
8000a944:	58 09       	cp.w	r9,0
8000a946:	c0 41       	brne	8000a94e <_sbrk+0x12>
8000a948:	e0 69 32 90 	mov	r9,12944
8000a94c:	91 09       	st.w	r8[0x0],r9
8000a94e:	e0 69 2a 34 	mov	r9,10804
8000a952:	e0 6a f0 00 	mov	r10,61440
8000a956:	72 08       	ld.w	r8,r9[0x0]
8000a958:	f0 0c 00 0c 	add	r12,r8,r12
8000a95c:	14 3c       	cp.w	r12,r10
8000a95e:	e0 8b 00 04 	brhi	8000a966 <_sbrk+0x2a>
8000a962:	93 0c       	st.w	r9[0x0],r12
8000a964:	c0 58       	rjmp	8000a96e <_sbrk+0x32>
8000a966:	c0 7c       	rcall	8000a974 <__errno>
8000a968:	30 c8       	mov	r8,12
8000a96a:	99 08       	st.w	r12[0x0],r8
8000a96c:	3f f8       	mov	r8,-1
8000a96e:	10 9c       	mov	r12,r8
8000a970:	d8 02       	popm	pc
8000a972:	d7 03       	nop

8000a974 <__errno>:
8000a974:	e0 68 05 28 	mov	r8,1320
8000a978:	70 0c       	ld.w	r12,r8[0x0]
8000a97a:	2f 4c       	sub	r12,-12
8000a97c:	5e fc       	retal	r12
8000a97e:	d7 03       	nop

8000a980 <_malloc_trim_r>:
8000a980:	d4 21       	pushm	r4-r7,lr
8000a982:	16 95       	mov	r5,r11
8000a984:	18 97       	mov	r7,r12
8000a986:	ca af       	rcall	8000a8da <__malloc_lock>
8000a988:	32 84       	mov	r4,40
8000a98a:	68 28       	ld.w	r8,r4[0x8]
8000a98c:	70 16       	ld.w	r6,r8[0x4]
8000a98e:	e0 16 ff fc 	andl	r6,0xfffc
8000a992:	ec c8 ff 91 	sub	r8,r6,-111
8000a996:	f0 05 01 05 	sub	r5,r8,r5
8000a99a:	e0 15 ff 80 	andl	r5,0xff80
8000a99e:	ea c5 00 80 	sub	r5,r5,128
8000a9a2:	e0 45 00 7f 	cp.w	r5,127
8000a9a6:	e0 8a 00 22 	brle	8000a9ea <_malloc_trim_r+0x6a>
8000a9aa:	30 0b       	mov	r11,0
8000a9ac:	0e 9c       	mov	r12,r7
8000a9ae:	c9 9f       	rcall	8000a8e0 <_sbrk_r>
8000a9b0:	68 28       	ld.w	r8,r4[0x8]
8000a9b2:	0c 08       	add	r8,r6
8000a9b4:	10 3c       	cp.w	r12,r8
8000a9b6:	c1 a1       	brne	8000a9ea <_malloc_trim_r+0x6a>
8000a9b8:	ea 0b 11 00 	rsub	r11,r5,0
8000a9bc:	0e 9c       	mov	r12,r7
8000a9be:	c9 1f       	rcall	8000a8e0 <_sbrk_r>
8000a9c0:	5b fc       	cp.w	r12,-1
8000a9c2:	c1 71       	brne	8000a9f0 <_malloc_trim_r+0x70>
8000a9c4:	30 0b       	mov	r11,0
8000a9c6:	0e 9c       	mov	r12,r7
8000a9c8:	c8 cf       	rcall	8000a8e0 <_sbrk_r>
8000a9ca:	68 28       	ld.w	r8,r4[0x8]
8000a9cc:	f8 08 01 09 	sub	r9,r12,r8
8000a9d0:	58 f9       	cp.w	r9,15
8000a9d2:	e0 8a 00 0c 	brle	8000a9ea <_malloc_trim_r+0x6a>
8000a9d6:	a1 a9       	sbr	r9,0x0
8000a9d8:	91 19       	st.w	r8[0x4],r9
8000a9da:	e0 68 04 34 	mov	r8,1076
8000a9de:	70 09       	ld.w	r9,r8[0x0]
8000a9e0:	e0 68 2a 0c 	mov	r8,10764
8000a9e4:	f8 09 01 09 	sub	r9,r12,r9
8000a9e8:	91 09       	st.w	r8[0x0],r9
8000a9ea:	0e 9c       	mov	r12,r7
8000a9ec:	c7 8f       	rcall	8000a8dc <__malloc_unlock>
8000a9ee:	d8 2a       	popm	r4-r7,pc,r12=0
8000a9f0:	68 28       	ld.w	r8,r4[0x8]
8000a9f2:	0a 16       	sub	r6,r5
8000a9f4:	a1 a6       	sbr	r6,0x0
8000a9f6:	91 16       	st.w	r8[0x4],r6
8000a9f8:	e0 68 2a 0c 	mov	r8,10764
8000a9fc:	70 09       	ld.w	r9,r8[0x0]
8000a9fe:	0a 19       	sub	r9,r5
8000aa00:	0e 9c       	mov	r12,r7
8000aa02:	91 09       	st.w	r8[0x0],r9
8000aa04:	c6 cf       	rcall	8000a8dc <__malloc_unlock>
8000aa06:	da 2a       	popm	r4-r7,pc,r12=1

8000aa08 <_free_r>:
8000aa08:	d4 21       	pushm	r4-r7,lr
8000aa0a:	16 96       	mov	r6,r11
8000aa0c:	18 97       	mov	r7,r12
8000aa0e:	58 0b       	cp.w	r11,0
8000aa10:	e0 80 00 bb 	breq	8000ab86 <_free_r+0x17e>
8000aa14:	c6 3f       	rcall	8000a8da <__malloc_lock>
8000aa16:	20 86       	sub	r6,8
8000aa18:	32 8a       	mov	r10,40
8000aa1a:	6c 18       	ld.w	r8,r6[0x4]
8000aa1c:	74 2e       	ld.w	lr,r10[0x8]
8000aa1e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000aa22:	a1 c8       	cbr	r8,0x0
8000aa24:	ec 08 00 09 	add	r9,r6,r8
8000aa28:	72 1b       	ld.w	r11,r9[0x4]
8000aa2a:	e0 1b ff fc 	andl	r11,0xfffc
8000aa2e:	1c 39       	cp.w	r9,lr
8000aa30:	c1 d1       	brne	8000aa6a <_free_r+0x62>
8000aa32:	f6 08 00 08 	add	r8,r11,r8
8000aa36:	58 0c       	cp.w	r12,0
8000aa38:	c0 81       	brne	8000aa48 <_free_r+0x40>
8000aa3a:	6c 09       	ld.w	r9,r6[0x0]
8000aa3c:	12 16       	sub	r6,r9
8000aa3e:	12 08       	add	r8,r9
8000aa40:	6c 3b       	ld.w	r11,r6[0xc]
8000aa42:	6c 29       	ld.w	r9,r6[0x8]
8000aa44:	97 29       	st.w	r11[0x8],r9
8000aa46:	93 3b       	st.w	r9[0xc],r11
8000aa48:	10 99       	mov	r9,r8
8000aa4a:	95 26       	st.w	r10[0x8],r6
8000aa4c:	a1 a9       	sbr	r9,0x0
8000aa4e:	8d 19       	st.w	r6[0x4],r9
8000aa50:	e0 69 04 30 	mov	r9,1072
8000aa54:	72 09       	ld.w	r9,r9[0x0]
8000aa56:	12 38       	cp.w	r8,r9
8000aa58:	c0 63       	brcs	8000aa64 <_free_r+0x5c>
8000aa5a:	e0 68 2a 08 	mov	r8,10760
8000aa5e:	0e 9c       	mov	r12,r7
8000aa60:	70 0b       	ld.w	r11,r8[0x0]
8000aa62:	c8 ff       	rcall	8000a980 <_malloc_trim_r>
8000aa64:	0e 9c       	mov	r12,r7
8000aa66:	c3 bf       	rcall	8000a8dc <__malloc_unlock>
8000aa68:	d8 22       	popm	r4-r7,pc
8000aa6a:	93 1b       	st.w	r9[0x4],r11
8000aa6c:	58 0c       	cp.w	r12,0
8000aa6e:	c0 30       	breq	8000aa74 <_free_r+0x6c>
8000aa70:	30 0c       	mov	r12,0
8000aa72:	c1 08       	rjmp	8000aa92 <_free_r+0x8a>
8000aa74:	6c 0e       	ld.w	lr,r6[0x0]
8000aa76:	f4 c5 ff f8 	sub	r5,r10,-8
8000aa7a:	1c 16       	sub	r6,lr
8000aa7c:	1c 08       	add	r8,lr
8000aa7e:	6c 2e       	ld.w	lr,r6[0x8]
8000aa80:	0a 3e       	cp.w	lr,r5
8000aa82:	f9 bc 00 01 	moveq	r12,1
8000aa86:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000aa8a:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000aa8e:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000aa92:	f2 0b 00 0e 	add	lr,r9,r11
8000aa96:	7c 1e       	ld.w	lr,lr[0x4]
8000aa98:	ed be 00 00 	bld	lr,0x0
8000aa9c:	c1 30       	breq	8000aac2 <_free_r+0xba>
8000aa9e:	16 08       	add	r8,r11
8000aaa0:	58 0c       	cp.w	r12,0
8000aaa2:	c0 c1       	brne	8000aaba <_free_r+0xb2>
8000aaa4:	32 8e       	mov	lr,40
8000aaa6:	72 2b       	ld.w	r11,r9[0x8]
8000aaa8:	2f 8e       	sub	lr,-8
8000aaaa:	1c 3b       	cp.w	r11,lr
8000aaac:	c0 71       	brne	8000aaba <_free_r+0xb2>
8000aaae:	97 36       	st.w	r11[0xc],r6
8000aab0:	97 26       	st.w	r11[0x8],r6
8000aab2:	8d 2b       	st.w	r6[0x8],r11
8000aab4:	8d 3b       	st.w	r6[0xc],r11
8000aab6:	30 1c       	mov	r12,1
8000aab8:	c0 58       	rjmp	8000aac2 <_free_r+0xba>
8000aaba:	72 2b       	ld.w	r11,r9[0x8]
8000aabc:	72 39       	ld.w	r9,r9[0xc]
8000aabe:	93 2b       	st.w	r9[0x8],r11
8000aac0:	97 39       	st.w	r11[0xc],r9
8000aac2:	10 99       	mov	r9,r8
8000aac4:	ec 08 09 08 	st.w	r6[r8],r8
8000aac8:	a1 a9       	sbr	r9,0x0
8000aaca:	8d 19       	st.w	r6[0x4],r9
8000aacc:	58 0c       	cp.w	r12,0
8000aace:	c5 a1       	brne	8000ab82 <_free_r+0x17a>
8000aad0:	e0 48 01 ff 	cp.w	r8,511
8000aad4:	e0 8b 00 13 	brhi	8000aafa <_free_r+0xf2>
8000aad8:	a3 98       	lsr	r8,0x3
8000aada:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000aade:	72 2b       	ld.w	r11,r9[0x8]
8000aae0:	8d 39       	st.w	r6[0xc],r9
8000aae2:	8d 2b       	st.w	r6[0x8],r11
8000aae4:	97 36       	st.w	r11[0xc],r6
8000aae6:	93 26       	st.w	r9[0x8],r6
8000aae8:	a3 48       	asr	r8,0x2
8000aaea:	74 19       	ld.w	r9,r10[0x4]
8000aaec:	30 1b       	mov	r11,1
8000aaee:	f6 08 09 48 	lsl	r8,r11,r8
8000aaf2:	f3 e8 10 08 	or	r8,r9,r8
8000aaf6:	95 18       	st.w	r10[0x4],r8
8000aaf8:	c4 58       	rjmp	8000ab82 <_free_r+0x17a>
8000aafa:	f0 09 16 09 	lsr	r9,r8,0x9
8000aafe:	58 49       	cp.w	r9,4
8000ab00:	e0 8b 00 06 	brhi	8000ab0c <_free_r+0x104>
8000ab04:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ab08:	2c 8b       	sub	r11,-56
8000ab0a:	c2 08       	rjmp	8000ab4a <_free_r+0x142>
8000ab0c:	59 49       	cp.w	r9,20
8000ab0e:	e0 8b 00 05 	brhi	8000ab18 <_free_r+0x110>
8000ab12:	f2 cb ff a5 	sub	r11,r9,-91
8000ab16:	c1 a8       	rjmp	8000ab4a <_free_r+0x142>
8000ab18:	e0 49 00 54 	cp.w	r9,84
8000ab1c:	e0 8b 00 06 	brhi	8000ab28 <_free_r+0x120>
8000ab20:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ab24:	29 2b       	sub	r11,-110
8000ab26:	c1 28       	rjmp	8000ab4a <_free_r+0x142>
8000ab28:	e0 49 01 54 	cp.w	r9,340
8000ab2c:	e0 8b 00 06 	brhi	8000ab38 <_free_r+0x130>
8000ab30:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ab34:	28 9b       	sub	r11,-119
8000ab36:	c0 a8       	rjmp	8000ab4a <_free_r+0x142>
8000ab38:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ab3c:	e0 49 05 54 	cp.w	r9,1364
8000ab40:	e0 88 00 04 	brls	8000ab48 <_free_r+0x140>
8000ab44:	37 eb       	mov	r11,126
8000ab46:	c0 28       	rjmp	8000ab4a <_free_r+0x142>
8000ab48:	28 4b       	sub	r11,-124
8000ab4a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ab4e:	78 29       	ld.w	r9,r12[0x8]
8000ab50:	18 39       	cp.w	r9,r12
8000ab52:	c0 e1       	brne	8000ab6e <_free_r+0x166>
8000ab54:	74 18       	ld.w	r8,r10[0x4]
8000ab56:	a3 4b       	asr	r11,0x2
8000ab58:	30 1c       	mov	r12,1
8000ab5a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ab5e:	f1 eb 10 0b 	or	r11,r8,r11
8000ab62:	12 98       	mov	r8,r9
8000ab64:	95 1b       	st.w	r10[0x4],r11
8000ab66:	c0 a8       	rjmp	8000ab7a <_free_r+0x172>
8000ab68:	72 29       	ld.w	r9,r9[0x8]
8000ab6a:	18 39       	cp.w	r9,r12
8000ab6c:	c0 60       	breq	8000ab78 <_free_r+0x170>
8000ab6e:	72 1a       	ld.w	r10,r9[0x4]
8000ab70:	e0 1a ff fc 	andl	r10,0xfffc
8000ab74:	14 38       	cp.w	r8,r10
8000ab76:	cf 93       	brcs	8000ab68 <_free_r+0x160>
8000ab78:	72 38       	ld.w	r8,r9[0xc]
8000ab7a:	8d 38       	st.w	r6[0xc],r8
8000ab7c:	8d 29       	st.w	r6[0x8],r9
8000ab7e:	93 36       	st.w	r9[0xc],r6
8000ab80:	91 26       	st.w	r8[0x8],r6
8000ab82:	0e 9c       	mov	r12,r7
8000ab84:	ca ce       	rcall	8000a8dc <__malloc_unlock>
8000ab86:	d8 22       	popm	r4-r7,pc

Disassembly of section .exception:

8000ac00 <_evba>:
8000ac00:	c0 08       	rjmp	8000ac00 <_evba>
	...

8000ac04 <_handle_TLB_Multiple_Hit>:
8000ac04:	c0 08       	rjmp	8000ac04 <_handle_TLB_Multiple_Hit>
	...

8000ac08 <_handle_Bus_Error_Data_Fetch>:
8000ac08:	c0 08       	rjmp	8000ac08 <_handle_Bus_Error_Data_Fetch>
	...

8000ac0c <_handle_Bus_Error_Instruction_Fetch>:
8000ac0c:	c0 08       	rjmp	8000ac0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ac10 <_handle_NMI>:
8000ac10:	c0 08       	rjmp	8000ac10 <_handle_NMI>
	...

8000ac14 <_handle_Instruction_Address>:
8000ac14:	c0 08       	rjmp	8000ac14 <_handle_Instruction_Address>
	...

8000ac18 <_handle_ITLB_Protection>:
8000ac18:	c0 08       	rjmp	8000ac18 <_handle_ITLB_Protection>
	...

8000ac1c <_handle_Breakpoint>:
8000ac1c:	c0 08       	rjmp	8000ac1c <_handle_Breakpoint>
	...

8000ac20 <_handle_Illegal_Opcode>:
8000ac20:	c0 08       	rjmp	8000ac20 <_handle_Illegal_Opcode>
	...

8000ac24 <_handle_Unimplemented_Instruction>:
8000ac24:	c0 08       	rjmp	8000ac24 <_handle_Unimplemented_Instruction>
	...

8000ac28 <_handle_Privilege_Violation>:
8000ac28:	c0 08       	rjmp	8000ac28 <_handle_Privilege_Violation>
	...

8000ac2c <_handle_Floating_Point>:
8000ac2c:	c0 08       	rjmp	8000ac2c <_handle_Floating_Point>
	...

8000ac30 <_handle_Coprocessor_Absent>:
8000ac30:	c0 08       	rjmp	8000ac30 <_handle_Coprocessor_Absent>
	...

8000ac34 <_handle_Data_Address_Read>:
8000ac34:	c0 08       	rjmp	8000ac34 <_handle_Data_Address_Read>
	...

8000ac38 <_handle_Data_Address_Write>:
8000ac38:	c0 08       	rjmp	8000ac38 <_handle_Data_Address_Write>
	...

8000ac3c <_handle_DTLB_Protection_Read>:
8000ac3c:	c0 08       	rjmp	8000ac3c <_handle_DTLB_Protection_Read>
	...

8000ac40 <_handle_DTLB_Protection_Write>:
8000ac40:	c0 08       	rjmp	8000ac40 <_handle_DTLB_Protection_Write>
	...

8000ac44 <_handle_DTLB_Modified>:
8000ac44:	c0 08       	rjmp	8000ac44 <_handle_DTLB_Modified>
	...

8000ac50 <_handle_ITLB_Miss>:
8000ac50:	c0 08       	rjmp	8000ac50 <_handle_ITLB_Miss>
	...

8000ac60 <_handle_DTLB_Miss_Read>:
8000ac60:	c0 08       	rjmp	8000ac60 <_handle_DTLB_Miss_Read>
	...

8000ac70 <_handle_DTLB_Miss_Write>:
8000ac70:	c0 08       	rjmp	8000ac70 <_handle_DTLB_Miss_Write>
	...

8000ad00 <_handle_Supervisor_Call>:
8000ad00:	c0 08       	rjmp	8000ad00 <_handle_Supervisor_Call>
8000ad02:	d7 03       	nop

8000ad04 <_int0>:
8000ad04:	30 0c       	mov	r12,0
8000ad06:	fe b0 bc c5 	rcall	80002690 <_get_interrupt_handler>
8000ad0a:	58 0c       	cp.w	r12,0
8000ad0c:	f8 0f 17 10 	movne	pc,r12
8000ad10:	d6 03       	rete

8000ad12 <_int1>:
8000ad12:	30 1c       	mov	r12,1
8000ad14:	fe b0 bc be 	rcall	80002690 <_get_interrupt_handler>
8000ad18:	58 0c       	cp.w	r12,0
8000ad1a:	f8 0f 17 10 	movne	pc,r12
8000ad1e:	d6 03       	rete

8000ad20 <_int2>:
8000ad20:	30 2c       	mov	r12,2
8000ad22:	fe b0 bc b7 	rcall	80002690 <_get_interrupt_handler>
8000ad26:	58 0c       	cp.w	r12,0
8000ad28:	f8 0f 17 10 	movne	pc,r12
8000ad2c:	d6 03       	rete

8000ad2e <_int3>:
8000ad2e:	30 3c       	mov	r12,3
8000ad30:	fe b0 bc b0 	rcall	80002690 <_get_interrupt_handler>
8000ad34:	58 0c       	cp.w	r12,0
8000ad36:	f8 0f 17 10 	movne	pc,r12
8000ad3a:	d6 03       	rete
8000ad3c:	d7 03       	nop
8000ad3e:	d7 03       	nop
8000ad40:	d7 03       	nop
8000ad42:	d7 03       	nop
8000ad44:	d7 03       	nop
8000ad46:	d7 03       	nop
8000ad48:	d7 03       	nop
8000ad4a:	d7 03       	nop
8000ad4c:	d7 03       	nop
8000ad4e:	d7 03       	nop
8000ad50:	d7 03       	nop
8000ad52:	d7 03       	nop
8000ad54:	d7 03       	nop
8000ad56:	d7 03       	nop
8000ad58:	d7 03       	nop
8000ad5a:	d7 03       	nop
8000ad5c:	d7 03       	nop
8000ad5e:	d7 03       	nop
8000ad60:	d7 03       	nop
8000ad62:	d7 03       	nop
8000ad64:	d7 03       	nop
8000ad66:	d7 03       	nop
8000ad68:	d7 03       	nop
8000ad6a:	d7 03       	nop
8000ad6c:	d7 03       	nop
8000ad6e:	d7 03       	nop
8000ad70:	d7 03       	nop
8000ad72:	d7 03       	nop
8000ad74:	d7 03       	nop
8000ad76:	d7 03       	nop
8000ad78:	d7 03       	nop
8000ad7a:	d7 03       	nop
8000ad7c:	d7 03       	nop
8000ad7e:	d7 03       	nop
8000ad80:	d7 03       	nop
8000ad82:	d7 03       	nop
8000ad84:	d7 03       	nop
8000ad86:	d7 03       	nop
8000ad88:	d7 03       	nop
8000ad8a:	d7 03       	nop
8000ad8c:	d7 03       	nop
8000ad8e:	d7 03       	nop
8000ad90:	d7 03       	nop
8000ad92:	d7 03       	nop
8000ad94:	d7 03       	nop
8000ad96:	d7 03       	nop
8000ad98:	d7 03       	nop
8000ad9a:	d7 03       	nop
8000ad9c:	d7 03       	nop
8000ad9e:	d7 03       	nop
8000ada0:	d7 03       	nop
8000ada2:	d7 03       	nop
8000ada4:	d7 03       	nop
8000ada6:	d7 03       	nop
8000ada8:	d7 03       	nop
8000adaa:	d7 03       	nop
8000adac:	d7 03       	nop
8000adae:	d7 03       	nop
8000adb0:	d7 03       	nop
8000adb2:	d7 03       	nop
8000adb4:	d7 03       	nop
8000adb6:	d7 03       	nop
8000adb8:	d7 03       	nop
8000adba:	d7 03       	nop
8000adbc:	d7 03       	nop
8000adbe:	d7 03       	nop
8000adc0:	d7 03       	nop
8000adc2:	d7 03       	nop
8000adc4:	d7 03       	nop
8000adc6:	d7 03       	nop
8000adc8:	d7 03       	nop
8000adca:	d7 03       	nop
8000adcc:	d7 03       	nop
8000adce:	d7 03       	nop
8000add0:	d7 03       	nop
8000add2:	d7 03       	nop
8000add4:	d7 03       	nop
8000add6:	d7 03       	nop
8000add8:	d7 03       	nop
8000adda:	d7 03       	nop
8000addc:	d7 03       	nop
8000adde:	d7 03       	nop
8000ade0:	d7 03       	nop
8000ade2:	d7 03       	nop
8000ade4:	d7 03       	nop
8000ade6:	d7 03       	nop
8000ade8:	d7 03       	nop
8000adea:	d7 03       	nop
8000adec:	d7 03       	nop
8000adee:	d7 03       	nop
8000adf0:	d7 03       	nop
8000adf2:	d7 03       	nop
8000adf4:	d7 03       	nop
8000adf6:	d7 03       	nop
8000adf8:	d7 03       	nop
8000adfa:	d7 03       	nop
8000adfc:	d7 03       	nop
8000adfe:	d7 03       	nop
