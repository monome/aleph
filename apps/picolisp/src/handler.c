/*
  handler.c

  aleph/apps/blank

  app-specific UI event handlers.

  app.c defines a global array of function pointers to handle system events.
  main.c defines its own handlers, most of which don't do anything.
  some events (e.g. ftdiConnect, monomePoll) call pretty low-level driver stuff,
  and there shouldn't be any need for applications to customize them.

  handlers that do need to be customized go here.
  define static functions,
  and then populate the global array with pointers to these functions.
  this step should happen in e.g. app_launch().

*/

// asf
#include "gpio.h"
#include "delay.h"
#include "print_funcs.h"

// aleph-avr32
#include "aleph_board.h"
#include "app.h"
#include "event_types.h"

// custom app sources
#include "handler.h"

#include "ser.h"

#include "pico.h"

///-------------------------------------
///---- event handlers

// switch handlers
static void handle_Switch0(s32 data) {
    //...
  callLisp1("switch0", box(data));
}

static void handle_Switch1(s32 data) {
  callLisp1("switch1", box(data));
}

static void handle_Switch2(s32 data) {
  callLisp1("switch2", box(data));
}

static void handle_Switch3(s32 data) {
  callLisp1("switch3", box(data));
}

// power switch handler
// note: if this isn't assigned, the power switch won't work!
static void handle_Switch5(s32 data) {
    // TODO: ... save current settings...
    delay_ms(100);
    // this pin is physically connected to the power system.
    // bringing it low causes immediate shutdown
    gpio_clr_gpio_pin(POWER_CTL_PIN);
}

// encoder handlers
static void handle_Encoder0(s32 data) {
    //...
  callLisp1("encoder0", box(data));
}

static void handle_Encoder1(s32 data) {
    //...
  callLisp1("encoder1", box(data));
}

static void handle_Encoder2(s32 data) {
    //...
  callLisp1("encoder2", box(data));
}

static void handle_Encoder3(s32 data) {
    //...
  callLisp1("encoder3", box(data));
}

//-------------------------------------
//---- extern

/// explicitly assign these...
/// this way the order of the event types enum doesn't matter.
void assign_event_handlers(void) {
    // function switches
    app_event_handlers[kEventSwitch0] = &handle_Switch0;
    app_event_handlers[kEventSwitch1] = &handle_Switch1;
    app_event_handlers[kEventSwitch2] = &handle_Switch2;
    app_event_handlers[kEventSwitch3] = &handle_Switch3;

    // power switch
    // note: if this isn't assigned, the power switch won't work!
    app_event_handlers[kEventSwitch5] = &handle_Switch5;

    // encoders
    app_event_handlers[kEventEncoder0] = &handle_Encoder0;
    app_event_handlers[kEventEncoder1] = &handle_Encoder1;
    app_event_handlers[kEventEncoder2] = &handle_Encoder2;
    app_event_handlers[kEventEncoder3] = &handle_Encoder3;

    app_event_handlers[ kEventSerial ] = &handle_Serial ;

    /*
    add more event handlers here as desired.

    event types are listed in aleph/avr32_lib/src/event_types.h

    most of them are pretty obvious.

    a notable exception is 'kEventAppCustom' :
    this event type is not generated by any of the peripheral interrupt
    handlers.
    instead, it is intended to be generated by the app itself.

    a typical case would be if the app sets a timer.
    timer handlers are called from an IRQ,
    so any heavy processing trigered by them should be deferred to the main
    loop.
    such a handler should post a kEventAppCustom event.

    */
}
